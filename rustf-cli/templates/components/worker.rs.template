use rustf::prelude::*;
use rustf::workers::WORKER;

/// {{worker_title}} worker
///
/// {{description}}
pub async fn install() -> Result<()> {
    WORKER::register("{{worker_name}}", |ctx| async move {
        ctx.info("{{worker_title}}: Starting execution");

        // Access payload if needed
        // let payload = ctx.payload()
        //     .ok_or_else(|| Error::validation("Payload required"))?;
        // let value = payload["key"].as_str()
        //     .ok_or_else(|| Error::validation("'key' field required"))?;

        // Perform your background task here
        // Example: Process data, call external APIs, update database, etc.

        // Report progress if needed (requires WORKER::call() instead of run())
        // ctx.emit(json!({"progress": 50, "status": "processing"}))?;

        ctx.info("{{worker_title}}: Completed successfully");
        Ok(())
    }).await?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustf::workers::WORKER;

    #[tokio::test]
    async fn test_{{worker_name_underscored}}_worker() {
        // Register the worker
        install().await.expect("Worker registration failed");

        // Test execution
        let result = WORKER::run("{{worker_name}}", None).await;
        assert!(result.is_ok(), "Worker should execute successfully");
    }
}
