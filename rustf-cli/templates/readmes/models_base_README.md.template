# Models Base Directory

This directory contains auto-generated base models from schema definitions. **DO NOT EDIT FILES IN THIS DIRECTORY** - they will be overwritten when schemas are regenerated.

## ğŸš¨ IMPORTANT WARNING

**ğŸš« DO NOT EDIT FILES IN THIS DIRECTORY**  
**ğŸš« DO NOT MANUALLY CREATE FILES HERE**  
**ğŸš« DO NOT COMMIT CUSTOM CHANGES HERE**

All files in this directory are automatically generated from schema definitions in the `schemas/` directory.

## ğŸ¤– AI Agent Quick Reference

**Purpose**: Auto-generated database models and CRUD operations  
**Generation**: Created by `rustf-cli schema generate` command  
**Source**: Generated from `schemas/*.yaml` files  
**Usage**: Import and extend in parent model files (e.g., `../users.rs`)  
**Editing**: Never edit - modify schemas and regenerate instead

## ğŸ“ File Organization

```
src/models/base/
â”œâ”€â”€ users_base.rs       # Generated from schemas/users.yaml
â”œâ”€â”€ posts_base.rs       # Generated from schemas/posts.yaml
â”œâ”€â”€ categories_base.rs  # Generated from schemas/categories.yaml
â””â”€â”€ ...                 # Other generated models
```

## ğŸ”„ Generation Process

### 1. Define Schema
Create `schemas/users.yaml`:
```yaml
name: users
table: users
description: "User accounts and authentication"

fields:
  id:
    type: integer
    primary_key: true
    auto_increment: true
    description: "Unique user identifier"
    
  name:
    type: string
    max_length: 100
    required: true
    description: "User's full name"
    
  email:
    type: string
    max_length: 255
    unique: true
    required: true
    description: "User's email address"
    
  password_hash:
    type: string
    max_length: 255
    required: true
    description: "Hashed password"
    
  is_active:
    type: boolean
    default: true
    description: "Account status"
    
  created_at:
    type: timestamp
    default: now
    description: "Account creation time"
    
  updated_at:
    type: timestamp  
    default: now
    on_update: now
    description: "Last update time"

indexes:
  - fields: [email]
    unique: true
  - fields: [created_at]
  - fields: [is_active, created_at]

relations:
  posts:
    type: has_many
    model: Post
    foreign_key: user_id
```

### 2. Generate Base Model
```bash
# Generate specific model
rustf-cli schema generate --model users

# Generate all models
rustf-cli schema generate --all

# Validate schema first
rustf-cli schema validate --file schemas/users.yaml
```

### 3. Generated Code Structure
The generated `users_base.rs` will contain:

```rust
// Auto-generated by RustF Schema Generator
// DO NOT EDIT - This file will be overwritten
// Source: schemas/users.yaml
// Generated: 2024-01-01 12:00:00 UTC

use serde::{Deserialize, Serialize};
use sqlx::{PgPool, FromRow, Row};
use chrono::{DateTime, Utc};
use anyhow::Result;

/// Base User model - auto-generated from schema
/// 
/// This struct contains all database fields and basic CRUD operations.
/// Extend this in ../users.rs for business logic.
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct UserBase {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub password_hash: String,
    pub is_active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Type constants for AI agent reference
/// 
/// AI agents can use these type aliases to generate consistent,
/// schema-aware code without hardcoding types.
/// 
/// Example: UserBase::Types::email resolves to String
pub mod Types {
    use chrono::{DateTime, Utc};
    
    pub type id = i32;
    pub type name = String;
    pub type email = String;
    pub type password_hash = String;
    pub type is_active = bool;
    pub type created_at = DateTime<Utc>;
    pub type updated_at = DateTime<Utc>;
}

impl UserBase {
    /// Create new user record
    pub async fn create(
        pool: &PgPool,
        name: &str,
        email: &str,
        password_hash: &str,
    ) -> Result<Self> {
        let user = sqlx::query_as!(
            UserBase,
            r#"
            INSERT INTO users (name, email, password_hash, is_active, created_at, updated_at)
            VALUES ($1, $2, $3, $4, NOW(), NOW())
            RETURNING id, name, email, password_hash, is_active, created_at, updated_at
            "#,
            name,
            email,
            password_hash,
            true
        )
        .fetch_one(pool)
        .await?;

        Ok(user)
    }

    /// Find user by ID
    pub async fn find_by_id(pool: &PgPool, id: i32) -> Result<Option<Self>> {
        let user = sqlx::query_as!(
            UserBase,
            "SELECT id, name, email, password_hash, is_active, created_at, updated_at FROM users WHERE id = $1",
            id
        )
        .fetch_optional(pool)
        .await?;

        Ok(user)
    }

    /// Find user by unique field
    pub async fn find_by_email(pool: &PgPool, email: &str) -> Result<Option<Self>> {
        let user = sqlx::query_as!(
            UserBase,
            "SELECT id, name, email, password_hash, is_active, created_at, updated_at FROM users WHERE email = $1",
            email
        )
        .fetch_optional(pool)
        .await?;

        Ok(user)
    }

    /// Find all users with optional filtering
    pub async fn find_all(pool: &PgPool, limit: Option<i64>, offset: Option<i64>) -> Result<Vec<Self>> {
        let limit = limit.unwrap_or(100);
        let offset = offset.unwrap_or(0);

        let users = sqlx::query_as!(
            UserBase,
            "SELECT id, name, email, password_hash, is_active, created_at, updated_at FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2",
            limit,
            offset
        )
        .fetch_all(pool)
        .await?;

        Ok(users)
    }

    /// Update user record
    pub async fn update(
        &mut self,
        pool: &PgPool,
        name: &str,
        email: &str,
    ) -> Result<()> {
        sqlx::query!(
            "UPDATE users SET name = $1, email = $2, updated_at = NOW() WHERE id = $3",
            name,
            email,
            self.id
        )
        .execute(pool)
        .await?;

        // Update local fields
        self.name = name.to_string();
        self.email = email.to_string();
        self.updated_at = Utc::now();

        Ok(())
    }

    /// Delete user record
    pub async fn delete(self, pool: &PgPool) -> Result<()> {
        sqlx::query!("DELETE FROM users WHERE id = $1", self.id)
            .execute(pool)
            .await?;

        Ok(())
    }

    /// Count total users
    pub async fn count(pool: &PgPool) -> Result<i64> {
        let count = sqlx::query_scalar!("SELECT COUNT(*) FROM users")
            .fetch_one(pool)
            .await?;

        Ok(count)
    }

    /// Find users with pagination
    pub async fn paginate(
        pool: &PgPool,
        page: u32,
        per_page: u32,
    ) -> Result<(Vec<Self>, i64)> {
        let offset = ((page - 1) * per_page) as i64;
        let limit = per_page as i64;

        let total = Self::count(pool).await?;
        let users = Self::find_all(pool, Some(limit), Some(offset)).await?;

        Ok((users, total))
    }

    // Additional generated methods based on schema...
}

// Schema metadata for CLI tools
pub const SCHEMA_VERSION: &str = "1.0.0";
pub const GENERATED_AT: &str = "2024-01-01T12:00:00Z";
pub const SOURCE_SCHEMA: &str = "schemas/users.yaml";
```

## ğŸ“Š Usage in Business Logic Models

Import and use in `../users.rs`:

```rust
// Import the generated base model
#[path = "base/users_base.rs"]
mod users_base;
pub use users_base::UserBase;

/// User model with business logic extending UserBase
pub struct User {
    base: UserBase,
}

impl User {
    /// Create User from base model
    pub fn from_base(base: UserBase) -> Self {
        Self { base }
    }

    /// Access to base model for database operations
    pub fn base(&self) -> &UserBase {
        &self.base
    }

    /// Business logic methods here...
    pub async fn authenticate(pool: &PgPool, email: &str, password: &str) -> Result<Option<Self>> {
        if let Some(base) = UserBase::find_by_email(pool, email).await? {
            if bcrypt::verify(password, &base.password_hash)? {
                return Ok(Some(Self::from_base(base)));
            }
        }
        Ok(None)
    }
}
```

## ğŸ”„ Regeneration Process

### When to Regenerate
- Schema definitions change in `schemas/*.yaml`
- New fields added or removed
- Index definitions modified
- Relationship definitions updated
- Database structure changes

### How to Regenerate
```bash
# Regenerate specific model
rustf-cli schema generate --model users

# Regenerate all models  
rustf-cli schema generate --all

# Validate before generation
rustf-cli schema validate --all
rustf-cli schema generate --all --validate
```

### Migration Process
1. **Backup**: Ensure business logic models are in parent directory
2. **Update Schema**: Modify `schemas/*.yaml` files
3. **Validate**: Run `rustf-cli schema validate`
4. **Generate**: Run `rustf-cli schema generate`
5. **Update Migration**: Create database migration if needed
6. **Test**: Verify business logic models still work

## ğŸš¨ What NOT to Do

### âŒ Don't Edit Generated Files
```rust
// DON'T DO THIS - changes will be lost
impl UserBase {
    pub fn my_custom_method(&self) -> String {
        // This will be overwritten!
        "custom".to_string()
    }
}
```

### âŒ Don't Commit Custom Changes
```bash
# DON'T DO THIS
git add src/models/base/users_base.rs  # Contains manual edits
git commit -m "Custom changes to base model"  # Will be overwritten!
```

### âŒ Don't Import Base Models Directly in Controllers
```rust
// DON'T DO THIS in controllers
use crate::models::base::users_base::UserBase;

// DO THIS instead
use crate::models::users::User;
```

## âœ… What TO Do

### âœ… Extend in Business Logic Models
```rust
// In ../users.rs - DO THIS
impl User {
    pub fn my_custom_method(&self) -> String {
        format!("User: {}", self.base.name)
    }
    
    pub async fn custom_query(pool: &PgPool) -> Result<Vec<Self>> {
        // Custom business logic using base model
        let bases = UserBase::find_all(pool, None, None).await?;
        Ok(bases.into_iter().map(Self::from_base).collect())
    }
}
```

### âœ… Modify Schemas and Regenerate
```bash
# DO THIS
vim schemas/users.yaml  # Edit schema
rustf-cli schema generate --model users  # Regenerate
```

### âœ… Use Business Logic Models
```rust
// In controllers - DO THIS
use crate::models::users::User;

async fn get_user(ctx: Context) -> Result<Response> {
    let user = User::find_by_id(&ctx.db, id).await?;
    // Use business logic methods
}
```

## ğŸ¤– Type Constants Pattern for AI Agents

Each generated base model includes a `Types` module with type aliases for every database field. This enables AI agents to generate schema-aware, type-safe code without hardcoding types.

### ğŸ“– Type Constants Usage Pattern

**Instead of hardcoding types:**
```rust
// âŒ AVOID: Hardcoded types (breaks on schema changes)
pub struct UserSummary {
    pub id: i64,           // Hardcoded - might be wrong type
    pub name: String,      // Hardcoded
    pub email: String,     // Hardcoded
}

pub fn get_user_email(id: i64) -> String {  // Hardcoded types
    // ...
}
```

**Use type constants instead:**
```rust
// âœ… PREFERRED: Schema-aware types
pub struct UserSummary {
    pub id: UserBase::Types::id,           // = i32 (from schema)
    pub name: UserBase::Types::name,       // = String
    pub email: UserBase::Types::email,     // = String
}

pub fn get_user_email(id: UserBase::Types::id) -> UserBase::Types::email {
    // Types automatically match database schema
}
```

### ğŸ” AI Agent Type Discovery Pattern

**Step 1: Read the base model file**
```rust
// AI agent reads: src/models/base/users_base.rs
// Discovers: UserBase::Types::email = String
// Discovers: UserBase::Types::created_at = DateTime<Utc>
// Discovers: UserBase::Types::id = i32
```

**Step 2: Generate schema-aware code**
```rust
// AI agent generates type-safe function signatures:
pub async fn find_user_by_email(
    pool: &Pool<MySql>,
    email: UserBase::Types::email  // = String, but schema-derived
) -> Result<Option<UserBase>> {
    UserBase::find_by_email(pool, &email).await
}

pub async fn update_user_status(
    pool: &Pool<MySql>,
    id: UserBase::Types::id,                    // = i32
    is_active: UserBase::Types::is_active       // = bool
) -> Result<()> {
    // ...
}
```

**Step 3: Generate query result structs**
```rust
// AI agent generates projection structs using type constants:
#[derive(Debug, Serialize, FromRow)]
pub struct UserProfile {
    pub id: UserBase::Types::id,
    pub name: UserBase::Types::name,
    pub email: UserBase::Types::email,
    pub created_at: UserBase::Types::created_at,
}

#[derive(Debug, Serialize, FromRow)]
pub struct UserNameOnly {
    pub name: UserBase::Types::name,  // Always matches schema
}
```

### ğŸš€ AI Code Generation Examples

**Dynamic Query Building:**
```rust
// AI agent can build queries using type information
let user_fields = vec![
    ("id", "UserBase::Types::id"),
    ("name", "UserBase::Types::name"),
    ("email", "UserBase::Types::email"),
];

// Generate custom projection struct
pub struct CustomUserView {
    pub id: UserBase::Types::id,
    pub name: UserBase::Types::name,
    pub email: UserBase::Types::email,
}
```

**Business Logic Generation:**
```rust
// AI agent generates validation methods using schema types
impl User {
    pub fn validate_email(email: &UserBase::Types::email) -> bool {
        email.contains('@') && email.len() <= 255  // Schema-aware validation
    }
    
    pub fn format_display_name(&self) -> String {
        // AI knows name field type from UserBase::Types::name
        format!("User: {}", self.base.name)
    }
}
```

**Form and API Generation:**
```rust
// AI agent generates forms with correct types
#[derive(Debug, Deserialize)]
pub struct CreateUserRequest {
    pub name: UserBase::Types::name,
    pub email: UserBase::Types::email,
    pub password: String,  // Not in schema - business logic type
}

#[derive(Debug, Serialize)]
pub struct UserResponse {
    pub id: UserBase::Types::id,
    pub name: UserBase::Types::name,
    pub email: UserBase::Types::email,
    pub created_at: UserBase::Types::created_at,
    // password_hash excluded for security
}
```

### ğŸ”„ Schema Evolution Benefits

When database schema changes, type constants automatically update:

```rust
// Schema change: email VARCHAR(255) -> TEXT
// Before regeneration: UserBase::Types::email = String (max 255)
// After regeneration: UserBase::Types::email = String (unlimited)
// AI-generated code automatically adapts!

// Schema change: id INTEGER -> BIGINT  
// Before: UserBase::Types::id = i32
// After: UserBase::Types::id = i64
// All AI-generated functions using UserBase::Types::id adapt automatically
```

### ğŸ“‹ AI Agent Best Practices

1. **Always read Types module first** - Parse `pub mod Types { ... }` to understand available types
2. **Use type constants in all generated code** - Never hardcode `i32`, `String`, etc.
3. **Generate validation based on types** - Use type information for business rules
4. **Create projections with type constants** - Build query result structs using schema types
5. **Update code on schema changes** - Regenerate when Types module changes

## ğŸ¤– AI Agent Instructions

When working with base models:
1. **Never edit files in `base/` directory** - they are auto-generated
2. **Always work in parent model files** (e.g., `../users.rs`)
3. **Import base models with `#[path = "base/model_base.rs"]`**
4. **Use ModelBase::Types::field_name for all type references**
5. **Read Types module to discover available field types**
6. **Generate schema-aware code using type constants**
7. **Extend functionality in business logic layer**
8. **Use `rustf-cli schema generate` to recreate base models**
9. **Modify schemas in `schemas/` directory instead of base models**
10. **Test after regeneration** to ensure business logic still works

**Schema First**: Always define your data structure in schemas, then generate base models, then add business logic.

**Type Safety**: Use ModelBase::Types::field_name instead of hardcoding types for automatic schema evolution.

**Separation of Concerns**: Base models handle database operations, business logic models handle validation and complex operations.