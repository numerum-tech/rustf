<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>RustF Framework Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Complete guide to the RustF MVC web framework for Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="README.html">Introduction</a></li><li><a href="getting-started/README.html"><strong>1.</strong> Quick Start</a></li><li><a href="getting-started/installation.html"><strong>2.</strong> Installation</a></li><li><a href="getting-started/hello-world.html"><strong>3.</strong> Hello World</a></li><li><a href="getting-started/project-structure.html"><strong>4.</strong> Project Structure</a></li><li><a href="guides/controllers.html"><strong>5.</strong> Controllers &amp; Routing</a></li><li><a href="guides/views.html"><strong>6.</strong> Views &amp; Templates</a></li><li><a href="guides/middleware.html"><strong>7.</strong> Middleware</a></li><li><a href="guides/sessions.html"><strong>8.</strong> Sessions</a></li><li><a href="guides/database.html"><strong>9.</strong> Database Integration</a></li><li><a href="guides/configuration.html"><strong>10.</strong> Configuration</a></li><li><a href="guides/security.html"><strong>11.</strong> Security</a></li><li><a href="guides/error-handling.html"><strong>12.</strong> Error Handling</a></li><li><a href="guides/schemas.html"><strong>13.</strong> Schemas &amp; Definitions</a></li><li><a href="advanced/README.html"><strong>14.</strong> Overview</a></li><li><a href="advanced/performance.html"><strong>15.</strong> Performance Optimization</a></li><li><a href="advanced/workers.html"><strong>16.</strong> Workers</a></li><li><a href="advanced/events.html"><strong>17.</strong> Events</a></li><li><a href="advanced/modules.html"><strong>18.</strong> Modules</a></li><li><a href="advanced/cli.html"><strong>19.</strong> CLI Tool</a></li><li><a href="api-reference/README.html"><strong>20.</strong> Overview</a></li><li><a href="api-reference/context.html"><strong>21.</strong> Context API</a></li><li><a href="api-reference/models.html"><strong>22.</strong> Model API</a></li><li><a href="api-reference/routing.html"><strong>23.</strong> Routing API</a></li><li><a href="api-reference/utilities.html"><strong>24.</strong> Utilities</a></li><li><a href="examples/README.html"><strong>25.</strong> Overview</a></li><li><a href="examples/rest-api.html"><strong>26.</strong> Building a REST API</a></li><li><a href="examples/authentication.html"><strong>27.</strong> Authentication</a></li><li><a href="examples/real-world-app.html"><strong>28.</strong> Real-World Application</a></li><li><a href="deployment/production.html"><strong>29.</strong> Production Deployment</a></li><li><a href="deployment/docker.html"><strong>30.</strong> Docker</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">RustF Framework Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#rustf-framework-documentation" id="rustf-framework-documentation"><h1>RustF Framework Documentation</h1></a>
<div align="center">
<p>ğŸ¤– <strong>AI-Agent Optimized</strong> | ğŸš€ <strong>Production Ready</strong> | ğŸ›¡ï¸ <strong>Enterprise Security</strong> | âš¡ <strong>High Performance</strong></p>
</div>
<a class="header" href="print.html#welcome-to-rustf" id="welcome-to-rustf"><h2>Welcome to RustF</h2></a>
<p>RustF is a convention-based MVC web framework for Rust, inspired by <a href="https://www.totaljs.com/">Total.js</a> v4. Designed to be equally intuitive for human developers and AI coding assistants, with auto-discovery, predictable patterns, comprehensive documentation, enterprise-grade security, and optimized performance.</p>
<a class="header" href="print.html#what-is-rustf" id="what-is-rustf"><h3>What is RustF?</h3></a>
<p>RustF provides a complete web development stack for Rust applications:</p>
<ul>
<li><strong>Convention Over Configuration</strong> - Sensible defaults reduce boilerplate</li>
<li><strong>AI-Friendly Development</strong> - Predictable patterns and comprehensive documentation</li>
<li><strong>Total.js Inspiration</strong> - Familiar patterns for web developers</li>
<li><strong>Type Safety</strong> - Compile-time validation throughout the stack</li>
<li><strong>Auto-Discovery</strong> - Automatic component registration at build time</li>
<li><strong>Schema-Driven</strong> - YAML schemas drive model generation and database tools</li>
</ul>
<a class="header" href="print.html#key-features" id="key-features"><h3>Key Features</h3></a>
<p>âœ… <strong>Auto-Discovery System</strong> - Automatic registration of controllers, models, middleware<br />
âœ… <strong>Convention-Based Architecture</strong> - Predictable project structure and patterns<br />
âœ… <strong>Comprehensive CLI Tools</strong> - Project scaffolding, schema management, database tools<br />
âœ… <strong>Template Engine</strong> - Total.js-style template system with layouts and partials<br />
âœ… <strong>Advanced Session Management</strong> - Memory, Redis, and database storage backends<br />
âœ… <strong>Built-in Security Features</strong> - CORS, CSRF protection, secure headers<br />
âœ… <strong>Database Tools</strong> - Multi-database query builder with schema management<br />
âœ… <strong>Performance Optimized</strong> - Request pooling, caching, and memory safety</p>
<a class="header" href="print.html#quick-start" id="quick-start"><h2>Quick Start</h2></a>
<p>Get started with RustF in just 3 commands:</p>
<pre><code class="language-bash"># Using the CLI tool (recommended)
rustf-cli new project my-app
cd my-app
cargo run
</code></pre>
<p>Visit <a href="getting-started/README.md">Getting Started</a> for detailed installation and setup instructions.</p>
<a class="header" href="print.html#documentation-structure" id="documentation-structure"><h2>Documentation Structure</h2></a>
<p>This documentation is organized to help you learn RustF at your own pace:</p>
<a class="header" href="print.html#-a-hrefgetting-startedreadmemdgetting-starteda" id="-a-hrefgetting-startedreadmemdgetting-starteda"><h3>ğŸš€ <a href="getting-started/README.md">Getting Started</a></h3></a>
<p>Perfect for beginners. Learn how to install RustF, create your first application, and understand the project structure.</p>
<a class="header" href="print.html#-a-hrefguidescontrollersmdcore-guidesa" id="-a-hrefguidescontrollersmdcore-guidesa"><h3>ğŸ“– <a href="guides/controllers.md">Core Guides</a></h3></a>
<p>Essential framework concepts: controllers, views, middleware, sessions, databases, and more.</p>
<a class="header" href="print.html#-a-hrefadvancedperformancemdadvanced-topicsa" id="-a-hrefadvancedperformancemdadvanced-topicsa"><h3>ğŸ”§ <a href="advanced/performance.md">Advanced Topics</a></h3></a>
<p>For experienced developers: performance optimization, workers, events, and advanced patterns.</p>
<a class="header" href="print.html#-a-hrefapi-referencecontextmdapi-referencea" id="-a-hrefapi-referencecontextmdapi-referencea"><h3>ğŸ“š <a href="api-reference/context.md">API Reference</a></h3></a>
<p>Complete API documentation for all framework components.</p>
<a class="header" href="print.html#-a-hrefexamplesrest-apimdexamples--tutorialsa" id="-a-hrefexamplesrest-apimdexamples--tutorialsa"><h3>ğŸ’¡ <a href="examples/rest-api.md">Examples &amp; Tutorials</a></h3></a>
<p>Step-by-step tutorials for building real-world applications.</p>
<a class="header" href="print.html#-a-hrefdeploymentproductionmddeploymenta" id="-a-hrefdeploymentproductionmddeploymenta"><h3>ğŸš¢ <a href="deployment/production.md">Deployment</a></h3></a>
<p>Production deployment guides, Docker setup, and performance tuning.</p>
<a class="header" href="print.html#who-is-this-documentation-for" id="who-is-this-documentation-for"><h2>Who is This Documentation For?</h2></a>
<a class="header" href="print.html#beginners" id="beginners"><h3>Beginners</h3></a>
<ul>
<li>Start with <a href="getting-started/README.md">Getting Started</a></li>
<li>Follow the <a href="getting-started/hello-world.md">Hello World</a> tutorial</li>
<li>Read through <a href="guides/controllers.md">Core Guides</a> step by step</li>
<li>Check out <a href="examples/rest-api.md">Examples</a> for practical applications</li>
</ul>
<a class="header" href="print.html#experienced-developers" id="experienced-developers"><h3>Experienced Developers</h3></a>
<ul>
<li>Jump to <a href="guides/controllers.md">Core Guides</a> for framework concepts</li>
<li>Explore <a href="advanced/performance.md">Advanced Topics</a> for optimization</li>
<li>Reference <a href="api-reference/context.md">API Reference</a> for detailed APIs</li>
<li>Review <a href="deployment/production.md">Deployment</a> for production setup</li>
</ul>
<a class="header" href="print.html#ai-coding-assistants" id="ai-coding-assistants"><h3>AI Coding Assistants</h3></a>
<ul>
<li>Structured documentation with clear patterns</li>
<li>Comprehensive API references</li>
<li>Predictable conventions</li>
<li>Code examples throughout</li>
</ul>
<a class="header" href="print.html#framework-philosophy" id="framework-philosophy"><h2>Framework Philosophy</h2></a>
<p>RustF follows these core principles:</p>
<ol>
<li><strong>Convention Over Configuration</strong> - Sensible defaults mean less code</li>
<li><strong>Type Safety First</strong> - Compile-time validation prevents runtime errors</li>
<li><strong>AI-Friendly</strong> - Predictable patterns make it easy for AI assistants to help</li>
<li><strong>Performance by Default</strong> - Optimized for speed and efficiency</li>
<li><strong>Security Built-In</strong> - Enterprise-grade security features included</li>
</ol>
<a class="header" href="print.html#community--support" id="community--support"><h2>Community &amp; Support</h2></a>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/numerum-tech/rustf">github.com/numerum-tech/rustf</a></li>
<li><strong>Issues</strong>: Report bugs and request features</li>
<li><strong>Discussions</strong>: Ask questions and share ideas</li>
</ul>
<a class="header" href="print.html#contributing" id="contributing"><h2>Contributing</h2></a>
<p>We welcome contributions! The framework was developed with AI collaboration and we actively seek feedback from the Rust community to improve code quality, safety, and performance.</p>
<a class="header" href="print.html#license" id="license"><h2>License</h2></a>
<p>RustF is dual-licensed under MIT and Apache 2.0 licenses.</p>
<hr />
<p><strong>Ready to get started?</strong> Head to <a href="getting-started/README.md">Getting Started</a> to begin your RustF journey!</p>
<a class="header" href="print.html#getting-started-with-rustf" id="getting-started-with-rustf"><h1>Getting Started with RustF</h1></a>
<p>Welcome to RustF! This guide will help you get up and running with the framework in minutes.</p>
<a class="header" href="print.html#what-youll-learn" id="what-youll-learn"><h2>What You'll Learn</h2></a>
<p>In this section, you'll learn:</p>
<ol>
<li>How to install RustF and its dependencies</li>
<li>How to create your first &quot;Hello World&quot; application</li>
<li>How to understand the project structure</li>
<li>Basic development workflow</li>
</ol>
<a class="header" href="print.html#prerequisites" id="prerequisites"><h2>Prerequisites</h2></a>
<p>Before you begin, make sure you have:</p>
<ul>
<li><strong>Rust 1.70+</strong> installed (<a href="https://rustup.rs/">rustup.rs</a>)</li>
<li><strong>Cargo</strong> (comes with Rust)</li>
<li>Basic familiarity with Rust syntax</li>
<li>A text editor or IDE (VS Code, RustRover, etc.)</li>
</ul>
<a class="header" href="print.html#quick-start-3-steps" id="quick-start-3-steps"><h2>Quick Start (3 Steps)</h2></a>
<p>The fastest way to get started:</p>
<pre><code class="language-bash"># 1. Create a new project using the CLI
rustf-cli new project my-app

# 2. Navigate to your project
cd my-app

# 3. Run the server
cargo run
</code></pre>
<p>That's it! Your server will be running at <code>http://127.0.0.1:8000</code>.</p>
<a class="header" href="print.html#whats-next" id="whats-next"><h2>What's Next?</h2></a>
<ul>
<li><strong><a href="installation.md">Installation</a></strong> - Detailed installation instructions and setup</li>
<li><strong><a href="hello-world.md">Hello World</a></strong> - Build your first application step-by-step</li>
<li><strong><a href="project-structure.md">Project Structure</a></strong> - Understand how RustF projects are organized</li>
</ul>
<a class="header" href="print.html#need-help" id="need-help"><h2>Need Help?</h2></a>
<ul>
<li>Check the <a href="../guides/controllers.md">Core Guides</a> for detailed framework documentation</li>
<li>Review <a href="../examples/rest-api.md">Examples</a> for practical tutorials</li>
<li>Visit our <a href="https://github.com/numerum-tech/rustf">GitHub repository</a> for issues and discussions</li>
</ul>
<hr />
<p>Ready to dive in? Let's start with <a href="installation.md">Installation</a>!</p>
<a class="header" href="print.html#installation" id="installation"><h1>Installation</h1></a>
<p>This guide covers multiple ways to install and set up RustF for development.</p>
<a class="header" href="print.html#method-1-using-rustf-cli-recommended" id="method-1-using-rustf-cli-recommended"><h2>Method 1: Using RustF CLI (Recommended)</h2></a>
<p>The easiest way to create a new RustF project is using the CLI tool:</p>
<a class="header" href="print.html#install-rustf-cli" id="install-rustf-cli"><h3>Install RustF CLI</h3></a>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/numerum-tech/rustf.git
cd rustf/rustf-cli

# Build and install
cargo install --path .
</code></pre>
<a class="header" href="print.html#create-a-new-project" id="create-a-new-project"><h3>Create a New Project</h3></a>
<pre><code class="language-bash"># Create a new project
rustf-cli new project my-app

# Navigate to your project
cd my-app

# Run the server
cargo run
</code></pre>
<p>The CLI tool will:</p>
<ul>
<li>Set up the correct project structure</li>
<li>Create necessary directories (controllers, models, views, etc.)</li>
<li>Generate a basic <code>main.rs</code> with auto-discovery</li>
<li>Create a sample controller</li>
<li>Set up configuration files</li>
</ul>
<a class="header" href="print.html#method-2-manual-setup" id="method-2-manual-setup"><h2>Method 2: Manual Setup</h2></a>
<p>If you prefer to set up a project manually:</p>
<a class="header" href="print.html#1-create-a-new-cargo-project" id="1-create-a-new-cargo-project"><h3>1. Create a New Cargo Project</h3></a>
<pre><code class="language-bash">cargo new my-app
cd my-app
</code></pre>
<a class="header" href="print.html#2-add-dependencies" id="2-add-dependencies"><h3>2. Add Dependencies</h3></a>
<p>Edit <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;my-app&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
rustf = { path = &quot;../rustf&quot; }  # Or from crates.io when published
tokio = { version = &quot;1.0&quot;, features = [&quot;full&quot;] }
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
log = &quot;0.4&quot;
env_logger = &quot;0.10&quot;
</code></pre>
<a class="header" href="print.html#3-create-project-structure" id="3-create-project-structure"><h3>3. Create Project Structure</h3></a>
<pre><code class="language-bash">mkdir -p src/controllers src/models src/modules src/middleware
mkdir -p views/layouts public/css public/js
mkdir -p schemas uploads
</code></pre>
<a class="header" href="print.html#4-create-main-application" id="4-create-main-application"><h3>4. Create Main Application</h3></a>
<p>Create <code>src/main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;

#[tokio::main]
async fn main() -&gt; rustf::Result&lt;()&gt; {
    env_logger::init();
    
    let app = RustF::new()
        .controllers(auto_controllers!())
        .middleware_from(auto_middleware!());
    
    println!(&quot;ğŸš€ Server at http://127.0.0.1:8000&quot;);
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#5-create-your-first-controller" id="5-create-your-first-controller"><h3>5. Create Your First Controller</h3></a>
<p>Create <code>src/controllers/home.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/&quot; =&gt; index,
    ]
}

async fn index(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    ctx.html(&quot;&lt;h1&gt;Hello, RustF!&lt;/h1&gt;&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#6-create-configuration" id="6-create-configuration"><h3>6. Create Configuration</h3></a>
<p>Create <code>config.toml</code>:</p>
<pre><code class="language-toml">[server]
host = &quot;127.0.0.1&quot;
port = 8000

[views]
directory = &quot;views&quot;
cache_enabled = false
</code></pre>
<a class="header" href="print.html#method-3-using-git-template" id="method-3-using-git-template"><h2>Method 3: Using Git Template</h2></a>
<p>You can also use the sample application as a template:</p>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/numerum-tech/rustf.git
cd rustf/sample-app

# Copy to your project
cp -r . /path/to/your/project
cd /path/to/your/project

# Install dependencies and run
cargo run
</code></pre>
<a class="header" href="print.html#verifying-installation" id="verifying-installation"><h2>Verifying Installation</h2></a>
<p>After installation, verify everything works:</p>
<pre><code class="language-bash"># Build the project
cargo build

# Run tests
cargo test

# Start the server
cargo run
</code></pre>
<p>You should see:</p>
<pre><code>ğŸš€ Server at http://127.0.0.1:8000
</code></pre>
<p>Visit <code>http://127.0.0.1:8000</code> in your browser to see your application.</p>
<a class="header" href="print.html#development-dependencies" id="development-dependencies"><h2>Development Dependencies</h2></a>
<p>For development, you may also want to add:</p>
<pre><code class="language-toml">[dev-dependencies]
tokio-test = &quot;0.4&quot;
tempfile = &quot;3.8&quot;
</code></pre>
<a class="header" href="print.html#troubleshooting" id="troubleshooting"><h2>Troubleshooting</h2></a>
<a class="header" href="print.html#common-issues" id="common-issues"><h3>Common Issues</h3></a>
<p><strong>Issue: &quot;cannot find crate <code>rustf</code>&quot;</strong></p>
<ul>
<li>Solution: Make sure you've added rustf to <code>Cargo.toml</code> dependencies</li>
<li>If using local development: Use <code>path = &quot;../rustf&quot;</code> in Cargo.toml</li>
<li>If using published version: Use <code>version = &quot;0.1.0&quot;</code> from crates.io</li>
</ul>
<p><strong>Issue: &quot;proc macro not found&quot;</strong></p>
<ul>
<li>Solution: Make sure <code>rustf-macros</code> is available</li>
<li>Check that <code>auto-discovery</code> feature is enabled</li>
</ul>
<p><strong>Issue: &quot;port already in use&quot;</strong></p>
<ul>
<li>Solution: Change the port in <code>config.toml</code> or stop the other process</li>
<li>Default port is 8000</li>
</ul>
<a class="header" href="print.html#next-steps" id="next-steps"><h2>Next Steps</h2></a>
<p>Now that you have RustF installed:</p>
<ol>
<li><strong><a href="hello-world.md">Hello World Tutorial</a></strong> - Build your first application</li>
<li><strong><a href="project-structure.md">Project Structure</a></strong> - Understand the framework layout</li>
<li><strong><a href="../guides/controllers.md">Controllers Guide</a></strong> - Learn about routing and controllers</li>
</ol>
<a class="header" href="print.html#hello-world-tutorial" id="hello-world-tutorial"><h1>Hello World Tutorial</h1></a>
<p>This tutorial will walk you through creating your first RustF application step-by-step.</p>
<a class="header" href="print.html#what-well-build" id="what-well-build"><h2>What We'll Build</h2></a>
<p>We'll create a simple application that:</p>
<ul>
<li>Displays a &quot;Hello World&quot; message</li>
<li>Shows a JSON API endpoint</li>
<li>Demonstrates basic routing</li>
</ul>
<a class="header" href="print.html#step-1-create-the-project" id="step-1-create-the-project"><h2>Step 1: Create the Project</h2></a>
<pre><code class="language-bash">rustf-cli new project hello-rustf
cd hello-rustf
</code></pre>
<p>Or manually:</p>
<pre><code class="language-bash">cargo new hello-rustf
cd hello-rustf
</code></pre>
<a class="header" href="print.html#step-2-add-dependencies" id="step-2-add-dependencies"><h2>Step 2: Add Dependencies</h2></a>
<p>Edit <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rustf = { path = &quot;../rustf&quot; }  # Adjust path as needed
tokio = { version = &quot;1.0&quot;, features = [&quot;full&quot;] }
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
log = &quot;0.4&quot;
env_logger = &quot;0.10&quot;
</code></pre>
<a class="header" href="print.html#step-3-create-the-main-application" id="step-3-create-the-main-application"><h2>Step 3: Create the Main Application</h2></a>
<p>Edit <code>src/main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;

#[tokio::main]
async fn main() -&gt; rustf::Result&lt;()&gt; {
    // Initialize logger
    env_logger::init();
    
    // Create the application with auto-discovery
    let app = RustF::new()
        .controllers(auto_controllers!())      // Auto-discover controllers
        .middleware_from(auto_middleware!());   // Auto-discover middleware
    
    println!(&quot;ğŸš€ Server running at http://127.0.0.1:8000&quot;);
    println!(&quot;ğŸ“– Visit http://127.0.0.1:8000/ for Hello World&quot;);
    println!(&quot;ğŸ“¡ Visit http://127.0.0.1:8000/api/status for JSON API&quot;);
    
    // Start the server
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#step-4-create-your-first-controller" id="step-4-create-your-first-controller"><h2>Step 4: Create Your First Controller</h2></a>
<p>Create <code>src/controllers/home.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

// Every controller must have an install() function
pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/&quot; =&gt; hello_world,
        GET &quot;/api/status&quot; =&gt; api_status,
    ]
}

// Handler function - must be async and take &amp;mut Context
async fn hello_world(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Send HTML response
    ctx.html(&quot;&lt;h1&gt;Hello, RustF! ğŸš€&lt;/h1&gt;&lt;p&gt;Welcome to your first RustF application!&lt;/p&gt;&quot;)
}

// JSON API endpoint
async fn api_status(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Create JSON data
    let data = json!({
        &quot;status&quot;: &quot;ok&quot;,
        &quot;framework&quot;: &quot;RustF&quot;,
        &quot;version&quot;: &quot;0.1.0&quot;,
        &quot;message&quot;: &quot;Hello from the API!&quot;
    });
    
    // Send JSON response
    ctx.json(data)
}
#}</code></pre></pre>
<a class="header" href="print.html#step-5-create-configuration" id="step-5-create-configuration"><h2>Step 5: Create Configuration</h2></a>
<p>Create <code>config.toml</code>:</p>
<pre><code class="language-toml">[server]
host = &quot;127.0.0.1&quot;
port = 8000
timeout = 30

[views]
directory = &quot;views&quot;
cache_enabled = false
default_layout = &quot;layouts/default&quot;

[session]
timeout = 3600
cookie_name = &quot;hello_rustf_session&quot;
secure = false
http_only = true
</code></pre>
<a class="header" href="print.html#step-6-run-your-application" id="step-6-run-your-application"><h2>Step 6: Run Your Application</h2></a>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see:</p>
<pre><code>ğŸš€ Server running at http://127.0.0.1:8000
ğŸ“– Visit http://127.0.0.1:8000/ for Hello World
ğŸ“¡ Visit http://127.0.0.1:8000/api/status for JSON API
</code></pre>
<a class="header" href="print.html#step-7-test-your-application" id="step-7-test-your-application"><h2>Step 7: Test Your Application</h2></a>
<a class="header" href="print.html#test-the-html-endpoint" id="test-the-html-endpoint"><h3>Test the HTML Endpoint</h3></a>
<p>Visit <code>http://127.0.0.1:8000/</code> in your browser. You should see:</p>
<pre><code class="language-html">Hello, RustF! ğŸš€
Welcome to your first RustF application!
</code></pre>
<a class="header" href="print.html#test-the-json-api" id="test-the-json-api"><h3>Test the JSON API</h3></a>
<p>Visit <code>http://127.0.0.1:8000/api/status</code> or use curl:</p>
<pre><code class="language-bash">curl http://127.0.0.1:8000/api/status
</code></pre>
<p>You should get:</p>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;ok&quot;,
  &quot;framework&quot;: &quot;RustF&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;message&quot;: &quot;Hello from the API!&quot;
}
</code></pre>
<a class="header" href="print.html#understanding-the-code" id="understanding-the-code"><h2>Understanding the Code</h2></a>
<a class="header" href="print.html#the-install-function" id="the-install-function"><h3>The <code>install()</code> Function</h3></a>
<p>Every controller must have an <code>install()</code> function that returns <code>Vec&lt;Route&gt;</code>. This function:</p>
<ul>
<li>Defines all routes for this controller</li>
<li>Uses the <code>routes![]</code> macro for clean syntax</li>
<li>Is automatically discovered by <code>auto_controllers!()</code></li>
</ul>
<a class="header" href="print.html#route-handlers" id="route-handlers"><h3>Route Handlers</h3></a>
<p>Route handlers must:</p>
<ul>
<li>Be <code>async</code> functions</li>
<li>Take <code>&amp;mut Context</code> as the only parameter</li>
<li>Return <code>Result&lt;()&gt;</code></li>
<li>Use <code>ctx</code> methods to send responses</li>
</ul>
<a class="header" href="print.html#response-methods" id="response-methods"><h3>Response Methods</h3></a>
<p>The <code>Context</code> provides several response methods:</p>
<ul>
<li><code>ctx.html(content)</code> - Send HTML response</li>
<li><code>ctx.json(data)</code> - Send JSON response</li>
<li><code>ctx.text(content)</code> - Send plain text</li>
<li><code>ctx.redirect(url)</code> - Redirect to another URL</li>
<li><code>ctx.status(code)</code> - Set HTTP status code</li>
</ul>
<a class="header" href="print.html#adding-more-routes" id="adding-more-routes"><h2>Adding More Routes</h2></a>
<p>Let's add a route with a parameter:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/&quot; =&gt; hello_world,
        GET &quot;/api/status&quot; =&gt; api_status,
        GET &quot;/hello/{name}&quot; =&gt; personalized_hello,  // New route with parameter
    ]
}

async fn personalized_hello(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Get route parameter
    let name = ctx.param(&quot;name&quot;).unwrap_or(&quot;World&quot;);
    
    let message = format!(&quot;Hello, {}! Welcome to RustF!&quot;, name);
    ctx.html(&amp;format!(&quot;&lt;h1&gt;{}&lt;/h1&gt;&quot;, message))
}
#}</code></pre></pre>
<p>Now visit <code>http://127.0.0.1:8000/hello/Alice</code> to see a personalized greeting!</p>
<a class="header" href="print.html#next-steps-1" id="next-steps-1"><h2>Next Steps</h2></a>
<p>Congratulations! You've created your first RustF application. Now you can:</p>
<ol>
<li><strong><a href="project-structure.md">Learn about Project Structure</a></strong> - Understand how RustF projects are organized</li>
<li><strong><a href="../guides/controllers.md">Explore Controllers</a></strong> - Learn more about routing and controllers</li>
<li><strong><a href="../guides/views.md">Add Views</a></strong> - Use templates instead of inline HTML</li>
<li><strong><a href="../examples/rest-api.md">Build a REST API</a></strong> - Create a complete API</li>
</ol>
<a class="header" href="print.html#common-questions" id="common-questions"><h2>Common Questions</h2></a>
<p><strong>Q: Why do I need <code>&amp;mut Context</code>?</strong>
A: Context is mutable because it stores request/response data and session information that may change during request processing.</p>
<p><strong>Q: What does <code>auto_controllers!()</code> do?</strong>
A: It's a macro that automatically discovers all controllers in <code>src/controllers/</code> at compile time and registers their routes.</p>
<p><strong>Q: Can I use <code>&amp;Context</code> instead?</strong>
A: No, handlers require <code>&amp;mut Context</code> because they need to modify the response and potentially update session data.</p>
<p><strong>Q: How do I handle errors?</strong>
A: Return <code>Err(Error::...)</code> from your handler. The framework will handle it appropriately based on the error type.</p>
<a class="header" href="print.html#project-structure" id="project-structure"><h1>Project Structure</h1></a>
<p>Understanding the RustF project structure is essential for building maintainable applications. This guide explains the standard layout and conventions.</p>
<a class="header" href="print.html#standard-project-layout" id="standard-project-layout"><h2>Standard Project Layout</h2></a>
<pre><code>your_project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs              # Application entry point with auto-discovery
â”‚   â”œâ”€â”€ controllers/         # HTTP request handlers
â”‚   â”‚   â”œâ”€â”€ home.rs          # Home page controller
â”‚   â”‚   â”œâ”€â”€ auth.rs          # Authentication controller  
â”‚   â”‚   â”œâ”€â”€ users.rs         # User management controller
â”‚   â”‚   â””â”€â”€ api/             # API controllers (namespaced)
â”‚   â”‚       â”œâ”€â”€ users.rs     # User API endpoints
â”‚   â”‚       â””â”€â”€ posts.rs     # Post API endpoints
â”‚   â”œâ”€â”€ models/              # Database models (schema-generated)
â”‚   â”‚   â”œâ”€â”€ users.rs         # User model wrapper
â”‚   â”‚   â”œâ”€â”€ posts.rs         # Post model wrapper
â”‚   â”‚   â””â”€â”€ base/            # Auto-generated base models (DO NOT EDIT)
â”‚   â”‚       â”œâ”€â”€ users_base.rs
â”‚   â”‚       â””â”€â”€ posts_base.rs
â”‚   â”œâ”€â”€ modules/             # Business logic modules
â”‚   â”‚   â”œâ”€â”€ user_service.rs  # User business logic
â”‚   â”‚   â””â”€â”€ email_service.rs # Email functionality
â”‚   â”œâ”€â”€ middleware/          # Custom middleware
â”‚   â”‚   â””â”€â”€ auth.rs          # Authentication middleware
â”‚   â”œâ”€â”€ _controllers.rs      # Auto-generated (IDE support only)
â”‚   â”œâ”€â”€ _models.rs           # Auto-generated (IDE support only)
â”‚   â””â”€â”€ _modules.rs          # Auto-generated (IDE support only)
â”œâ”€â”€ views/                   # Template files
â”‚   â”œâ”€â”€ layouts/
â”‚   â”‚   â””â”€â”€ application.html # Default layout
â”‚   â”œâ”€â”€ home/
â”‚   â”‚   â”œâ”€â”€ index.html       # Home page template
â”‚   â”‚   â””â”€â”€ about.html       # About page template
â”‚   â””â”€â”€ auth/
â”‚       â””â”€â”€ login.html       # Login form template
â”œâ”€â”€ schemas/                 # YAML schema definitions
â”‚   â”œâ”€â”€ users.yaml           # User table schema
â”‚   â”œâ”€â”€ posts.yaml           # Posts table schema
â”‚   â””â”€â”€ _meta.yaml           # Database metadata
â”œâ”€â”€ public/                  # Static files
â”‚   â”œâ”€â”€ css/
â”‚   â”œâ”€â”€ js/
â”‚   â””â”€â”€ images/
â”œâ”€â”€ uploads/                 # File uploads directory
â”œâ”€â”€ config.toml              # Base configuration
â”œâ”€â”€ config.prod.toml         # Production overrides
â””â”€â”€ Cargo.toml               # Rust project configuration
</code></pre>
<a class="header" href="print.html#directory-descriptions" id="directory-descriptions"><h2>Directory Descriptions</h2></a>
<a class="header" href="print.html#src---source-code" id="src---source-code"><h3><code>src/</code> - Source Code</h3></a>
<p>All Rust source code lives in the <code>src/</code> directory.</p>
<a class="header" href="print.html#srcmainrs" id="srcmainrs"><h4><code>src/main.rs</code></h4></a>
<p>The application entry point. Typically contains:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;

#[tokio::main]
async fn main() -&gt; rustf::Result&lt;()&gt; {
    env_logger::init();
    
    let app = RustF::new()
        .controllers(auto_controllers!())
        .middleware_from(auto_middleware!());
    
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#srccontrollers---request-handlers" id="srccontrollers---request-handlers"><h4><code>src/controllers/</code> - Request Handlers</h4></a>
<p>Controllers handle HTTP requests and define routes. Each controller file must have an <code>install()</code> function.</p>
<p><strong>Example: <code>src/controllers/home.rs</code></strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/&quot; =&gt; index,
        GET &quot;/about&quot; =&gt; about,
    ]
}

async fn index(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    ctx.view(&quot;home/index&quot;, json!({}))
}
#}</code></pre></pre>
<p><strong>Nested Controllers: <code>src/controllers/api/users.rs</code></strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/api/users&quot; =&gt; list_users,
        GET &quot;/api/users/{id}&quot; =&gt; get_user,
    ]
}
#}</code></pre></pre>
<a class="header" href="print.html#srcmodels---database-models" id="srcmodels---database-models"><h4><code>src/models/</code> - Database Models</h4></a>
<p>Models represent database tables and provide type-safe database access.</p>
<p><strong>Structure:</strong></p>
<ul>
<li><code>src/models/users.rs</code> - User model wrapper (your code)</li>
<li><code>src/models/base/users_base.rs</code> - Auto-generated base model (don't edit)</li>
</ul>
<p><strong>Example: <code>src/models/users.rs</code></strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;
use crate::models::base::users_base::UsersBase;

pub struct Users {
    base: UsersBase,
}

impl Users {
    pub fn new() -&gt; Self {
        Self {
            base: UsersBase::new(),
        }
    }
    
    // Add custom methods here
}
#}</code></pre></pre>
<a class="header" href="print.html#srcmodules---business-logic" id="srcmodules---business-logic"><h4><code>src/modules/</code> - Business Logic</h4></a>
<p>Modules contain business logic separate from HTTP concerns. They're shared across controllers and can be accessed via <code>MODULE</code>.</p>
<p><strong>Example: <code>src/modules/user_service.rs</code></strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

pub struct UserService;

impl UserService {
    pub fn create_user(&amp;self, name: &amp;str, email: &amp;str) -&gt; Result&lt;User&gt; {
        // Business logic here
    }
}

// Register as shared module
impl_shared_service!(UserService);
#}</code></pre></pre>
<a class="header" href="print.html#srcmiddleware---request-processing" id="srcmiddleware---request-processing"><h4><code>src/middleware/</code> - Request Processing</h4></a>
<p>Middleware processes requests before they reach controllers.</p>
<p><strong>Example: <code>src/middleware/auth.rs</code></strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

pub struct AuthMiddleware;

impl InboundMiddleware for AuthMiddleware {
    fn handle(&amp;self, ctx: &amp;mut Context) -&gt; MiddlewareResult {
        // Authentication logic
        MiddlewareResult::Continue
    }
}

pub fn install(registry: &amp;mut MiddlewareRegistry) {
    registry.register(&quot;auth&quot;, AuthMiddleware::new());
}
#}</code></pre></pre>
<a class="header" href="print.html#src_rs---auto-generated-files" id="src_rs---auto-generated-files"><h4><code>src/_*.rs</code> - Auto-Generated Files</h4></a>
<p>These files are generated by auto-discovery macros for IDE support:</p>
<ul>
<li><code>_controllers.rs</code> - Controller module declarations</li>
<li><code>_models.rs</code> - Model module declarations</li>
<li><code>_modules.rs</code> - Module declarations</li>
</ul>
<p><strong>Important:</strong> These files are NOT compiled. They're only for IDE autocomplete.</p>
<a class="header" href="print.html#views---templates" id="views---templates"><h3><code>views/</code> - Templates</h3></a>
<p>Template files organized by feature.</p>
<p><strong>Structure:</strong></p>
<pre><code>views/
â”œâ”€â”€ layouts/
â”‚   â””â”€â”€ application.html     # Default layout
â”œâ”€â”€ home/
â”‚   â”œâ”€â”€ index.html           # Home page
â”‚   â””â”€â”€ about.html           # About page
â””â”€â”€ auth/
    â””â”€â”€ login.html           # Login form
</code></pre>
<p><strong>Layout Example: <code>views/layouts/application.html</code></strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{{title}}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    {{@body}}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>View Example: <code>views/home/index.html</code></strong></p>
<pre><code class="language-html">&lt;h1&gt;Welcome&lt;/h1&gt;
&lt;p&gt;Hello, {{name}}!&lt;/p&gt;
</code></pre>
<a class="header" href="print.html#schemas---database-schemas" id="schemas---database-schemas"><h3><code>schemas/</code> - Database Schemas</h3></a>
<p>YAML schema definitions for database tables. Used by the CLI to generate models.</p>
<p><strong>Example: <code>schemas/users.yaml</code></strong></p>
<pre><code class="language-yaml">table: users
fields:
  id:
    type: integer
    primary: true
    auto_increment: true
  name:
    type: string
    length: 255
    required: true
  email:
    type: string
    length: 255
    required: true
    unique: true
</code></pre>
<a class="header" href="print.html#public---static-assets" id="public---static-assets"><h3><code>public/</code> - Static Assets</h3></a>
<p>Static files served directly by the web server.</p>
<pre><code>public/
â”œâ”€â”€ css/
â”‚   â””â”€â”€ style.css
â”œâ”€â”€ js/
â”‚   â””â”€â”€ app.js
â””â”€â”€ images/
    â””â”€â”€ logo.png
</code></pre>
<p>Access via: <code>http://localhost:8000/css/style.css</code></p>
<a class="header" href="print.html#uploads---user-uploads" id="uploads---user-uploads"><h3><code>uploads/</code> - User Uploads</h3></a>
<p>Directory for user-uploaded files. Location is configurable in <code>config.toml</code>.</p>
<a class="header" href="print.html#configuration-files" id="configuration-files"><h3>Configuration Files</h3></a>
<a class="header" href="print.html#configtoml---base-configuration" id="configtoml---base-configuration"><h4><code>config.toml</code> - Base Configuration</h4></a>
<pre><code class="language-toml">[server]
host = &quot;127.0.0.1&quot;
port = 8000

[views]
directory = &quot;views&quot;
cache_enabled = false
</code></pre>
<a class="header" href="print.html#configprodtoml---production-overrides" id="configprodtoml---production-overrides"><h4><code>config.prod.toml</code> - Production Overrides</h4></a>
<pre><code class="language-toml">[server]
host = &quot;0.0.0.0&quot;
port = 8080

[views]
cache_enabled = true

[session]
secure = true
</code></pre>
<a class="header" href="print.html#file-naming-conventions" id="file-naming-conventions"><h2>File Naming Conventions</h2></a>
<table><thead><tr><th> Component </th><th> Convention </th><th> Example </th></tr></thead><tbody>
<tr><td> <strong>Controllers</strong> </td><td> <code>snake_case.rs</code> </td><td> <code>users.rs</code>, <code>auth.rs</code> </td></tr>
<tr><td> <strong>Models</strong> </td><td> <code>snake_case.rs</code> </td><td> <code>users.rs</code>, <code>blog_posts.rs</code> </td></tr>
<tr><td> <strong>Modules</strong> </td><td> <code>snake_case.rs</code> </td><td> <code>user_service.rs</code>, <code>email_service.rs</code> </td></tr>
<tr><td> <strong>Middleware</strong> </td><td> <code>snake_case.rs</code> </td><td> <code>auth.rs</code>, <code>rate_limit.rs</code> </td></tr>
<tr><td> <strong>Templates</strong> </td><td> <code>snake_case.html</code> </td><td> <code>index.html</code>, <code>user_profile.html</code> </td></tr>
<tr><td> <strong>Schemas</strong> </td><td> <code>snake_case.yaml</code> </td><td> <code>users.yaml</code>, <code>blog_posts.yaml</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#best-practices" id="best-practices"><h2>Best Practices</h2></a>
<a class="header" href="print.html#1-organize-by-feature" id="1-organize-by-feature"><h3>1. Organize by Feature</h3></a>
<p>Group related files together:</p>
<pre><code>src/controllers/
â”œâ”€â”€ users.rs          # User-related routes
â”œâ”€â”€ posts.rs          # Post-related routes
â””â”€â”€ comments.rs       # Comment-related routes
</code></pre>
<a class="header" href="print.html#2-use-namespaces-for-apis" id="2-use-namespaces-for-apis"><h3>2. Use Namespaces for APIs</h3></a>
<p>Separate API controllers:</p>
<pre><code>src/controllers/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”œâ”€â”€ users.rs
â”‚   â”‚   â””â”€â”€ posts.rs
â”‚   â””â”€â”€ v2/
â”‚       â””â”€â”€ users.rs
</code></pre>
<a class="header" href="print.html#3-keep-models-simple" id="3-keep-models-simple"><h3>3. Keep Models Simple</h3></a>
<p>Models should be thin wrappers around base models:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Good: Thin wrapper
pub struct Users {
    base: UsersBase,
}

// Avoid: Complex logic in models
// Move business logic to modules
#}</code></pre></pre>
<a class="header" href="print.html#4-separate-concerns" id="4-separate-concerns"><h3>4. Separate Concerns</h3></a>
<ul>
<li><strong>Controllers</strong> - HTTP request/response handling</li>
<li><strong>Models</strong> - Database access</li>
<li><strong>Modules</strong> - Business logic</li>
<li><strong>Middleware</strong> - Cross-cutting concerns</li>
</ul>
<a class="header" href="print.html#auto-discovery" id="auto-discovery"><h2>Auto-Discovery</h2></a>
<p>RustF automatically discovers components based on file location:</p>
<ul>
<li><code>src/controllers/*.rs</code> â†’ Controllers</li>
<li><code>src/models/*.rs</code> â†’ Models</li>
<li><code>src/modules/*.rs</code> â†’ Modules</li>
<li><code>src/middleware/*.rs</code> â†’ Middleware</li>
</ul>
<p>No manual registration needed!</p>
<a class="header" href="print.html#next-steps-2" id="next-steps-2"><h2>Next Steps</h2></a>
<p>Now that you understand the project structure:</p>
<ol>
<li><strong><a href="../guides/controllers.md">Controllers Guide</a></strong> - Learn about routing</li>
<li><strong><a href="../guides/database.md">Models Guide</a></strong> - Work with databases</li>
<li><strong><a href="../guides/views.md">Views Guide</a></strong> - Use templates</li>
<li><strong><a href="../advanced/modules.md">Modules Guide</a></strong> - Share business logic</li>
</ol>
<a class="header" href="print.html#rustf-controllers-user-guide" id="rustf-controllers-user-guide"><h1>RustF Controllers User Guide</h1></a>
<p><strong>Complete documentation based on current framework implementation</strong></p>
<a class="header" href="print.html#overview" id="overview"><h2>Overview</h2></a>
<p>RustF provides a clean, organized controller system inspired by Total.js. Controllers are Rust modules that group related route handlers together and expose them through an <code>install()</code> function. The framework supports both manual controller registration and automatic controller discovery for streamlined development.</p>
<a class="header" href="print.html#key-features-1" id="key-features-1"><h3>Key Features</h3></a>
<ul>
<li><strong>Convention-based routing</strong> - Clean <code>routes![]</code> macro syntax</li>
<li><strong>Auto-discovery</strong> - Automatically finds and registers controllers at compile time</li>
<li><strong>Total.js-inspired API</strong> - Familiar patterns for web developers</li>
<li><strong>Type-safe handlers</strong> - All handlers are statically checked at compile time</li>
<li><strong>Flexible organization</strong> - Group related functionality logically</li>
</ul>
<a class="header" href="print.html#core-components" id="core-components"><h2>Core Components</h2></a>
<a class="header" href="print.html#route-system" id="route-system"><h3>Route System</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Route {
    pub method: String,    // HTTP method (GET, POST, PUT, DELETE)
    pub path: String,      // URL pattern with optional parameters ({id})
    pub handler: RouteHandler,  // Async handler function
}

// Type alias for route handlers - all handlers follow this signature
pub type RouteHandler = for&lt;'a&gt; fn(&amp;'a mut Context) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;()&gt;&gt; + Send + 'a&gt;&gt;;
#}</code></pre></pre>
<p><strong>Route Handler Requirements:</strong></p>
<ul>
<li>Must be <code>async</code> functions</li>
<li>Take a single <code>&amp;mut Context</code> parameter (mutable reference)</li>
<li>Return <code>Result&lt;()&gt;</code> (response is set internally on Context)</li>
<li>Are automatically wrapped by the <code>routes!</code> macro</li>
</ul>
<a class="header" href="print.html#supported-http-methods" id="supported-http-methods"><h3>Supported HTTP Methods</h3></a>
<p>The framework supports all standard HTTP methods:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Available in routes! macro:
GET    &quot;/path&quot;     =&gt; handler_function
POST   &quot;/path&quot;     =&gt; handler_function  
PUT    &quot;/path&quot;     =&gt; handler_function
DELETE &quot;/path&quot;     =&gt; handler_function

// Manual route creation (rarely needed):
Route::get(&quot;/users&quot;, handler)           // GET request
Route::post(&quot;/users&quot;, handler)          // POST request
Route::put(&quot;/users/{id}&quot;, handler)       // PUT request
Route::delete(&quot;/users/{id}&quot;, handler)    // DELETE request
#}</code></pre></pre>
<a class="header" href="print.html#controller-pattern" id="controller-pattern"><h2>Controller Pattern</h2></a>
<a class="header" href="print.html#basic-controller-structure" id="basic-controller-structure"><h3>Basic Controller Structure</h3></a>
<p>Every controller must follow this exact pattern:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

// Required: Every controller must have an install() function
pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/&quot; =&gt; index,
        POST &quot;/submit&quot; =&gt; submit,
        GET &quot;/item/{id}&quot; =&gt; show_item,
    ]
}

// Handler functions - must be async and return Result&lt;()&gt;
async fn index(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let data = json!({&quot;message&quot;: &quot;Welcome!&quot;});
    ctx.view(&quot;/home/index&quot;, data)
}

async fn submit(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form_data = ctx.body_form()?;
    // Process form data
    ctx.redirect(&quot;/success&quot;)
}

async fn show_item(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let item_id = ctx.param(&quot;id&quot;).unwrap_or(&quot;0&quot;).to_string();
    let data = json!({&quot;id&quot;: item_id});
    ctx.json(data)
}
#}</code></pre></pre>
<a class="header" href="print.html#controller-file-organization" id="controller-file-organization"><h3>Controller File Organization</h3></a>
<pre><code>src/controllers/
â”œâ”€â”€ home.rs          # Home page and static content
â”œâ”€â”€ auth.rs          # Login, logout, registration
â”œâ”€â”€ users.rs         # User management
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ users.rs     # API endpoints for users
â”‚   â””â”€â”€ posts.rs     # API endpoints for posts
â””â”€â”€ admin.rs         # Admin functionality
</code></pre>
<a class="header" href="print.html#the-routes-macro" id="the-routes-macro"><h3>The routes! Macro</h3></a>
<p>The <code>routes!</code> macro provides clean, declarative route definition:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
routes![
    // Basic routes
    GET &quot;/&quot; =&gt; index,
    GET &quot;/about&quot; =&gt; about,
    
    // Routes with parameters
    GET &quot;/users/{id}&quot; =&gt; get_user,
    GET &quot;/posts/{post_id}/comments/{comment_id}&quot; =&gt; get_comment,
    
    // Different HTTP methods
    POST &quot;/users&quot; =&gt; create_user,
    PUT &quot;/users/{id}&quot; =&gt; update_user,
    DELETE &quot;/users/{id}&quot; =&gt; delete_user,
    
    // Complex paths
    GET &quot;/api/v1/users/{id}/profile&quot; =&gt; get_user_profile,
]
#}</code></pre></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Clean, readable syntax</li>
<li>Automatic handler wrapping</li>
<li>Compile-time validation</li>
<li>Support for URL parameters with <code>{parameter}</code> syntax</li>
<li>Trailing commas allowed</li>
</ul>
<a class="header" href="print.html#writing-route-handlers" id="writing-route-handlers"><h2>Writing Route Handlers</h2></a>
<a class="header" href="print.html#handler-function-requirements" id="handler-function-requirements"><h3>Handler Function Requirements</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Required signature for all handlers
async fn handler_name(ctx: &amp;mut Context) -&gt; Result&lt;()&gt;
#}</code></pre></pre>
<p><strong>Handler Rules:</strong></p>
<ul>
<li>Must be <code>async</code> functions</li>
<li>Must take exactly one <code>&amp;mut Context</code> parameter (mutable reference)</li>
<li>Must return <code>Result&lt;()&gt;</code> - the response is set internally on the Context</li>
<li>Can have any name (referenced in routes! macro)</li>
<li>Are automatically wrapped by the framework</li>
</ul>
<a class="header" href="print.html#response-handling-pattern" id="response-handling-pattern"><h3>Response Handling Pattern</h3></a>
<p><strong>Key Change:</strong> Handlers now receive <code>&amp;mut Context</code> and return <code>Result&lt;()&gt;</code> instead of <code>Result&lt;Response&gt;</code>. This architectural change ensures that session data and all middleware modifications persist throughout the entire request/response lifecycle.</p>
<a class="header" href="print.html#how-responses-work" id="how-responses-work"><h4>How Responses Work</h4></a>
<ol>
<li><strong>Response Storage</strong>: The Context struct now contains an <code>Option&lt;Response&gt;</code> field initialized with a default 200 OK response</li>
<li><strong>Setting Responses</strong>: All response helper methods (<code>json()</code>, <code>view()</code>, <code>redirect()</code>, etc.) internally call <code>ctx.set_response()</code></li>
<li><strong>Return Type</strong>: Methods return <code>Result&lt;()&gt;</code> to indicate success/failure of setting the response</li>
<li><strong>Middleware Access</strong>: Both inbound and outbound middleware can access and modify the response via <code>ctx.response</code></li>
<li><strong>Response Helpers in Middleware</strong>: Since Context initializes with a default response, middleware can use the same response helpers (<code>ctx.json()</code>, <code>ctx.throw403()</code>, etc.) as handlers</li>
</ol>
<a class="header" href="print.html#custom-response-creation" id="custom-response-creation"><h4>Custom Response Creation</h4></a>
<p>If you need to create a custom response beyond the built-in helpers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn custom_response_handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Create a custom response
    let response = Response::new(StatusCode::from_u16(418).unwrap())
        .with_header(&quot;X-Custom&quot;, &quot;value&quot;)
        .with_body(b&quot;I'm a teapot&quot;.to_vec());
    
    // Set it on the context
    ctx.set_response(response);
    Ok(())
}
#}</code></pre></pre>
<a class="header" href="print.html#error-handling-pattern" id="error-handling-pattern"><h4>Error Handling Pattern</h4></a>
<p>Since handlers return <code>Result&lt;()&gt;</code>, error responses are handled the same way as success responses:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn validated_handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let data = ctx.body_json::&lt;MyData&gt;()?;
    
    if !data.is_valid() {
        // Error response - still returns Result&lt;()&gt;
        return ctx.throw400(Some(&quot;Invalid data&quot;));
    }
    
    // Success response - also returns Result&lt;()&gt;
    ctx.json(json!({&quot;status&quot;: &quot;success&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#working-with-context" id="working-with-context"><h3>Working with Context</h3></a>
<p>The <code>Context</code> parameter provides access to all request/response functionality.</p>
<p><strong>Important Note on Middleware Context Preservation:</strong>
The framework ensures that all context modifications made by middleware (such as setting layout, repository data, or session values) are properly preserved and passed to your controller handlers. The context is passed by mutable reference through the middleware chain and arrives at your handler with all modifications intact.</p>
<a class="header" href="print.html#request-data" id="request-data"><h4>Request Data</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// URL parameters (/users/{id} -&gt; id)
let user_id = ctx.param(&quot;id&quot;).unwrap_or(&quot;0&quot;);

// Query parameters (?page=2 -&gt; page)
let page = ctx.query(&quot;page&quot;).unwrap_or(&quot;1&quot;);

// Form data - Three approaches available:

// 1. Manual parsing (low-level, verbose but flexible)
let form_data = ctx.body_form()?;
let email = form_data.get(&quot;email&quot;).unwrap_or(&amp;String::new());

// 2. Typed parsing (recommended - automatic deserialization)
#[derive(serde::Deserialize)]
struct LoginForm {
    email: String,
    password: String,
}
let form: LoginForm = ctx.body_form_typed()?;
let email = form.email;

// 3. Individual field helpers (for simple cases)
let email = ctx.str_body(&quot;email&quot;)?;              // Required field
let name = ctx.str_body_or(&quot;name&quot;, &quot;Anonymous&quot;); // Optional with default
let age = ctx.int_body(&quot;age&quot;)?;                  // Parse as integer
let active = ctx.bool_body_or(&quot;active&quot;, false);  // Parse as boolean

// JSON body
let json_data: MyStruct = ctx.body_json()?;

// Headers
let auth_header = ctx.header(&quot;Authorization&quot;);

// File uploads
let uploaded_file = ctx.file(&quot;avatar&quot;)?;
#}</code></pre></pre>
<a class="header" href="print.html#response-modification" id="response-modification"><h4>Response Modification</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Add custom headers to response
ctx.add_header(&quot;X-Custom-Header&quot;, &quot;value&quot;);
ctx.add_header(&quot;Cache-Control&quot;, &quot;no-cache&quot;);

// Set response status code
ctx.status(hyper::StatusCode::CREATED);  // 201 Created
ctx.status(hyper::StatusCode::ACCEPTED); // 202 Accepted

// These methods are particularly useful in middleware
// since Context now initializes with a default 200 OK response
#}</code></pre></pre>
<a class="header" href="print.html#response-generation" id="response-generation"><h4>Response Generation</h4></a>
<p><strong>Important:</strong> All response methods now set the response internally on the Context and return <code>Result&lt;()&gt;</code> instead of <code>Result&lt;Response&gt;</code>. This ensures that session data and middleware modifications are preserved throughout the request lifecycle.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Template responses (data accessed via model.key or M.key in template)
ctx.view(&quot;/users/profile&quot;, json!({&quot;user&quot;: user_data}))?  // Sets template response

// JSON responses
ctx.json(json!({&quot;status&quot;: &quot;success&quot;, &quot;data&quot;: users}))?   // Sets JSON response

// Redirects
ctx.redirect(&quot;/login&quot;)?                                  // Sets redirect response

// HTTP errors - all return Result&lt;()&gt; after setting error response
ctx.throw404(Some(&quot;User not found&quot;))?                   // Sets 404 error
ctx.throw400(Some(&quot;Invalid input&quot;))?                    // Sets 400 error
ctx.throw500(None)?                                      // Sets 500 error

// Plain text
ctx.text(&quot;Hello, world!&quot;)?                              // Sets text response

// File responses
ctx.file_download(&quot;/path/to/file&quot;, Some(&quot;name.pdf&quot;))?   // Sets file download
ctx.file_inline(&quot;/path/to/image.jpg&quot;)?                  // Sets inline file
#}</code></pre></pre>
<a class="header" href="print.html#session-management" id="session-management"><h4>Session Management</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Set session data
ctx.session_set(&quot;user_id&quot;, 123)?;
ctx.session_set(&quot;cart&quot;, json!({&quot;items&quot;: []}));

// Get session data
let user_id: Option&lt;i32&gt; = ctx.session_get(&quot;user_id&quot;);
let cart: Option&lt;Value&gt; = ctx.session_get(&quot;cart&quot;);

// Remove session data
ctx.session_remove(&quot;temporary_data&quot;);
#}</code></pre></pre>
<a class="header" href="print.html#repository-data-handler-scoped-data" id="repository-data-handler-scoped-data"><h4>Repository Data (Handler-Scoped Data)</h4></a>
<p>The repository system allows controllers to pass data to all views called within the handler function without explicitly including it in each view's data parameter. The repository lives for the duration of the handler function execution.</p>
<p><strong>Setting Repository Data</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn my_handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Set simple values
    ctx.repository_set(&quot;app_name&quot;, &quot;RustF Application&quot;);
    ctx.repository_set(&quot;current_section&quot;, &quot;dashboard&quot;);
    ctx.repository_set(&quot;user_level&quot;, 5);
    
    // Set arrays
    ctx.repository_set(&quot;nav_items&quot;, json!([
        {&quot;title&quot;: &quot;Home&quot;, &quot;url&quot;: &quot;/&quot;},
        {&quot;title&quot;: &quot;About&quot;, &quot;url&quot;: &quot;/about&quot;},
        {&quot;title&quot;: &quot;Contact&quot;, &quot;url&quot;: &quot;/contact&quot;}
    ]));
    
    // Set complex objects
    ctx.repository_set(&quot;site_config&quot;, json!({
        &quot;theme&quot;: &quot;dark&quot;,
        &quot;sidebar&quot;: &quot;expanded&quot;,
        &quot;notifications&quot;: true
    }));
    
    // Repository data is automatically available in the view
    // Note: View data is accessed via model.key or M.key in templates
    ctx.view(&quot;/my_view&quot;, json!({&quot;title&quot;: &quot;Page Title&quot;}))
}
#}</code></pre></pre>
<p><strong>Important Note About View Data Access</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// When you pass data to ctx.view(), it becomes the &quot;model&quot; in the template
ctx.view(&quot;/template&quot;, json!({
    &quot;title&quot;: &quot;My Page&quot;,
    &quot;users&quot;: vec![...]
}))

// In the template, access this data with model. or M. prefix:
// @{model.title} or @{M.title}
// @{model.users} or @{M.users}
// NOT directly as @{title} or @{users}
#}</code></pre></pre>
<p><strong>Working with Repository</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get data from repository
let section = ctx.repository_get(&quot;current_section&quot;);

// Clear all repository data
ctx.repository_clear();

// Chain multiple operations
ctx.repository_set(&quot;key1&quot;, &quot;value1&quot;)
   .repository_set(&quot;key2&quot;, &quot;value2&quot;)
   .repository_clear();  // Returns &amp;mut Self for chaining
#}</code></pre></pre>
<p><strong>Accessing in Templates</strong></p>
<pre><code class="language-html">&lt;!-- Use repository.key or R.key (shorthand) --&gt;
&lt;h1&gt;@{repository.app_name}&lt;/h1&gt;
&lt;div class=&quot;section-@{R.current_section}&quot;&gt;

&lt;!-- Access nested data --&gt;
Theme: @{repository.site_config.theme}
Sidebar: @{R.site_config.sidebar}

&lt;!-- Use in conditionals --&gt;
@{if R.site_config.notifications}
    &lt;div class=&quot;notifications&quot;&gt;Enabled&lt;/div&gt;
@{fi}

&lt;!-- Iterate over arrays --&gt;
@{foreach item in repository.nav_items}
    &lt;a href=&quot;@{item.url}&quot;&gt;@{item.title}&lt;/a&gt;
@{end}
</code></pre>
<p><strong>Complete Example</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/dashboard&quot; =&gt; dashboard,
    ]
}

async fn dashboard(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Set shared repository data
    ctx.repository_set(&quot;user&quot;, json!({
        &quot;name&quot;: &quot;John Doe&quot;,
        &quot;role&quot;: &quot;admin&quot;,
        &quot;avatar&quot;: &quot;/images/john.jpg&quot;
    }));
    
    ctx.repository_set(&quot;breadcrumbs&quot;, json!([
        {&quot;label&quot;: &quot;Home&quot;, &quot;url&quot;: &quot;/&quot;},
        {&quot;label&quot;: &quot;Dashboard&quot;, &quot;url&quot;: null}
    ]));
    
    ctx.repository_set(&quot;stats&quot;, json!({
        &quot;total_users&quot;: 1234,
        &quot;active_sessions&quot;: 42
    }));
    
    // View-specific data
    let data = json!({
        &quot;title&quot;: &quot;Dashboard&quot;,
        &quot;recent_activity&quot;: [&quot;Login&quot;, &quot;Posted comment&quot;, &quot;Updated profile&quot;]
    });
    
    ctx.view(&quot;/dashboard/index&quot;, data)
}
#}</code></pre></pre>
<p><strong>Multiple Views in One Handler</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn dashboard_with_sidebar(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Set repository data once - available to all views in this handler
    ctx.repository_set(&quot;user&quot;, get_current_user()?);
    ctx.repository_set(&quot;notifications&quot;, get_notifications()?);
    ctx.repository_set(&quot;theme&quot;, &quot;dark&quot;);
    
    // Conditional rendering - all views have access to repository
    if is_mobile_device(&amp;ctx) {
        // Mobile view also has access to repository data
        return ctx.view(&quot;/dashboard/mobile&quot;, json!({
            &quot;stats&quot;: get_stats()?
        }));
    }
    
    // Desktop view also has access to the same repository data
    ctx.view(&quot;/dashboard/desktop&quot;, json!({
        &quot;stats&quot;: get_stats()?,
        &quot;charts&quot;: get_charts()?
    }))
}
#}</code></pre></pre>
<p><strong>Use Cases for Repository</strong></p>
<ul>
<li>Data needed by all views rendered in the same handler</li>
<li>User information and permissions for the current handler</li>
<li>UI state (theme, layout) for views in this handler</li>
<li>Temporary data that shouldn't be in the main view data</li>
<li>Avoiding repetition when calling multiple views</li>
</ul>
<p><strong>Note:</strong> The repository lives only for the handler function's execution and is cleared when the handler returns. For application-wide data that persists across all requests and is accessible throughout the entire application, use the APP global repository system.</p>
<a class="header" href="print.html#flash-messages-one-time-messages" id="flash-messages-one-time-messages"><h4>Flash Messages (one-time messages)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Standard convenience methods
ctx.flash_success(&quot;User created successfully!&quot;);
ctx.flash_error(&quot;Invalid credentials&quot;);
ctx.flash_info(&quot;Please check your email&quot;);

// Generic flash setter for custom keys
ctx.flash(&quot;warning_msg&quot;, &quot;This is a warning&quot;)?;
ctx.flash(&quot;user_level&quot;, 42)?;
ctx.flash(&quot;notification&quot;, json!({&quot;text&quot;: &quot;You have messages&quot;, &quot;count&quot;: 5}))?;
ctx.flash(&quot;items&quot;, vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])?;

// Manual flash management
ctx.flash_clear();                    // Clear all flash messages
ctx.flash_clear_key(&quot;error_msg&quot;);     // Clear specific flash message

// Flash messages automatically appear in views via @{flash.success_msg}, @{flash.custom_key}, etc.
#}</code></pre></pre>
<a class="header" href="print.html#client-information" id="client-information"><h4>Client Information</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Client details
let ip = ctx.ip();                    // Client IP address
let user_agent = ctx.user_agent();    // Browser/client info
let is_mobile = ctx.is_mobile();      // Mobile device detection
let is_ajax = ctx.is_xhr();           // AJAX request detection
let language = ctx.language();        // Preferred language
#}</code></pre></pre>
<a class="header" href="print.html#controller-registration" id="controller-registration"><h2>Controller Registration</h2></a>
<a class="header" href="print.html#manual-registration" id="manual-registration"><h3>Manual Registration</h3></a>
<p>For simple applications or when you need precise control:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;

mod controllers {
    pub mod home;
    pub mod auth;
    pub mod users;
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::new()
        .controllers({
            let mut routes = Vec::new();
            routes.extend(controllers::home::install());
            routes.extend(controllers::auth::install());
            routes.extend(controllers::users::install());
            routes
        });
        
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#auto-discovery-recommended" id="auto-discovery-recommended"><h3>Auto-Discovery (Recommended)</h3></a>
<p>For larger applications, use automatic controller discovery:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;

// The #[rustf::auto_discover] attribute automatically:
// 1. Scans src/controllers/*.rs files
// 2. Generates module declarations  
// 3. Creates controller registration code
#[rustf::auto_discover]
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::new()
        .controllers(auto_controllers!())  // Registers all discovered controllers
        .models(auto_models!())           // Also discovers models
        .middleware_from(auto_middleware!()); // And middleware
        
    app.start().await
}
</code></pre></pre>
<p><strong>Auto-discovery Process:</strong></p>
<ol>
<li><strong>Compile-time scanning</strong> - Framework scans <code>src/controllers/*.rs</code> at build time</li>
<li><strong>Module generation</strong> - Generates <code>_controllers.rs</code> with module declarations</li>
<li><strong>Registration</strong> - <code>auto_controllers!()</code> macro returns all discovered routes</li>
</ol>
<p><strong>Requirements for Auto-Discovery:</strong></p>
<ul>
<li>Enable <code>auto-discovery</code> feature in <code>Cargo.toml</code></li>
<li>Each controller file must have <code>pub fn install() -&gt; Vec&lt;Route&gt;</code></li>
<li>Controller files must be in <code>src/controllers/</code> directory</li>
<li>Use <code>#[rustf::auto_discover]</code> attribute on main function</li>
</ul>
<a class="header" href="print.html#complete-controller-examples" id="complete-controller-examples"><h2>Complete Controller Examples</h2></a>
<a class="header" href="print.html#simple-home-controller" id="simple-home-controller"><h3>Simple Home Controller</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/controllers/home.rs
use rustf::prelude::*;

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/&quot; =&gt; index,
        GET &quot;/about&quot; =&gt; about,
        GET &quot;/contact&quot; =&gt; contact,
    ]
}

async fn index(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let data = json!({
        &quot;title&quot;: &quot;Welcome to RustF&quot;,
        &quot;message&quot;: &quot;Your application is running successfully!&quot;,
        &quot;features&quot;: [
            &quot;Auto-discovery for controllers&quot;,
            &quot;Template engine with layouts&quot;, 
            &quot;Session management&quot;,
            &quot;Built-in security features&quot;
        ]
    });
    
    ctx.view(&quot;/home/index&quot;, data)
}

async fn about(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let data = json!({
        &quot;title&quot;: &quot;About&quot;,
        &quot;description&quot;: &quot;Built with RustF framework - an AI-friendly MVC framework for Rust&quot;,
        &quot;version&quot;: &quot;1.0.0&quot;
    });
    
    ctx.view(&quot;/home/about&quot;, data)
}

async fn contact(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    ctx.view(&quot;/home/contact&quot;, json!({
        &quot;title&quot;: &quot;Contact Us&quot;,
        &quot;email&quot;: &quot;info@example.com&quot;
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#authentication-controller-with-repository" id="authentication-controller-with-repository"><h3>Authentication Controller with Repository</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/controllers/auth.rs  
use rustf::prelude::*;
use serde::Deserialize;

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET  &quot;/auth/login&quot;    =&gt; view_login,
        POST &quot;/auth/login&quot;    =&gt; do_login,
        GET  &quot;/auth/logout&quot;   =&gt; do_logout,
        GET  &quot;/auth/register&quot; =&gt; view_register,
        POST &quot;/auth/register&quot; =&gt; do_register,
    ]
}

// Struct for form validation (optional)
#[derive(Deserialize)]
struct LoginForm {
    email: String,
    password: String,
}

#[derive(Deserialize)]
struct RegisterForm {
    email: String,
    password: String,
    name: String,
}

async fn view_login(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Set repository data for this request
    ctx.repository_set(&quot;page_type&quot;, &quot;auth&quot;)
       .repository_set(&quot;show_social_login&quot;, true)
       .repository_set(&quot;providers&quot;, json!([&quot;google&quot;, &quot;github&quot;]));
    
    // Use empty layout for login page
    ctx.layout(&quot;&quot;)
       .view(&quot;/auth/login&quot;, json!({
           &quot;title&quot;: &quot;Login&quot;,
           &quot;debug&quot;: cfg!(debug_assertions) // Show test credentials in debug
       }))
}

async fn do_login(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Parse form data into typed structure
    let form: LoginForm = ctx.body_form_typed()?;

    // Input validation
    if !form.email.contains('@') || form.password.is_empty() {
        ctx.flash_error(&quot;Please provide a valid email and password&quot;);
        return ctx.redirect(&quot;/auth/login&quot;);
    }

    // Authentication logic (use proper password hashing in production)
    if form.email == &quot;admin@example.com&quot; &amp;&amp; form.password == &quot;password&quot; {
        ctx.session_set(&quot;user&quot;, json!({
            &quot;id&quot;: 1,
            &quot;email&quot;: form.email,
            &quot;name&quot;: &quot;Admin User&quot;,
            &quot;role&quot;: &quot;admin&quot;
        }))?;

        ctx.flash_success(&quot;Login successful!&quot;);
        ctx.redirect(&quot;/dashboard&quot;)
    } else {
        ctx.flash_error(&quot;Invalid email or password&quot;);
        ctx.redirect(&quot;/auth/login&quot;)
    }
}

async fn do_logout(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    ctx.session_remove(&quot;user&quot;);
    ctx.flash_info(&quot;You have been logged out successfully&quot;);
    ctx.redirect(&quot;/auth/login&quot;)
}

async fn view_register(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    ctx.layout(&quot;&quot;)
       .view(&quot;/auth/register&quot;, json!({
           &quot;title&quot;: &quot;Create Account&quot;
       }))
}

async fn do_register(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Parse form data into typed structure
    let form: RegisterForm = ctx.body_form_typed()?;

    // Validation
    if !form.email.contains('@') {
        ctx.flash_error(&quot;Please provide a valid email address&quot;);
        return ctx.redirect(&quot;/auth/register&quot;);
    }

    if form.password.len() &lt; 8 {
        ctx.flash_error(&quot;Password must be at least 8 characters long&quot;);
        return ctx.redirect(&quot;/auth/register&quot;);
    }

    if form.name.trim().is_empty() {
        ctx.flash_error(&quot;Please provide your name&quot;);
        return ctx.redirect(&quot;/auth/register&quot;);
    }

    // Check if user already exists (simplified)
    // In real app: check database
    if form.email == &quot;admin@example.com&quot; {
        ctx.flash_error(&quot;User already exists&quot;);
        return ctx.redirect(&quot;/auth/register&quot;);
    }

    // Create user (in real app: hash password, save to database)
    ctx.flash_success(&amp;format!(&quot;Account created successfully for {}! You can now log in.&quot;, form.name));
    ctx.redirect(&quot;/auth/login&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#form-handling-with-typed-parsing" id="form-handling-with-typed-parsing"><h3>Form Handling with Typed Parsing</h3></a>
<p>RustF provides <code>body_form_typed&lt;T&gt;()</code> for automatic form deserialization into Rust structures, significantly reducing boilerplate code.</p>
<a class="header" href="print.html#basic-form-parsing" id="basic-form-parsing"><h4>Basic Form Parsing</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;
use serde::Deserialize;

// Define your form structure
#[derive(Deserialize)]
struct ContactForm {
    name: String,
    email: String,
    message: String,
}

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET  &quot;/contact&quot; =&gt; view_contact,
        POST &quot;/contact&quot; =&gt; submit_contact,
    ]
}

async fn view_contact(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    ctx.view(&quot;/contact&quot;, json!({&quot;title&quot;: &quot;Contact Us&quot;}))
}

async fn submit_contact(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Parse form directly into typed structure
    let form: ContactForm = ctx.body_form_typed()?;

    // Validate
    if !form.email.contains('@') {
        ctx.flash_error(&quot;Please provide a valid email address&quot;);
        return ctx.redirect(&quot;/contact&quot;);
    }

    if form.message.trim().is_empty() {
        ctx.flash_error(&quot;Message cannot be empty&quot;);
        return ctx.redirect(&quot;/contact&quot;);
    }

    // Process form data
    log::info!(&quot;Contact form from {}: {}&quot;, form.name, form.email);

    ctx.flash_success(&quot;Thank you! We'll get back to you soon.&quot;);
    ctx.redirect(&quot;/&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#optional-fields" id="optional-fields"><h4>Optional Fields</h4></a>
<p>Use <code>Option&lt;T&gt;</code> for optional form fields:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Deserialize)]
struct ProfileForm {
    name: String,              // Required
    bio: Option&lt;String&gt;,       // Optional
    website: Option&lt;String&gt;,   // Optional
    age: Option&lt;i32&gt;,          // Optional number
    newsletter: Option&lt;bool&gt;,  // Optional checkbox
}

async fn update_profile(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form: ProfileForm = ctx.body_form_typed()?;

    // Required field is always present
    let name = form.name;

    // Optional fields can be None
    if let Some(bio) = form.bio {
        log::info!(&quot;User bio: {}&quot;, bio);
    }

    // Provide defaults for optional fields
    let website = form.website.unwrap_or_else(|| &quot;Not provided&quot;.to_string());
    let age = form.age.unwrap_or(0);
    let newsletter = form.newsletter.unwrap_or(false);

    ctx.flash_success(&quot;Profile updated!&quot;);
    ctx.redirect(&quot;/profile&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#working-with-arrays-multiple-select--checkboxes" id="working-with-arrays-multiple-select--checkboxes"><h4>Working with Arrays (Multiple Select / Checkboxes)</h4></a>
<p>Handle multiple values using <code>Vec&lt;T&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Deserialize)]
struct PreferencesForm {
    username: String,
    interests: Vec&lt;String&gt;,      // Multiple checkboxes
    languages: Vec&lt;String&gt;,       // Multiple select
    notifications: Option&lt;Vec&lt;String&gt;&gt;, // Optional multiple
}

async fn save_preferences(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form: PreferencesForm = ctx.body_form_typed()?;

    // Handle multiple values
    log::info!(&quot;User interests: {:?}&quot;, form.interests);
    log::info!(&quot;Languages: {:?}&quot;, form.languages);

    // Optional arrays
    if let Some(notif) = form.notifications {
        log::info!(&quot;Notification preferences: {:?}&quot;, notif);
    }

    ctx.flash_success(&quot;Preferences saved!&quot;);
    ctx.redirect(&quot;/settings&quot;)
}
#}</code></pre></pre>
<p><strong>HTML Form Example:</strong></p>
<pre><code class="language-html">&lt;form method=&quot;POST&quot;&gt;
    &lt;input name=&quot;username&quot; value=&quot;john_doe&quot; /&gt;

    &lt;!-- Multiple checkboxes with same name --&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;interests&quot; value=&quot;sports&quot; checked /&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;interests&quot; value=&quot;music&quot; checked /&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;interests&quot; value=&quot;travel&quot; /&gt;

    &lt;!-- Multiple select --&gt;
    &lt;select name=&quot;languages&quot; multiple&gt;
        &lt;option value=&quot;en&quot; selected&gt;English&lt;/option&gt;
        &lt;option value=&quot;fr&quot; selected&gt;French&lt;/option&gt;
        &lt;option value=&quot;es&quot;&gt;Spanish&lt;/option&gt;
    &lt;/select&gt;
&lt;/form&gt;
</code></pre>
<a class="header" href="print.html#post-processing-transformations" id="post-processing-transformations"><h4>Post-Processing Transformations</h4></a>
<p>Apply transformations after parsing:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Deserialize)]
struct CountryForm {
    code: String,
    name: String,
    native_name: Option&lt;String&gt;,
    timezone: Option&lt;String&gt;,
}

async fn save_country(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let mut form: CountryForm = ctx.body_form_typed()?;

    // Apply transformations
    form.code = form.code.trim().to_uppercase();
    form.name = form.name.trim().to_string();

    // Transform optional fields
    form.native_name = form.native_name
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty());

    form.timezone = form.timezone
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty());

    // Validate transformed data
    if form.code.len() != 2 {
        ctx.flash_error(&quot;Country code must be exactly 2 characters&quot;);
        return ctx.redirect(&quot;/countries/new&quot;);
    }

    // Save to database...

    ctx.flash_success(&amp;format!(&quot;Country {} created!&quot;, form.name));
    ctx.redirect(&quot;/countries&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#nested-structures" id="nested-structures"><h4>Nested Structures</h4></a>
<p>Handle complex nested forms:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Deserialize)]
struct Address {
    street: String,
    city: String,
    country: String,
    postal_code: String,
}

#[derive(Deserialize)]
struct UserForm {
    name: String,
    email: String,
    address: Address,  // Nested structure
}

async fn create_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form: UserForm = ctx.body_form_typed()?;

    // Access nested data
    log::info!(&quot;User: {}&quot;, form.name);
    log::info!(&quot;Address: {}, {}&quot;, form.address.city, form.address.country);

    ctx.json(json!({
        &quot;success&quot;: true,
        &quot;user&quot;: form
    }))
}
#}</code></pre></pre>
<p><strong>HTML Form Example:</strong></p>
<pre><code class="language-html">&lt;form method=&quot;POST&quot;&gt;
    &lt;input name=&quot;name&quot; value=&quot;John Doe&quot; /&gt;
    &lt;input name=&quot;email&quot; value=&quot;john@example.com&quot; /&gt;

    &lt;!-- Nested fields use dot notation --&gt;
    &lt;input name=&quot;address.street&quot; value=&quot;123 Main St&quot; /&gt;
    &lt;input name=&quot;address.city&quot; value=&quot;New York&quot; /&gt;
    &lt;input name=&quot;address.country&quot; value=&quot;USA&quot; /&gt;
    &lt;input name=&quot;address.postal_code&quot; value=&quot;10001&quot; /&gt;
&lt;/form&gt;
</code></pre>
<a class="header" href="print.html#error-handling" id="error-handling"><h4>Error Handling</h4></a>
<p>Handle parsing errors gracefully:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn safe_form_handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Parse form with error handling
    let form: ContactForm = match ctx.body_form_typed() {
        Ok(f) =&gt; f,
        Err(e) =&gt; {
            log::error!(&quot;Form parsing error: {}&quot;, e);
            ctx.flash_error(&quot;Invalid form data. Please check your input.&quot;);
            return ctx.redirect(&quot;/contact&quot;);
        }
    };

    // Process valid form...
    ctx.flash_success(&quot;Form submitted successfully!&quot;);
    ctx.redirect(&quot;/&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#comparison-three-approaches" id="comparison-three-approaches"><h4>Comparison: Three Approaches</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ Approach 1: Manual (verbose, error-prone)
async fn manual_approach(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form_data = ctx.body_form()?;
    let name = form_data.get(&quot;name&quot;).unwrap_or(&amp;String::new()).clone();
    let email = form_data.get(&quot;email&quot;).unwrap_or(&amp;String::new()).clone();
    let age = form_data.get(&quot;age&quot;).unwrap_or(&amp;String::new()).parse::&lt;i32&gt;().unwrap_or(0);
    // ... lots of repetitive code
}

// âš ï¸ Approach 2: Field helpers (good for simple forms)
async fn field_helpers_approach(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let name = ctx.str_body(&quot;name&quot;)?;
    let email = ctx.str_body(&quot;email&quot;)?;
    let age = ctx.int_body(&quot;age&quot;)?;
    // Good for 2-3 fields, becomes verbose with many fields
}

// âœ… Approach 3: Typed parsing (recommended for complex forms)
#[derive(Deserialize)]
struct UserForm {
    name: String,
    email: String,
    age: i32,
}

async fn typed_approach(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form: UserForm = ctx.body_form_typed()?;
    // Clean, type-safe, and concise!
}
#}</code></pre></pre>
<a class="header" href="print.html#when-to-use-each-method" id="when-to-use-each-method"><h4>When to Use Each Method</h4></a>
<p><strong>Use <code>body_form_typed&lt;T&gt;()</code></strong> when:</p>
<ul>
<li>âœ… Form has 4+ fields</li>
<li>âœ… You need type safety</li>
<li>âœ… You have nested data structures</li>
<li>âœ… You want to reuse form structures</li>
<li>âœ… You need to pass form data to other functions</li>
</ul>
<p><strong>Use individual field helpers</strong> (<code>str_body()</code>, etc.) when:</p>
<ul>
<li>âœ… Form has 1-3 simple fields</li>
<li>âœ… You need immediate validation</li>
<li>âœ… Quick prototyping</li>
</ul>
<p><strong>Use manual <code>body_form()</code></strong> when:</p>
<ul>
<li>âœ… You need maximum flexibility</li>
<li>âœ… Dynamic field names</li>
<li>âœ… Custom parsing logic</li>
</ul>
<a class="header" href="print.html#restful-api-controller" id="restful-api-controller"><h3>RESTful API Controller</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/controllers/api.rs
use rustf::prelude::*;
use serde::{Serialize, Deserialize};

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        // User management API
        GET    &quot;/api/users&quot;          =&gt; list_users,
        GET    &quot;/api/users/{id}&quot;      =&gt; get_user,
        POST   &quot;/api/users&quot;          =&gt; create_user,
        PUT    &quot;/api/users/{id}&quot;      =&gt; update_user,
        DELETE &quot;/api/users/{id}&quot;      =&gt; delete_user,
        
        // Additional endpoints
        GET    &quot;/api/users/search&quot;   =&gt; search_users,
        GET    &quot;/api/health&quot;         =&gt; health_check,
    ]
}

#[derive(Serialize, Deserialize)]
struct User {
    id: i32,
    name: String,
    email: String,
    created_at: String,
    is_active: bool,
}

#[derive(Deserialize)]
struct CreateUserRequest {
    name: String,
    email: String,
}

#[derive(Deserialize)] 
struct UpdateUserRequest {
    name: Option&lt;String&gt;,
    email: Option&lt;String&gt;,
    is_active: Option&lt;bool&gt;,
}

async fn list_users(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Parse query parameters for pagination
    let page = ctx.query(&quot;page&quot;).unwrap_or(&quot;1&quot;).parse::&lt;i32&gt;().unwrap_or(1);
    let limit = ctx.query(&quot;limit&quot;).unwrap_or(&quot;10&quot;).parse::&lt;i32&gt;().unwrap_or(10);
    
    let users = vec![
        User {
            id: 1,
            name: &quot;Alice Johnson&quot;.to_string(),
            email: &quot;alice@example.com&quot;.to_string(),
            created_at: &quot;2024-01-15T10:00:00Z&quot;.to_string(),
            is_active: true,
        },
        User {
            id: 2,
            name: &quot;Bob Smith&quot;.to_string(),
            email: &quot;bob@example.com&quot;.to_string(),
            created_at: &quot;2024-02-20T14:30:00Z&quot;.to_string(),
            is_active: true,
        },
    ];
    
    ctx.json(json!({
        &quot;users&quot;: users,
        &quot;pagination&quot;: {
            &quot;page&quot;: page,
            &quot;limit&quot;: limit,
            &quot;total&quot;: users.len(),
            &quot;total_pages&quot;: 1
        }
    }))
}

async fn get_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let user_id = ctx.param(&quot;id&quot;).unwrap_or(&quot;0&quot;);
    
    match user_id.parse::&lt;i32&gt;() {
        Ok(id) if id &gt; 0 =&gt; {
            let user = User {
                id,
                name: &quot;Sample User&quot;.to_string(),
                email: &quot;user@example.com&quot;.to_string(),
                created_at: &quot;2024-01-01T00:00:00Z&quot;.to_string(),
                is_active: true,
            };
            
            ctx.json(json!({
                &quot;success&quot;: true,
                &quot;user&quot;: user
            }))
        }
        _ =&gt; {
            ctx.throw400(Some(&quot;Invalid user ID&quot;))
        }
    }
}

async fn create_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let request: CreateUserRequest = ctx.body_json()?;
    
    // Validation
    if request.name.trim().is_empty() {
        return ctx.throw400(Some(&quot;Name is required&quot;));
    }
    
    if !request.email.contains('@') {
        return ctx.throw400(Some(&quot;Valid email is required&quot;));
    }
    
    // Create user (in real app: save to database)
    let user = User {
        id: 3, // Would be generated by database
        name: request.name,
        email: request.email,
        created_at: chrono::Utc::now().to_rfc3339(),
        is_active: true,
    };
    
    ctx.json(json!({
        &quot;success&quot;: true,
        &quot;message&quot;: &quot;User created successfully&quot;,
        &quot;user&quot;: user
    }))
}

async fn update_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let user_id = ctx.param(&quot;id&quot;).unwrap_or(&quot;0&quot;);
    let request: UpdateUserRequest = ctx.body_json()?;
    
    match user_id.parse::&lt;i32&gt;() {
        Ok(id) if id &gt; 0 =&gt; {
            // In real app: update in database
            ctx.json(json!({
                &quot;success&quot;: true,
                &quot;message&quot;: &quot;User updated successfully&quot;,
                &quot;user_id&quot;: id,
                &quot;updated_fields&quot;: request
            }))
        }
        _ =&gt; {
            ctx.throw400(Some(&quot;Invalid user ID&quot;))
        }
    }
}

async fn delete_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let user_id = ctx.param(&quot;id&quot;).unwrap_or(&quot;0&quot;);
    
    match user_id.parse::&lt;i32&gt;() {
        Ok(id) if id &gt; 0 =&gt; {
            // In real app: delete from database
            ctx.json(json!({
                &quot;success&quot;: true,
                &quot;message&quot;: &quot;User deleted successfully&quot;,
                &quot;deleted_user_id&quot;: id
            }))
        }
        _ =&gt; {
            ctx.throw400(Some(&quot;Invalid user ID&quot;))
        }
    }
}

async fn search_users(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let query = ctx.query(&quot;q&quot;).unwrap_or(&quot;&quot;);
    
    if query.is_empty() {
        return ctx.throw400(Some(&quot;Search query is required&quot;));
    }
    
    // In real app: search database
    let results = vec![
        User {
            id: 1,
            name: &quot;Alice Johnson&quot;.to_string(),
            email: &quot;alice@example.com&quot;.to_string(),
            created_at: &quot;2024-01-15T10:00:00Z&quot;.to_string(),
            is_active: true,
        }
    ];
    
    ctx.json(json!({
        &quot;success&quot;: true,
        &quot;query&quot;: query,
        &quot;results&quot;: results,
        &quot;count&quot;: results.len()
    }))
}

async fn health_check(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    ctx.json(json!({
        &quot;status&quot;: &quot;healthy&quot;,
        &quot;timestamp&quot;: chrono::Utc::now().to_rfc3339(),
        &quot;version&quot;: &quot;1.0.0&quot;
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#advanced-features" id="advanced-features"><h2>Advanced Features</h2></a>
<a class="header" href="print.html#url-parameters" id="url-parameters"><h3>URL Parameters</h3></a>
<p>Capture dynamic parts of URLs using the <code>{parameter}</code> syntax:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
routes![
    GET &quot;/users/{id}&quot; =&gt; get_user,
    GET &quot;/users/{user_id}/posts/{post_id}&quot; =&gt; get_user_post,
    GET &quot;/posts/{post_id}/comments/{comment_id}&quot; =&gt; get_comment,
    GET &quot;/files/{category}/{filename}&quot; =&gt; download_file,
]

async fn get_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let id = ctx.param(&quot;id&quot;).unwrap_or(&quot;0&quot;);
    
    // Validate and parse parameter
    match id.parse::&lt;i32&gt;() {
        Ok(user_id) if user_id &gt; 0 =&gt; {
            // Use the validated user_id
            ctx.json(json!({&quot;user_id&quot;: user_id, &quot;name&quot;: &quot;User Name&quot;}))
        }
        _ =&gt; ctx.throw400(Some(&quot;Invalid user ID&quot;))
    }
}

async fn get_user_post(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let user_id = ctx.param(&quot;user_id&quot;).unwrap_or(&quot;0&quot;);
    let post_id = ctx.param(&quot;post_id&quot;).unwrap_or(&quot;0&quot;);
    
    ctx.json(json!({
        &quot;user_id&quot;: user_id,
        &quot;post_id&quot;: post_id,
        &quot;title&quot;: &quot;Sample Post&quot;
    }))
}

async fn download_file(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let category = ctx.param(&quot;category&quot;).unwrap_or(&quot;general&quot;);
    let filename = ctx.param(&quot;filename&quot;).unwrap_or(&quot;file.txt&quot;);
    
    // Security: validate file path (prevent directory traversal)
    if filename.contains(&quot;..&quot;) || filename.contains('/') {
        return ctx.throw403(Some(&quot;Invalid filename&quot;));
    }
    
    let file_path = format!(&quot;uploads/{}/{}&quot;, category, filename);
    ctx.file_download(&amp;file_path, Some(filename))
}
#}</code></pre></pre>
<a class="header" href="print.html#query-parameters" id="query-parameters"><h3>Query Parameters</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// URL: /search?q=rust&amp;category=programming&amp;page=2
async fn search(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let query = ctx.query(&quot;q&quot;).unwrap_or(&quot;&quot;);
    let category = ctx.query(&quot;category&quot;).unwrap_or(&quot;all&quot;);
    let page = ctx.query(&quot;page&quot;).unwrap_or(&quot;1&quot;)
        .parse::&lt;i32&gt;().unwrap_or(1);
    
    if query.is_empty() {
        return ctx.throw400(Some(&quot;Search query is required&quot;));
    }
    
    // Perform search with parameters
    ctx.json(json!({
        &quot;query&quot;: query,
        &quot;category&quot;: category,
        &quot;page&quot;: page,
        &quot;results&quot;: [/* search results */]
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#file-handling" id="file-handling"><h3>File Handling</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
routes![
    GET  &quot;/upload&quot; =&gt; upload_form,
    POST &quot;/upload&quot; =&gt; handle_upload,
    GET  &quot;/files/{filename}&quot; =&gt; serve_file,
]

async fn upload_form(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    ctx.view(&quot;/upload&quot;, json!({&quot;title&quot;: &quot;File Upload&quot;}))
}

async fn handle_upload(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Get uploaded files
    let files = ctx.files()?;
    
    if files.is_empty() {
        ctx.flash_error(&quot;No files were uploaded&quot;);
        return ctx.redirect(&quot;/upload&quot;);
    }
    
    // Process first uploaded file
    if let Some(file) = ctx.file(&quot;document&quot;)? {
        // Validate file type
        let allowed_types = [&quot;pdf&quot;, &quot;doc&quot;, &quot;docx&quot;, &quot;txt&quot;];
        let file_ext = file.filename
            .as_ref()
            .and_then(|name| name.split('.').last())
            .unwrap_or(&quot;&quot;);
            
        if !allowed_types.contains(&amp;file_ext) {
            ctx.flash_error(&quot;Only PDF, DOC, DOCX, and TXT files are allowed&quot;);
            return ctx.redirect(&quot;/upload&quot;);
        }
        
        // Save file (in real app: save to disk/cloud storage)
        let filename = format!(&quot;upload_{}.{}&quot;, U::guid(), file_ext);
        
        ctx.flash_success(&amp;format!(&quot;File '{}' uploaded successfully as {}&quot;, 
            file.filename.as_ref().unwrap_or(&amp;&quot;unknown&quot;.to_string()), filename));
    }
    
    ctx.redirect(&quot;/upload&quot;)
}

async fn serve_file(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let filename = ctx.param(&quot;filename&quot;).unwrap_or(&quot;missing&quot;);
    let file_path = format!(&quot;uploads/{}&quot;, filename);
    
    // Security check
    if filename.contains(&quot;..&quot;) {
        return ctx.throw403(Some(&quot;Access denied&quot;));
    }
    
    ctx.file_download(&amp;file_path, Some(filename))
}
#}</code></pre></pre>
<a class="header" href="print.html#middleware-integration" id="middleware-integration"><h3>Middleware Integration</h3></a>
<p>Controllers work seamlessly with middleware:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Authentication middleware can protect routes
routes![
    GET &quot;/admin/dashboard&quot; =&gt; admin_dashboard,  // Protected by auth middleware
    GET &quot;/admin/users&quot;     =&gt; admin_users,     // Protected by auth middleware
    GET &quot;/public/info&quot;     =&gt; public_info,     // Not protected
]

async fn admin_dashboard(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // This handler only runs if auth middleware allows it
    let user: Value = ctx.session_get(&quot;user&quot;).unwrap_or_default();
    
    ctx.view(&quot;/admin/dashboard&quot;, json!({
        &quot;title&quot;: &quot;Admin Dashboard&quot;,
        &quot;user&quot;: user
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#error-handling-best-practices" id="error-handling-best-practices"><h2>Error Handling Best Practices</h2></a>
<a class="header" href="print.html#structured-error-handling" id="structured-error-handling"><h3>Structured Error Handling</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn robust_handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Parse form data with proper error handling
    let form_data = match ctx.body_form() {
        Ok(data) =&gt; data,
        Err(e) =&gt; {
            log::error!(&quot;Failed to parse form data: {}&quot;, e);
            return ctx.throw400(Some(&quot;Invalid form data&quot;));
        }
    };
    
    // Validate required fields
    let email = match form_data.get(&quot;email&quot;) {
        Some(email) if !email.is_empty() =&gt; email,
        _ =&gt; {
            ctx.flash_error(&quot;Email is required&quot;);
            return ctx.redirect(&quot;/form&quot;);
        }
    };
    
    // Business logic validation
    if !email.contains('@') {
        ctx.flash_error(&quot;Please provide a valid email address&quot;);
        return ctx.redirect(&quot;/form&quot;);
    }
    
    // Success path
    ctx.flash_success(&quot;Form processed successfully!&quot;);
    ctx.redirect(&quot;/success&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#api-error-responses" id="api-error-responses"><h3>API Error Responses</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn api_handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Parse JSON with error handling
    let request_data: Value = match ctx.body_json() {
        Ok(data) =&gt; data,
        Err(_) =&gt; {
            return ctx.json(json!({
                &quot;error&quot;: &quot;Invalid JSON&quot;,
                &quot;code&quot;: &quot;INVALID_JSON&quot;,
                &quot;status&quot;: 400
            }));
        }
    };
    
    // Validate required fields
    let name = match request_data[&quot;name&quot;].as_str() {
        Some(name) if !name.trim().is_empty() =&gt; name.trim(),
        _ =&gt; {
            return ctx.json(json!({
                &quot;error&quot;: &quot;Name is required&quot;,
                &quot;code&quot;: &quot;MISSING_NAME&quot;, 
                &quot;status&quot;: 400
            }));
        }
    };
    
    // Success response
    ctx.json(json!({
        &quot;success&quot;: true,
        &quot;message&quot;: &quot;Data processed successfully&quot;,
        &quot;data&quot;: {&quot;name&quot;: name}
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#using-http-error-methods" id="using-http-error-methods"><h3>Using HTTP Error Methods</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn comprehensive_error_handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let action = ctx.param(&quot;action&quot;).unwrap_or(&quot;&quot;);
    
    match action {
        &quot;unauthorized&quot; =&gt; ctx.throw401(Some(&quot;Please log in&quot;)),
        &quot;forbidden&quot; =&gt; ctx.throw403(Some(&quot;Access denied&quot;)), 
        &quot;notfound&quot; =&gt; ctx.throw404(Some(&quot;Resource not found&quot;)),
        &quot;conflict&quot; =&gt; ctx.throw409(Some(&quot;Resource already exists&quot;)),
        &quot;server_error&quot; =&gt; ctx.throw500(Some(&quot;Internal server error&quot;)),
        &quot;not_implemented&quot; =&gt; ctx.throw501(Some(&quot;Feature not implemented&quot;)),
        _ =&gt; ctx.throw400(Some(&quot;Invalid action&quot;))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#framework-integration" id="framework-integration"><h2>Framework Integration</h2></a>
<a class="header" href="print.html#how-controllers-work-in-rustf" id="how-controllers-work-in-rustf"><h3>How Controllers Work in RustF</h3></a>
<ol>
<li><strong>Route Registration</strong> - Controllers return <code>Vec&lt;Route&gt;</code> from their <code>install()</code> function</li>
<li><strong>Request Matching</strong> - Framework matches incoming requests to routes using method and path</li>
<li><strong>Context Creation</strong> - Framework creates a <code>Context</code> with request data, session, and config</li>
<li><strong>Middleware Chain</strong> - Request passes through middleware before reaching controller</li>
<li><strong>Handler Execution</strong> - Controller handler processes request and returns response</li>
<li><strong>Response Processing</strong> - Framework sends response back to client</li>
</ol>
<a class="header" href="print.html#application-lifecycle" id="application-lifecycle"><h3>Application Lifecycle</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 1. Application setup
let app = RustF::new()
    .controllers(auto_controllers!())  // Register all controllers
    .middleware(&quot;auth&quot;, AuthMiddleware::new());  // Add middleware

// 2. Server startup
app.start().await;  // Starts HTTP server

// 3. Request processing
// HTTP Request -&gt; Middleware Chain -&gt; Controller Handler -&gt; HTTP Response
#}</code></pre></pre>
<a class="header" href="print.html#best-practices-1" id="best-practices-1"><h2>Best Practices</h2></a>
<a class="header" href="print.html#1-controller-organization" id="1-controller-organization"><h3>1. Controller Organization</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Group related functionality
// src/controllers/auth.rs - All authentication
// src/controllers/users.rs - All user management
// src/controllers/api/users.rs - API endpoints for users

// âŒ Bad: Mixed functionality in one controller
// src/controllers/everything.rs - Login, users, posts, etc.
#}</code></pre></pre>
<a class="header" href="print.html#2-naming-conventions" id="2-naming-conventions"><h3>2. Naming Conventions</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Descriptive, consistent names
routes![
    GET  &quot;/login&quot;  =&gt; view_login,     // Shows form
    POST &quot;/login&quot;  =&gt; do_login,       // Processes form
    GET  &quot;/users&quot;  =&gt; list_users,     // Lists resources
    GET  &quot;/users/{id}&quot; =&gt; show_user,   // Shows single resource
    POST &quot;/users&quot;  =&gt; create_user,    // Creates resource
    PUT  &quot;/users/{id}&quot; =&gt; update_user, // Updates resource
    DELETE &quot;/users/{id}&quot; =&gt; delete_user, // Deletes resource
]

// âŒ Bad: Generic, unclear names
routes![
    GET &quot;/login&quot; =&gt; handler1,
    POST &quot;/login&quot; =&gt; handler2,
    GET &quot;/users&quot; =&gt; users,
]
#}</code></pre></pre>
<a class="header" href="print.html#3-input-validation" id="3-input-validation"><h3>3. Input Validation</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Comprehensive validation
async fn create_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form_data = ctx.body_form()?;
    
    // Validate required fields
    let email = match form_data.get(&quot;email&quot;) {
        Some(email) if !email.trim().is_empty() =&gt; email.trim(),
        _ =&gt; {
            ctx.flash_error(&quot;Email is required&quot;);
            return ctx.redirect(&quot;/users/new&quot;);
        }
    };
    
    // Validate format
    if !email.contains('@') {
        ctx.flash_error(&quot;Please provide a valid email address&quot;);
        return ctx.redirect(&quot;/users/new&quot;);
    }
    
    // Continue with processing...
}

// âŒ Bad: No validation
async fn create_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form_data = ctx.body_form()?;
    let email = form_data.get(&quot;email&quot;).unwrap(); // Can panic!
    // Save without validation...
}
#}</code></pre></pre>
<a class="header" href="print.html#4-error-handling" id="4-error-handling"><h3>4. Error Handling</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Proper error handling with user feedback
async fn process_payment(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let amount_str = ctx.query(&quot;amount&quot;).unwrap_or(&quot;0&quot;);
    
    let amount = match amount_str.parse::&lt;f64&gt;() {
        Ok(amt) if amt &gt; 0.0 =&gt; amt,
        _ =&gt; {
            ctx.flash_error(&quot;Invalid payment amount&quot;);
            return ctx.redirect(&quot;/payment&quot;);
        }
    };
    
    // Process payment with proper error handling
    match process_payment_logic(amount).await {
        Ok(receipt) =&gt; {
            ctx.flash_success(&quot;Payment processed successfully!&quot;);
            ctx.redirect(&amp;format!(&quot;/receipt/{}&quot;, receipt.id))
        }
        Err(e) =&gt; {
            log::error!(&quot;Payment failed: {}&quot;, e);
            ctx.flash_error(&quot;Payment processing failed. Please try again.&quot;);
            ctx.redirect(&quot;/payment&quot;)
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#5-response-patterns" id="5-response-patterns"><h3>5. Response Patterns</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Consistent response patterns
routes![
    GET  &quot;/users&quot;     =&gt; list_users,    // Returns view or JSON list
    POST &quot;/users&quot;     =&gt; create_user,   // Redirects on success, back on error
    GET  &quot;/api/users&quot; =&gt; api_list_users, // Always returns JSON
]

async fn list_users(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let users = get_users().await?;
    ctx.view(&quot;/users/index&quot;, json!({&quot;users&quot;: users}))
}

async fn create_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Validation...
    // Creation...
    
    ctx.flash_success(&quot;User created successfully!&quot;);
    ctx.redirect(&quot;/users&quot;)
}

async fn api_list_users(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let users = get_users().await?;
    ctx.json(json!({
        &quot;success&quot;: true,
        &quot;users&quot;: users,
        &quot;count&quot;: users.len()
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#6-security-considerations" id="6-security-considerations"><h3>6. Security Considerations</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Security-aware controller
async fn download_file(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let filename = ctx.param(&quot;filename&quot;).unwrap_or(&quot;&quot;);
    
    // Prevent directory traversal attacks
    if filename.contains(&quot;..&quot;) || filename.contains('/') || filename.contains('\\') {
        return ctx.throw403(Some(&quot;Invalid filename&quot;));
    }
    
    // Validate file exists and user has access
    let file_path = format!(&quot;uploads/{}&quot;, filename);
    if !std::path::Path::new(&amp;file_path).exists() {
        return ctx.throw404(Some(&quot;File not found&quot;));
    }
    
    // Check user permissions
    if let Some(user) = ctx.session_get::&lt;Value&gt;(&quot;user&quot;) {
        ctx.file_download(&amp;file_path, Some(filename))
    } else {
        ctx.throw401(Some(&quot;Login required&quot;))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#7-testing-controllers" id="7-testing-controllers"><h3>7. Testing Controllers</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use rustf::test_helpers::*;
    
    #[tokio::test]
    async fn test_login_success() {
        let ctx = create_test_context()
            .with_form_data([
                (&quot;email&quot;, &quot;test@example.com&quot;),
                (&quot;password&quot;, &quot;password&quot;)
            ]);
            
        let response = do_login(ctx).await.unwrap();
        assert_eq!(response.status_code(), 302); // Redirect
    }
    
    #[tokio::test]
    async fn test_login_invalid_email() {
        let ctx = create_test_context()
            .with_form_data([
                (&quot;email&quot;, &quot;invalid-email&quot;),
                (&quot;password&quot;, &quot;password&quot;)
            ]);
            
        let response = do_login(ctx).await.unwrap();
        assert_eq!(response.status_code(), 302); // Redirect back to form
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#file-organization" id="file-organization"><h2>File Organization</h2></a>
<a class="header" href="print.html#recommended-project-structure" id="recommended-project-structure"><h3>Recommended Project Structure</h3></a>
<pre><code>src/
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ home.rs          # Home page, about, contact
â”‚   â”œâ”€â”€ auth.rs          # Authentication (login, register, logout)
â”‚   â”œâ”€â”€ users.rs         # User management (CRUD operations)
â”‚   â”œâ”€â”€ posts.rs         # Blog posts or content
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ mod.rs        # API module declaration
â”‚   â”‚   â”œâ”€â”€ users.rs      # User API endpoints
â”‚   â”‚   â”œâ”€â”€ posts.rs      # Posts API endpoints
â”‚   â”‚   â””â”€â”€ auth.rs       # Authentication API
â”‚   â”œâ”€â”€ admin/
â”‚   â”‚   â”œâ”€â”€ mod.rs        # Admin module declaration
â”‚   â”‚   â”œâ”€â”€ dashboard.rs  # Admin dashboard
â”‚   â”‚   â”œâ”€â”€ users.rs      # Admin user management
â”‚   â”‚   â””â”€â”€ settings.rs   # System settings
â”‚   â””â”€â”€ errors.rs         # Error pages (404, 500, etc.)
â”œâ”€â”€ _controllers.rs       # Auto-generated (DO NOT EDIT)
â”œâ”€â”€ models/              # Database models
â”œâ”€â”€ modules/             # Business logic modules
â”œâ”€â”€ middleware/          # Custom middleware
â””â”€â”€ main.rs              # Application entry point
</code></pre>
<a class="header" href="print.html#auto-generated-files" id="auto-generated-files"><h3>Auto-Generated Files</h3></a>
<ul>
<li><code>_controllers.rs</code> - Generated by <code>#[rustf::auto_discover]</code> for IDE support</li>
<li><strong>DO NOT EDIT</strong> auto-generated files manually</li>
<li>Regenerated on each build when controllers change</li>
</ul>
<a class="header" href="print.html#summary" id="summary"><h2>Summary</h2></a>
<p>RustF's controller system provides:</p>
<p>âœ… <strong>Clean Architecture</strong> - Separate HTTP handling from business logic
âœ… <strong>Auto-Discovery</strong> - Automatic controller registration at compile time<br />
âœ… <strong>Type Safety</strong> - Compile-time validation of routes and handlers
âœ… <strong>Total.js Familiarity</strong> - Familiar patterns for web developers
âœ… <strong>Flexible Organization</strong> - Organize controllers by feature or API version
âœ… <strong>Rich Context API</strong> - Comprehensive request/response handling
âœ… <strong>Error Handling</strong> - Built-in HTTP error responses
âœ… <strong>Security Features</strong> - Session management, input validation helpers
âœ… <strong>Testing Support</strong> - Easy to unit test individual handlers</p>
<p>The controller system strikes a balance between simplicity and power, making it easy to build maintainable web applications while providing all the features needed for modern web development.</p>
<a class="header" href="print.html#related-topics" id="related-topics"><h2>Related Topics</h2></a>
<ul>
<li><a href="views.md">Views &amp; Templates</a> - Learn how to render templates in controllers</li>
<li><a href="middleware.md">Middleware</a> - Add request/response processing to your routes</li>
<li><a href="sessions.md">Sessions</a> - Manage user sessions in your controllers</li>
<li><a href="error-handling.md">Error Handling</a> - Handle errors gracefully</li>
<li><a href="database.md">Database Integration</a> - Access databases from controllers</li>
<li><a href="../api-reference/context.md">API Reference: Context</a> - Complete Context API documentation</li>
<li><a href="../examples/rest-api.md">Examples: REST API</a> - See controllers in action</li>
</ul>
<a class="header" href="print.html#rustf-view--template-engine-layer" id="rustf-view--template-engine-layer"><h1>RustF View &amp; Template Engine Layer</h1></a>
<a class="header" href="print.html#overview-1" id="overview-1"><h2>Overview</h2></a>
<p>RustF provides a powerful view system with Total.js as the built-in template engine. The framework is optimized for Total.js templates, providing a familiar syntax for Total.js developers and direct integration with framework features.</p>
<a class="header" href="print.html#template-engine" id="template-engine"><h2>Template Engine</h2></a>
<a class="header" href="print.html#totaljs-built-in" id="totaljs-built-in"><h3>Total.js (Built-in)</h3></a>
<ul>
<li><strong>No feature flag required</strong> - Always available</li>
<li><strong>Syntax</strong>: Uses <code>@{...}</code> for expressions</li>
<li><strong>Compatible with Total.js v4</strong> - Familiar syntax for Total.js developers</li>
<li><strong>Optimized for RustF</strong> - Direct integration with framework features</li>
<li><strong>Powerful features</strong> - Conditionals, loops, layouts, sections, helpers</li>
<li><strong>Auto-escaping</strong> - HTML is escaped by default for security</li>
</ul>
<a class="header" href="print.html#configuration" id="configuration"><h2>Configuration</h2></a>
<p>Configure your template engine in <code>config.toml</code>:</p>
<pre><code class="language-toml">[views]
directory = &quot;views&quot;                # Template directory
default_layout = &quot;layouts/default&quot;  # Default layout template
cache_enabled = false              # Template caching (dev: false, prod: true)
extension = &quot;html&quot;                 # File extension for templates
# engine is always &quot;totaljs&quot; - no other options available
storage = &quot;filesystem&quot;             # Choose: &quot;filesystem&quot; or &quot;embedded&quot;
default_root = &quot;&quot;                  # Base URL path for deployment (e.g., &quot;/app&quot;)
</code></pre>
<a class="header" href="print.html#basic-usage" id="basic-usage"><h2>Basic Usage</h2></a>
<a class="header" href="print.html#in-controllers" id="in-controllers"><h3>In Controllers</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

#[rustf::install]
impl HomeController {
    #[route(GET, &quot;/&quot;)]
    pub async fn index(ctx: Context) -&gt; Result&lt;Response&gt; {
        // Render a template with data
        ctx.view(&quot;home/index&quot;, json!({
            &quot;title&quot;: &quot;Welcome&quot;,
            &quot;message&quot;: &quot;Hello from RustF!&quot;,
            &quot;features&quot;: vec![&quot;Fast&quot;, &quot;Safe&quot;, &quot;Productive&quot;]
        }))
    }
    
    #[route(GET, &quot;/about&quot;)]
    pub async fn about(mut ctx: Context) -&gt; Result&lt;Response&gt; {
        // Render with custom layout
        ctx.layout(&quot;layouts/special&quot;)
            .view(&quot;about&quot;, json!({
                &quot;title&quot;: &quot;About Us&quot;
            }))
    }
    
    #[route(GET, &quot;/standalone&quot;)]
    pub async fn standalone(mut ctx: Context) -&gt; Result&lt;Response&gt; {
        // Render without layout
        ctx.layout(&quot;&quot;)  // Empty string = no layout
            .view(&quot;standalone&quot;, json!({
                &quot;content&quot;: &quot;This page has no layout&quot;
            }))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#context-methods" id="context-methods"><h3>Context Methods</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Basic template rendering
ctx.view(&quot;template_name&quot;, data)

// Set custom layout (requires mut ctx)
ctx.layout(&quot;layouts/special&quot;)
    .view(&quot;template&quot;, data)

// Render without layout
ctx.layout(&quot;&quot;)  // Empty string = no layout
    .view(&quot;template&quot;, data)

// Use default layout from config (no need to call layout())
ctx.view(&quot;template&quot;, data)  // Uses config.views.default_layout

// Render HTML string directly
ctx.html(&quot;&lt;h1&gt;Direct HTML&lt;/h1&gt;&quot;)

// JSON response
ctx.json(data)

// Text response
ctx.text(&quot;Plain text response&quot;)
#}</code></pre></pre>
<a class="header" href="print.html#totaljs-template-syntax" id="totaljs-template-syntax"><h2>Total.js Template Syntax</h2></a>
<a class="header" href="print.html#variables" id="variables"><h3>Variables</h3></a>
<pre><code class="language-html">&lt;!-- Model/View data access --&gt;
&lt;h1&gt;@{model.title}&lt;/h1&gt;
&lt;h1&gt;@{M.title}&lt;/h1&gt;  &lt;!-- Alias for model --&gt;

&lt;!-- Nested properties --&gt;
&lt;p&gt;@{model.user.name}&lt;/p&gt;
&lt;p&gt;@{M.user.name}&lt;/p&gt;  &lt;!-- Alias --&gt;

&lt;!-- With default value --&gt;
&lt;!-- Default values using || operator --&gt;
&lt;p&gt;@{model.description || 'No description'}&lt;/p&gt;
&lt;p&gt;@{user.avatar || '/images/default-avatar.png'}&lt;/p&gt;
&lt;span&gt;@{settings.theme || 'light'}&lt;/span&gt;
</code></pre>
<p><strong>Using <code>||</code> for Fallback Values:</strong></p>
<p>The <code>||</code> (OR) operator provides default values when the left operand is falsy (null, undefined, empty string, 0, false, empty array/object):</p>
<pre><code class="language-html">&lt;!-- String defaults --&gt;
&lt;p&gt;Bio: @{user.bio || &quot;No bio available&quot;}&lt;/p&gt;

&lt;!-- Numeric defaults --&gt;
&lt;p&gt;Items per page: @{settings.pageSize || 20}&lt;/p&gt;

&lt;!-- Chaining multiple fallbacks --&gt;
&lt;h1&gt;@{custom_title || page.title || &quot;Untitled Page&quot;}&lt;/h1&gt;
</code></pre>
<a class="header" href="print.html#conditionals" id="conditionals"><h3>Conditionals</h3></a>
<a class="header" href="print.html#basic-ifelse" id="basic-ifelse"><h4>Basic If/Else</h4></a>
<pre><code class="language-html">@{if model.logged_in}
    &lt;p&gt;Welcome, @{model.username}!&lt;/p&gt;
@{else}
    &lt;p&gt;Please log in&lt;/p&gt;
@{fi}

&lt;!-- Inline conditional --&gt;
&lt;div class=&quot;@{if M.active}active@{else}inactive@{fi}&quot;&gt;
</code></pre>
<a class="header" href="print.html#comparison-operators" id="comparison-operators"><h4>Comparison Operators</h4></a>
<pre><code class="language-html">&lt;!-- Equality --&gt;
@{if user.role == &quot;admin&quot;}
    &lt;p&gt;Admin Dashboard&lt;/p&gt;
@{fi}

@{if status != &quot;deleted&quot;}
    &lt;p&gt;Active Item&lt;/p&gt;
@{fi}

&lt;!-- Strict equality (type-sensitive) --&gt;
@{if count === 0}
    &lt;p&gt;Exactly zero&lt;/p&gt;
@{fi}

&lt;!-- Numeric comparison --&gt;
@{if age &gt;= 18}
    &lt;p&gt;Adult content&lt;/p&gt;
@{fi}

@{if stock &gt; 0}
    &lt;button&gt;Add to Cart&lt;/button&gt;
@{else}
    &lt;span&gt;Out of Stock&lt;/span&gt;
@{fi}

@{if price &lt;= budget}
    &lt;span class=&quot;affordable&quot;&gt;Within Budget&lt;/span&gt;
@{fi}
</code></pre>
<p><strong>Supported Comparison Operators:</strong></p>
<ul>
<li><code>==</code> - Loose equality (type coercion)</li>
<li><code>!=</code> - Loose inequality</li>
<li><code>===</code> - Strict equality (no type coercion)</li>
<li><code>!==</code> - Strict inequality</li>
<li><code>&lt;</code> - Less than</li>
<li><code>&gt;</code> - Greater than</li>
<li><code>&lt;=</code> - Less than or equal</li>
<li><code>&gt;=</code> - Greater than or equal</li>
</ul>
<a class="header" href="print.html#logical-operators" id="logical-operators"><h4>Logical Operators</h4></a>
<p><strong>AND (<code>&amp;&amp;</code>)</strong> - Both conditions must be true:</p>
<pre><code class="language-html">@{if user.is_admin &amp;&amp; user.is_active}
    &lt;a href=&quot;/admin&quot;&gt;Admin Panel&lt;/a&gt;
@{fi}

@{if age &gt;= 18 &amp;&amp; has_id}
    &lt;p&gt;Access granted&lt;/p&gt;
@{fi}
</code></pre>
<p><strong>OR (<code>||</code>)</strong> - At least one condition must be true:</p>
<pre><code class="language-html">@{if user.is_admin || user.is_moderator}
    &lt;div class=&quot;staff-tools&quot;&gt;Staff Area&lt;/div&gt;
@{fi}

@{if is_weekend || is_holiday}
    &lt;span&gt;ğŸ‰ Special Hours&lt;/span&gt;
@{fi}
</code></pre>
<p><strong>Complex Conditions</strong> - Combine with parentheses:</p>
<pre><code class="language-html">@{if (age &gt;= 18 &amp;&amp; verified) || is_staff}
    &lt;p&gt;Access granted&lt;/p&gt;
@{fi}

@{if (is_member &amp;&amp; points &gt; 100) || is_vip}
    &lt;span class=&quot;badge&quot;&gt;Premium&lt;/span&gt;
@{fi}
</code></pre>
<a class="header" href="print.html#negation-with-" id="negation-with-"><h4>Negation with <code>!</code></h4></a>
<pre><code class="language-html">&lt;!-- NOT operator --&gt;
@{if !user.is_banned}
    &lt;p&gt;Welcome back!&lt;/p&gt;
@{fi}

@{if !is_empty}
    &lt;ul&gt;@{foreach item in items}...@{end}&lt;/ul&gt;
@{fi}

&lt;!-- Negating expressions --&gt;
@{if !(status == &quot;deleted&quot; || status == &quot;archived&quot;)}
    &lt;button&gt;Edit&lt;/button&gt;
@{fi}
</code></pre>
<a class="header" href="print.html#else-if-chains-with-elif" id="else-if-chains-with-elif"><h4>Else-If Chains with <code>@{elif}</code></h4></a>
<pre><code class="language-html">@{if score &gt; 90}
    &lt;span class=&quot;grade-a&quot;&gt;A - Excellent!&lt;/span&gt;
@{elif score &gt; 80}
    &lt;span class=&quot;grade-b&quot;&gt;B - Good Job&lt;/span&gt;
@{elif score &gt; 70}
    &lt;span class=&quot;grade-c&quot;&gt;C - Fair&lt;/span&gt;
@{elif score &gt; 60}
    &lt;span class=&quot;grade-d&quot;&gt;D - Needs Improvement&lt;/span&gt;
@{else}
    &lt;span class=&quot;grade-f&quot;&gt;F - Failed&lt;/span&gt;
@{fi}
</code></pre>
<p><strong>Multiple elif branches:</strong></p>
<pre><code class="language-html">@{if role == &quot;owner&quot;}
    &lt;p&gt;Full Access&lt;/p&gt;
@{elif role == &quot;admin&quot;}
    &lt;p&gt;Administrative Access&lt;/p&gt;
@{elif role == &quot;moderator&quot;}
    &lt;p&gt;Moderation Access&lt;/p&gt;
@{elif role == &quot;member&quot;}
    &lt;p&gt;Member Access&lt;/p&gt;
@{else}
    &lt;p&gt;Guest Access&lt;/p&gt;
@{fi}
</code></pre>
<a class="header" href="print.html#truthyfalsy-values" id="truthyfalsy-values"><h4>Truthy/Falsy Values</h4></a>
<p>Values are evaluated as truthy or falsy in conditionals:</p>
<p><strong>Falsy values:</strong></p>
<ul>
<li><code>false</code></li>
<li><code>null</code></li>
<li><code>0</code></li>
<li><code>&quot;&quot;</code> (empty string)</li>
<li><code>[]</code> (empty array)</li>
<li><code>{}</code> (empty object)</li>
</ul>
<p><strong>Truthy values:</strong></p>
<ul>
<li><code>true</code></li>
<li>Any non-zero number</li>
<li>Any non-empty string</li>
<li>Any non-empty array</li>
<li>Any non-empty object</li>
</ul>
<pre><code class="language-html">&lt;!-- Check if value exists and is truthy --&gt;
@{if user.email}
    &lt;p&gt;Email: @{user.email}&lt;/p&gt;
@{fi}

&lt;!-- Check if array has items --&gt;
@{if products}
    &lt;p&gt;@{products.length} products available&lt;/p&gt;
@{fi}
</code></pre>
<a class="header" href="print.html#loops" id="loops"><h3>Loops</h3></a>
<pre><code class="language-html">&lt;!-- Array iteration --&gt;
@{foreach item in model.items}
    &lt;li&gt;@{item.name} - @{item.price}&lt;/li&gt;
@{end}

&lt;!-- With index (using M alias) --&gt;
@{foreach item, index in M.items}
    &lt;li&gt;@{index}: @{item}&lt;/li&gt;
@{end}
</code></pre>
<a class="header" href="print.html#escaping" id="escaping"><h3>Escaping</h3></a>
<pre><code class="language-html">&lt;!-- Auto-escaped (safe by default) --&gt;
&lt;p&gt;@{model.user_input}&lt;/p&gt;

&lt;!-- Raw HTML (unescaped) --&gt;
&lt;div&gt;@{!M.html_content}&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#expressions--operators" id="expressions--operators"><h3>Expressions &amp; Operators</h3></a>
<p>The Total.js template engine supports rich expressions with multiple operator types, allowing for complex logic directly in templates.</p>
<a class="header" href="print.html#operator-reference" id="operator-reference"><h4>Operator Reference</h4></a>
<table><thead><tr><th> Category </th><th> Operators </th><th> Description </th><th> Example </th></tr></thead><tbody>
<tr><td> <strong>Comparison</strong> </td><td> <code>==</code>, <code>!=</code> </td><td> Loose equality/inequality (with type coercion) </td><td> <code>@{if age == &quot;18&quot;}</code> </td></tr>
<tr><td> </td><td> <code>===</code>, <code>!==</code> </td><td> Strict equality/inequality (no type coercion) </td><td> <code>@{if count === 0}</code> </td></tr>
<tr><td> </td><td> <code>&lt;</code>, <code>&gt;</code> </td><td> Less than, greater than </td><td> <code>@{if price &gt; 100}</code> </td></tr>
<tr><td> </td><td> <code>&lt;=</code>, <code>&gt;=</code> </td><td> Less/greater than or equal </td><td> <code>@{if stock &lt;= 5}</code> </td></tr>
<tr><td> <strong>Logical</strong> </td><td> <code>&amp;&amp;</code> </td><td> AND - both must be true </td><td> <code>@{if a &amp;&amp; b}</code> </td></tr>
<tr><td> </td><td> <code>\|\|</code> </td><td> OR - at least one must be true </td><td> <code>@{if a \|\| b}</code> </td></tr>
<tr><td> <strong>Unary</strong> </td><td> <code>!</code> </td><td> NOT - negates boolean </td><td> <code>@{if !is_deleted}</code> </td></tr>
<tr><td> </td><td> <code>-</code> </td><td> Negation - negates number </td><td> <code>@{-value}</code> </td></tr>
<tr><td> <strong>Arithmetic</strong> </td><td> <code>+</code> </td><td> Addition / String concatenation </td><td> <code>@{price + tax}</code> </td></tr>
<tr><td> </td><td> <code>-</code> </td><td> Subtraction </td><td> <code>@{total - discount}</code> </td></tr>
<tr><td> </td><td> <code>*</code> </td><td> Multiplication </td><td> <code>@{price * quantity}</code> </td></tr>
<tr><td> </td><td> <code>/</code> </td><td> Division </td><td> <code>@{total / count}</code> </td></tr>
<tr><td> </td><td> <code>%</code> </td><td> Modulo (remainder) </td><td> <code>@{index % 2}</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#operator-precedence" id="operator-precedence"><h4>Operator Precedence</h4></a>
<p>Operators are evaluated in the following order (highest to lowest precedence):</p>
<ol>
<li><strong>Parentheses</strong> <code>( )</code> - Grouping (evaluated first)</li>
<li><strong>Unary</strong> <code>!</code>, <code>-</code> - NOT, negation</li>
<li><strong>Multiplication/Division</strong> <code>*</code>, <code>/</code>, <code>%</code> - Arithmetic</li>
<li><strong>Addition/Subtraction</strong> <code>+</code>, <code>-</code> - Arithmetic</li>
<li><strong>Comparison</strong> <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> - Relational</li>
<li><strong>Equality</strong> <code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code> - Equality checks</li>
<li><strong>Logical AND</strong> <code>&amp;&amp;</code> - Boolean AND</li>
<li><strong>Logical OR</strong> <code>||</code> - Boolean OR (evaluated last)</li>
</ol>
<p><strong>Examples:</strong></p>
<pre><code class="language-html">&lt;!-- Precedence without parentheses --&gt;
@{if x + 5 &gt; 10 &amp;&amp; y &lt; 20}
    &lt;!-- Evaluates as: ((x + 5) &gt; 10) &amp;&amp; (y &lt; 20) --&gt;
@{fi}

&lt;!-- Using parentheses to control precedence --&gt;
@{if (a || b) &amp;&amp; c}
    &lt;!-- OR is evaluated before AND due to parentheses --&gt;
@{fi}
</code></pre>
<a class="header" href="print.html#arithmetic-operations" id="arithmetic-operations"><h4>Arithmetic Operations</h4></a>
<pre><code class="language-html">&lt;!-- Basic arithmetic --&gt;
&lt;p&gt;Subtotal: $@{price * quantity}&lt;/p&gt;
&lt;p&gt;Tax: $@{subtotal * 0.08}&lt;/p&gt;
&lt;p&gt;Total: $@{subtotal + (subtotal * 0.08)}&lt;/p&gt;

&lt;!-- Complex calculations --&gt;
&lt;p&gt;Price per unit: $@{total_price / item_count}&lt;/p&gt;
&lt;p&gt;Discount: @{(original_price - sale_price) / original_price * 100}%&lt;/p&gt;

&lt;!-- Modulo for alternating styles --&gt;
@{foreach item, index in items}
    &lt;tr class=&quot;@{if index % 2 == 0}even@{else}odd@{fi}&quot;&gt;
        &lt;td&gt;@{item.name}&lt;/td&gt;
    &lt;/tr&gt;
@{end}
</code></pre>
<a class="header" href="print.html#string-concatenation" id="string-concatenation"><h4>String Concatenation</h4></a>
<pre><code class="language-html">&lt;!-- Concatenate strings with + --&gt;
&lt;p&gt;@{first_name + &quot; &quot; + last_name}&lt;/p&gt;
&lt;p&gt;@{&quot;Hello, &quot; + user.name + &quot;!&quot;}&lt;/p&gt;

&lt;!-- Build URLs --&gt;
&lt;a href=&quot;@{&quot;/products/&quot; + product.id}&quot;&gt;View Product&lt;/a&gt;

&lt;!-- Combine with variables --&gt;
&lt;p&gt;@{greeting + &quot; &quot; + M.username}&lt;/p&gt;
</code></pre>
<a class="header" href="print.html#default-values-with-" id="default-values-with-"><h4>Default Values with <code>||</code></h4></a>
<p>The <code>||</code> operator provides fallback values when the left side is falsy:</p>
<pre><code class="language-html">&lt;!-- Simple default --&gt;
&lt;p&gt;@{user.bio || &quot;No bio provided&quot;}&lt;/p&gt;

&lt;!-- Nested properties with default --&gt;
&lt;p&gt;@{user.profile.avatar || &quot;/images/default-avatar.png&quot;}&lt;/p&gt;

&lt;!-- Numeric defaults --&gt;
&lt;p&gt;Items per page: @{settings.page_size || 20}&lt;/p&gt;

&lt;!-- Chain multiple defaults --&gt;
&lt;p&gt;@{custom_title || default_title || &quot;Untitled&quot;}&lt;/p&gt;
</code></pre>
<a class="header" href="print.html#complex-expressions" id="complex-expressions"><h4>Complex Expressions</h4></a>
<pre><code class="language-html">&lt;!-- Nested conditionals in expressions --&gt;
&lt;p class=&quot;@{if score &gt;= 90}excellent@{elif score &gt;= 70}good@{else}poor@{fi}&quot;&gt;
    Score: @{score}
&lt;/p&gt;

&lt;!-- Mathematical expressions in conditionals --&gt;
@{if (price * quantity) &gt; budget}
    &lt;span class=&quot;warning&quot;&gt;Over budget!&lt;/span&gt;
@{fi}

&lt;!-- Combining multiple operators --&gt;
@{if ((total - discount) * tax_rate) &lt; 100 &amp;&amp; is_member}
    &lt;span&gt;Free shipping!&lt;/span&gt;
@{fi}

&lt;!-- Expression in attribute values --&gt;
&lt;div data-score=&quot;@{points * 10}&quot; 
     class=&quot;level-@{if points &gt; 100}high@{else}low@{fi}&quot;&gt;
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#grouping-with-parentheses" id="grouping-with-parentheses"><h4>Grouping with Parentheses</h4></a>
<p>Use parentheses to control evaluation order and clarify complex expressions:</p>
<pre><code class="language-html">&lt;!-- Without parentheses (may be unclear) --&gt;
@{if a &amp;&amp; b || c &amp;&amp; d}  &lt;!-- Evaluates as: (a &amp;&amp; b) || (c &amp;&amp; d) --&gt;

&lt;!-- With parentheses (explicit) --&gt;
@{if (a &amp;&amp; b) || (c &amp;&amp; d)}  &lt;!-- Same result, but clearer intent --&gt;

&lt;!-- Change evaluation order --&gt;
@{if a &amp;&amp; (b || c) &amp;&amp; d}  &lt;!-- OR evaluated before outer ANDs --&gt;

&lt;!-- Arithmetic grouping --&gt;
&lt;p&gt;@{(price + shipping) * (1 + tax_rate)}&lt;/p&gt;
</code></pre>
<a class="header" href="print.html#practical-examples" id="practical-examples"><h4>Practical Examples</h4></a>
<p><strong>Shopping Cart Total:</strong></p>
<pre><code class="language-html">@{var subtotal = 0}
@{foreach item in cart.items}
    @{var item_total = item.price * item.quantity}
    @{subtotal = subtotal + item_total}
    &lt;tr&gt;
        &lt;td&gt;@{item.name}&lt;/td&gt;
        &lt;td&gt;@{item.quantity} Ã— $@{item.price}&lt;/td&gt;
        &lt;td&gt;$@{item_total}&lt;/td&gt;
    &lt;/tr&gt;
@{end}
&lt;tr class=&quot;total&quot;&gt;
    &lt;td colspan=&quot;2&quot;&gt;Subtotal:&lt;/td&gt;
    &lt;td&gt;$@{subtotal}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td colspan=&quot;2&quot;&gt;Tax (@{tax_rate * 100}%):&lt;/td&gt;
    &lt;td&gt;$@{subtotal * tax_rate}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;grand-total&quot;&gt;
    &lt;td colspan=&quot;2&quot;&gt;Total:&lt;/td&gt;
    &lt;td&gt;$@{subtotal + (subtotal * tax_rate)}&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
<p><strong>Pagination Logic:</strong></p>
<pre><code class="language-html">@{var total_pages = Math.ceil(total_items / items_per_page)}
@{var has_prev = current_page &gt; 1}
@{var has_next = current_page &lt; total_pages}

&lt;div class=&quot;pagination&quot;&gt;
    @{if has_prev}
        &lt;a href=&quot;?page=@{current_page - 1}&quot;&gt;Previous&lt;/a&gt;
    @{fi}
    
    &lt;span&gt;Page @{current_page} of @{total_pages}&lt;/span&gt;
    
    @{if has_next}
        &lt;a href=&quot;?page=@{current_page + 1}&quot;&gt;Next&lt;/a&gt;
    @{fi}
&lt;/div&gt;
</code></pre>
<p><strong>Access Control:</strong></p>
<pre><code class="language-html">@{var can_edit = (user.id === post.author_id) || user.is_admin}
@{var can_delete = user.is_admin || (user.is_moderator &amp;&amp; post.flagged)}
@{var can_publish = (user.role === &quot;editor&quot; || user.role === &quot;admin&quot;) &amp;&amp; !post.published}

@{if can_edit}
    &lt;button onclick=&quot;editPost()&quot;&gt;Edit&lt;/button&gt;
@{fi}

@{if can_delete}
    &lt;button onclick=&quot;deletePost()&quot; class=&quot;danger&quot;&gt;Delete&lt;/button&gt;
@{fi}

@{if can_publish}
    &lt;button onclick=&quot;publishPost()&quot; class=&quot;primary&quot;&gt;Publish&lt;/button&gt;
@{fi}
</code></pre>
<a class="header" href="print.html#data-access-in-templates" id="data-access-in-templates"><h3>Data Access in Templates</h3></a>
<a class="header" href="print.html#global-constants" id="global-constants"><h4>Global Constants</h4></a>
<p>These are directly accessible without any prefix:</p>
<pre><code class="language-html">@{url}          &lt;!-- Current request URL --&gt;
@{hostname}     &lt;!-- Server hostname --&gt;
@{root}         &lt;!-- Application root path (from config.default_root) --&gt;
@{index}        &lt;!-- Current loop index (inside foreach) --&gt;
@{csrf_token}   &lt;!-- CSRF token for forms --&gt;
</code></pre>
<a class="header" href="print.html#data-source-objects" id="data-source-objects"><h4>Data Source Objects</h4></a>
<p>These objects can be accessed entirely or via dot notation for properties:</p>
<pre><code class="language-html">&lt;!-- Configuration (entire object or properties) --&gt;
@{CONF}               &lt;!-- Entire config object --&gt;
@{CONF.app_name}      &lt;!-- Specific config value --&gt;
@{CONF.default_root}  &lt;!-- Deployment root path --&gt;

&lt;!-- Session (entire object or properties) --&gt;
@{session}            &lt;!-- Entire session object --&gt;
@{session.user_id}    &lt;!-- Specific session value --&gt;
@{session.cart}       &lt;!-- Session cart data --&gt;

&lt;!-- Flash Messages (stored in session, aliased for convenience) --&gt;
@{flash}              &lt;!-- All flash messages --&gt;
@{flash.error}        &lt;!-- Error flash message --&gt;
@{flash.success}      &lt;!-- Success flash message --&gt;
@{flash.info}         &lt;!-- Info flash message --&gt;
@{flash.custom_key}   &lt;!-- Custom flash message --&gt;

&lt;!-- Query parameters (entire object or properties) --&gt;
@{query}              &lt;!-- All query parameters --&gt;
@{query.page}         &lt;!-- Specific query parameter --&gt;
@{query.search}       &lt;!-- Search query parameter --&gt;

&lt;!-- User (entire object or properties) --&gt;
@{user}               &lt;!-- Entire user object --&gt;
@{user.name}          &lt;!-- User's name --&gt;
@{user.email}         &lt;!-- User's email --&gt;

&lt;!-- Context Repository (per-handler) --&gt;
@{repository}         &lt;!-- Entire repository object --&gt;
@{repository.key}     &lt;!-- Specific repository value --&gt;
@{R.key}              &lt;!-- Shorthand for repository.key --&gt;

&lt;!-- Global Repository (application-wide) --&gt;
@{APP.key}            &lt;!-- Global repository value --&gt;
@{MAIN.key}           &lt;!-- Alias for APP.key --&gt;

&lt;!-- Model/View Data (from ctx.view()) --&gt;
@{model}              &lt;!-- Entire model object --&gt;
@{model.key}          &lt;!-- Specific model value --&gt;
@{M}                  &lt;!-- Alias for entire model --&gt;
@{M.key}              &lt;!-- Alias for model.key --&gt;
</code></pre>
<a class="header" href="print.html#loop-variables" id="loop-variables"><h4>Loop Variables</h4></a>
<p>Within <code>@{foreach}</code> loops, the iterator variable is directly accessible:</p>
<pre><code class="language-html">@{foreach product in model.products}
    &lt;!-- 'product' is directly accessible here --&gt;
    &lt;h3&gt;@{product.name}&lt;/h3&gt;
    &lt;p&gt;Price: @{product.price}&lt;/p&gt;
    &lt;p&gt;Index: @{index}&lt;/p&gt;  &lt;!-- Loop index is available --&gt;
@{end}

&lt;!-- Looping over objects --&gt;
@{foreach key, value in CONF}
    &lt;p&gt;Config @{key}: @{value}&lt;/p&gt;
@{end}
</code></pre>
<a class="header" href="print.html#built-in-functions" id="built-in-functions"><h3>Built-in Functions</h3></a>
<pre><code class="language-html">&lt;!-- URL helpers --&gt;
@{url('/path')}         &lt;!-- Generate URL with root prefix --&gt;
@{css('/static/app.css')}  &lt;!-- CSS link tag --&gt;
@{js('/static/app.js')}    &lt;!-- Script tag --&gt;

&lt;!-- Data formatting --&gt;
@{json(data)}           &lt;!-- JSON stringify --&gt;
@{encode(text)}         &lt;!-- URL encode --&gt;
@{escape(html)}         &lt;!-- HTML escape --&gt;

&lt;!-- String manipulation --&gt;
@{upper(text)}          &lt;!-- Uppercase --&gt;
@{lower(text)}          &lt;!-- Lowercase --&gt;
@{trim(text)}           &lt;!-- Trim whitespace --&gt;
@{capitalize(text)}     &lt;!-- Capitalize first letter --&gt;

&lt;!-- Iteration helpers --&gt;
@{range(10)}            &lt;!-- Generate array [0,1,2,3,4,5,6,7,8,9] --&gt;
@{range(1, 11)}         &lt;!-- Generate array [1,2,3,4,5,6,7,8,9,10] --&gt;
@{range(0, 10, 2)}      &lt;!-- Generate array [0,2,4,6,8] with step --&gt;
</code></pre>
<a class="header" href="print.html#range-function-examples" id="range-function-examples"><h4>Range Function Examples</h4></a>
<p>The <code>range()</code> function generates numeric sequences for loops:</p>
<pre><code class="language-html">&lt;!-- Simple range: 0 to N-1 --&gt;
@{foreach num in range(5)}
    &lt;p&gt;Item @{num}&lt;/p&gt;  &lt;!-- Outputs: 0, 1, 2, 3, 4 --&gt;
@{end}

&lt;!-- Range with start and stop --&gt;
@{foreach page in range(1, 6)}
    &lt;a href=&quot;/page/@{page}&quot;&gt;Page @{page}&lt;/a&gt;  &lt;!-- Pages 1-5 --&gt;
@{end}

&lt;!-- Range with custom step --&gt;
@{foreach year in range(2020, 2030, 2)}
    &lt;option value=&quot;@{year}&quot;&gt;@{year}&lt;/option&gt;  &lt;!-- 2020, 2022, 2024, 2026, 2028 --&gt;
@{end}

&lt;!-- Practical example: pagination --&gt;
@{foreach page in range(1, model.totalPages + 1)}
    @{if page == model.currentPage}
        &lt;span class=&quot;active&quot;&gt;@{page}&lt;/span&gt;
    @{else}
        &lt;a href=&quot;?page=@{page}&quot;&gt;@{page}&lt;/a&gt;
    @{fi}
@{end}
</code></pre>
<a class="header" href="print.html#template-partials-and-includes" id="template-partials-and-includes"><h3>Template Partials and Includes</h3></a>
<p>Total.js templates support including other templates (partials) using the <code>@{view()}</code> function:</p>
<pre><code class="language-html">&lt;!-- Include a partial template --&gt;
@{view('partials/header')}

&lt;!-- Include with specific model data --&gt;
@{view('partials/user-card', model.currentUser)}

&lt;!-- Include in loops --&gt;
@{foreach user in model.users}
    @{view('partials/user-card', user)}
@{end}

&lt;!-- Nested partials (partials can include other partials) --&gt;
&lt;!-- In partials/sidebar.html: --&gt;
@{view('partials/user-info', model.user)}
@{view('partials/menu', model.menuItems)}
</code></pre>
<a class="header" href="print.html#partial-template-example" id="partial-template-example"><h4>Partial Template Example</h4></a>
<p>Create reusable components in <code>views/partials/</code>:</p>
<pre><code class="language-html">&lt;!-- views/partials/user-card.html --&gt;
&lt;div class=&quot;user-card&quot;&gt;
    &lt;img src=&quot;@{model.avatar}&quot; alt=&quot;@{model.name}&quot;&gt;
    &lt;h3&gt;@{model.name}&lt;/h3&gt;
    &lt;p&gt;@{model.email}&lt;/p&gt;
    @{if model.isAdmin}
        &lt;span class=&quot;badge&quot;&gt;Admin&lt;/span&gt;
    @{fi}
&lt;/div&gt;
</code></pre>
<p>Use it in your main templates:</p>
<pre><code class="language-html">&lt;!-- views/users/list.html --&gt;
&lt;div class=&quot;users-grid&quot;&gt;
    @{foreach user in model.users}
        @{view('partials/user-card', user)}
    @{end}
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#important-notes" id="important-notes"><h4>Important Notes</h4></a>
<ul>
<li>Partials have access to all global data (repository, session, etc.)</li>
<li>When passing model data, the partial receives only that data as its model</li>
<li>Partials are loaded relative to the views directory</li>
<li>Nested partials are supported (partials can include other partials)</li>
<li>Currently, array indexing in expressions (e.g., <code>model.users[0]</code>) is not supported in the view() function</li>
</ul>
<a class="header" href="print.html#layouts" id="layouts"><h2>Layouts</h2></a>
<a class="header" href="print.html#layout-system-overview" id="layout-system-overview"><h3>Layout System Overview</h3></a>
<p>RustF follows the Total.js pattern for layouts:</p>
<ul>
<li><strong>Default layout</strong>: Configured in <code>config.toml</code> as <code>views.default_layout</code> (default: <code>&quot;layouts/default&quot;</code>)</li>
<li><strong>Custom layout</strong>: Use <code>ctx.layout(&quot;path/to/layout&quot;)</code> in controller (requires <code>mut ctx</code>)</li>
<li><strong>No layout</strong>: Use <code>ctx.layout(&quot;&quot;)</code> with empty string</li>
<li><strong>Layout inheritance</strong>: Templates can specify their own layout with <code>@{layout('path')}</code></li>
</ul>
<a class="header" href="print.html#controller-side-layout-control" id="controller-side-layout-control"><h3>Controller-Side Layout Control</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

#[rustf::install]
impl PageController {
    // Uses default layout from config
    #[route(GET, &quot;/&quot;)]
    pub async fn index(ctx: Context) -&gt; Result&lt;Response&gt; {
        ctx.view(&quot;home/index&quot;, json!({&quot;title&quot;: &quot;Home&quot;}))
    }
    
    // Custom layout
    #[route(GET, &quot;/admin&quot;)]
    pub async fn admin(mut ctx: Context) -&gt; Result&lt;Response&gt; {
        ctx.layout(&quot;layouts/admin&quot;)  // Set custom layout
            .view(&quot;admin/dashboard&quot;, json!({&quot;user&quot;: &quot;Admin&quot;}))
    }
    
    // No layout (standalone page)
    #[route(GET, &quot;/api-doc&quot;)]
    pub async fn api_doc(mut ctx: Context) -&gt; Result&lt;Response&gt; {
        ctx.layout(&quot;&quot;)  // Empty string = no layout
            .view(&quot;docs/api&quot;, json!({&quot;version&quot;: &quot;1.0&quot;}))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#totaljs-layouts" id="totaljs-layouts"><h3>Total.js Layouts</h3></a>
<p>Define a layout (<code>views/layouts/default.html</code>):</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;@{if model.title}@{model.title} - @{fi}My App&lt;/title&gt;
    @{css('/static/css/main.css')}
&lt;/head&gt;
&lt;body&gt;
    &lt;nav&gt;
        &lt;a href=&quot;@{root}/&quot;&gt;Home&lt;/a&gt;
        &lt;a href=&quot;@{root}/about&quot;&gt;About&lt;/a&gt;
    &lt;/nav&gt;
    
    &lt;main&gt;
        @{body}  &lt;!-- Child template content renders here --&gt;
    &lt;/main&gt;
    
    @{js('/static/js/app.js')}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Use in child template (<code>views/home/index.html</code>):</p>
<pre><code class="language-html">@{layout('layouts/default')}  &lt;!-- Optional: Override controller layout --&gt;

&lt;h1&gt;@{model.title}&lt;/h1&gt;
&lt;p&gt;@{M.message}&lt;/p&gt;

@{foreach feature in model.features}
    &lt;div&gt;@{feature}&lt;/div&gt;
@{end}
</code></pre>
<a class="header" href="print.html#sections" id="sections"><h2>Sections</h2></a>
<a class="header" href="print.html#section-system-overview" id="section-system-overview"><h3>Section System Overview</h3></a>
<p>Sections allow child templates to define content blocks that parent layouts can render in specific locations. This is the standard pattern for customizing different areas of a layout (head content, sidebar, footer, etc.) from child views.</p>
<p><strong>Key Concepts</strong>:</p>
<ul>
<li><strong>Child defines sections</strong>: Use <code>@{section name}...@{end}</code> in child templates</li>
<li><strong>Parent renders sections</strong>: Use <code>@{section('name')}</code> in layout templates</li>
<li><strong>Optional sections</strong>: Missing sections render as empty (no errors)</li>
<li><strong>Multiple sections</strong>: Child can define multiple sections for different layout areas</li>
</ul>
<a class="header" href="print.html#basic-section-usage" id="basic-section-usage"><h3>Basic Section Usage</h3></a>
<p><strong>Layout with Section Placeholders</strong> (<code>views/layouts/main.html</code>):</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;@{M.title}&lt;/title&gt;
    
    &lt;!-- Child can inject custom styles here --&gt;
    @{section('styles')}
    
    &lt;!-- Child can add meta tags, scripts, etc. --&gt;
    @{section('head')}
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;
        &lt;!-- Child can customize header --&gt;
        @{section('header')}
    &lt;/header&gt;
    
    &lt;main&gt;
        @{body}  &lt;!-- Main content --&gt;
    &lt;/main&gt;
    
    &lt;aside&gt;
        &lt;!-- Child can provide sidebar content --&gt;
        @{section('sidebar')}
    &lt;/aside&gt;
    
    &lt;footer&gt;
        &lt;!-- Child can customize footer --&gt;
        @{section('footer')}
    &lt;/footer&gt;
    
    &lt;!-- Child can inject page-specific scripts --&gt;
    @{section('scripts')}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Child Template Defining Sections</strong> (<code>views/products/detail.html</code>):</p>
<pre><code class="language-html">@{section styles}
&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/products.css&quot;&gt;
&lt;style&gt;
    .product-gallery { display: grid; }
&lt;/style&gt;
@{end}

@{section head}
&lt;meta property=&quot;og:title&quot; content=&quot;@{M.product.name}&quot;&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;@{M.product.image}&quot;&gt;
@{end}

@{section header}
&lt;h1&gt;@{M.product.name}&lt;/h1&gt;
&lt;nav class=&quot;breadcrumb&quot;&gt;
    &lt;a href=&quot;@{root}/&quot;&gt;Home&lt;/a&gt; &amp;gt;
    &lt;a href=&quot;@{root}/products&quot;&gt;Products&lt;/a&gt; &amp;gt;
    @{M.product.category}
&lt;/nav&gt;
@{end}

&lt;!-- Main content (rendered in @{body}) --&gt;
&lt;div class=&quot;product-detail&quot;&gt;
    &lt;img src=&quot;@{M.product.image}&quot; alt=&quot;@{M.product.name}&quot;&gt;
    &lt;div class=&quot;product-info&quot;&gt;
        &lt;p class=&quot;price&quot;&gt;$@{M.product.price}&lt;/p&gt;
        &lt;p&gt;@{M.product.description}&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;

@{section sidebar}
&lt;h3&gt;Related Products&lt;/h3&gt;
@{foreach item in M.related}
    &lt;div class=&quot;related-item&quot;&gt;
        &lt;a href=&quot;/products/@{item.id}&quot;&gt;@{item.name}&lt;/a&gt;
    &lt;/div&gt;
@{end}
@{end}

@{section scripts}
&lt;script src=&quot;/js/product-gallery.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    initProductGallery('@{M.product.id}');
&lt;/script&gt;
@{end}
</code></pre>
<a class="header" href="print.html#section-features" id="section-features"><h3>Section Features</h3></a>
<p><strong>1. Optional Sections</strong> - No errors if section not defined:</p>
<pre><code class="language-html">&lt;!-- Layout --&gt;
&lt;div class=&quot;notifications&quot;&gt;
    @{section('alerts')}  &lt;!-- Empty if child doesn't define it --&gt;
&lt;/div&gt;

&lt;!-- Child - can choose to define or skip --&gt;
@{section alerts}
&lt;div class=&quot;alert&quot;&gt;Special offer!&lt;/div&gt;
@{end}
</code></pre>
<p><strong>2. Conditional Sections</strong>:</p>
<pre><code class="language-html">&lt;!-- Child template --&gt;
@{if M.show_newsletter}
    @{section footer}
    &lt;div class=&quot;newsletter-signup&quot;&gt;
        &lt;form&gt;...&lt;/form&gt;
    &lt;/div&gt;
    @{end}
@{fi}
</code></pre>
<p><strong>3. Sections with Dynamic Content</strong>:</p>
<pre><code class="language-html">&lt;!-- Child template --&gt;
@{section sidebar}
    &lt;h3&gt;Categories&lt;/h3&gt;
    @{foreach cat in M.categories}
        &lt;a href=&quot;/category/@{cat.slug}&quot;&gt;@{cat.name}&lt;/a&gt;
    @{end}
    
    &lt;h3&gt;Tags&lt;/h3&gt;
    @{foreach tag in M.tags}
        &lt;span class=&quot;tag&quot;&gt;@{tag}&lt;/span&gt;
    @{end}
@{end}
</code></pre>
<p><strong>4. Multiple Sections in One Template</strong>:</p>
<pre><code class="language-html">&lt;!-- A single child view can define many sections --&gt;
@{section meta}...@{end}
@{section styles}...@{end}
@{section header}...@{end}

&lt;!-- Main content here --&gt;

@{section sidebar}...@{end}
@{section footer}...@{end}
@{section scripts}...@{end}
</code></pre>
<a class="header" href="print.html#common-section-patterns" id="common-section-patterns"><h3>Common Section Patterns</h3></a>
<p><strong>Meta Tags &amp; SEO</strong>:</p>
<pre><code class="language-html">&lt;!-- Layout head --&gt;
@{section('meta')}

&lt;!-- Child defines SEO metadata --&gt;
@{section meta}
&lt;meta name=&quot;description&quot; content=&quot;@{M.description}&quot;&gt;
&lt;meta name=&quot;keywords&quot; content=&quot;@{M.keywords}&quot;&gt;
&lt;link rel=&quot;canonical&quot; href=&quot;@{M.canonical_url}&quot;&gt;
@{end}
</code></pre>
<p><strong>Page-Specific Styles</strong>:</p>
<pre><code class="language-html">&lt;!-- Layout head --&gt;
@{section('page_styles')}

&lt;!-- Child adds custom CSS --&gt;
@{section page_styles}
&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/dashboard.css&quot;&gt;
&lt;style&gt;
    .dashboard-widget { margin: 1rem; }
&lt;/style&gt;
@{end}
</code></pre>
<p><strong>JavaScript Initialization</strong>:</p>
<pre><code class="language-html">&lt;!-- Layout before &lt;/body&gt; --&gt;
@{section('page_scripts')}

&lt;!-- Child adds page logic --&gt;
@{section page_scripts}
&lt;script src=&quot;/js/chart.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    initCharts(@{json(M.chart_data)});
&lt;/script&gt;
@{end}
</code></pre>
<p><strong>Breadcrumbs</strong>:</p>
<pre><code class="language-html">&lt;!-- Layout --&gt;
&lt;nav class=&quot;breadcrumbs&quot;&gt;
    &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;
    @{section('breadcrumbs')}
&lt;/nav&gt;

&lt;!-- Child extends breadcrumb trail --&gt;
@{section breadcrumbs}
&amp;gt; &lt;a href=&quot;/products&quot;&gt;Products&lt;/a&gt;
&amp;gt; @{M.category}
@{end}
</code></pre>
<a class="header" href="print.html#section-vs-head-special-placeholder" id="section-vs-head-special-placeholder"><h3>Section vs @{head} Special Placeholder</h3></a>
<p>RustF provides a special <code>@{head}</code> placeholder that automatically renders content from a section named &quot;head&quot;:</p>
<pre><code class="language-html">&lt;!-- These are equivalent: --&gt;
@{section('head')}
@{head}
</code></pre>
<p>The <code>@{head}</code> placeholder is a convenience feature inherited from Total.js for adding content to the HTML <code>&lt;head&gt;</code> section. For all other sections, use the explicit <code>@{section('name')}</code> syntax.</p>
<a class="header" href="print.html#best-practices-2" id="best-practices-2"><h3>Best Practices</h3></a>
<ol>
<li>
<p><strong>Name sections clearly</strong>: Use descriptive names like <code>page_styles</code>, <code>sidebar_menu</code>, <code>footer_links</code></p>
</li>
<li>
<p><strong>Document expected sections</strong>: Comment layout templates to show which sections are available:</p>
<pre><code class="language-html">&lt;!-- Available sections:
     - styles: Custom CSS for this page
     - header: Page-specific header content
     - sidebar: Sidebar widgets
     - scripts: Page-specific JavaScript
--&gt;
</code></pre>
</li>
<li>
<p><strong>Keep sections focused</strong>: Each section should have a single, clear purpose</p>
</li>
<li>
<p><strong>Make sections optional</strong>: Don't require every child to define every section</p>
</li>
<li>
<p><strong>Use consistent naming</strong>: Establish naming conventions across your app:</p>
<ul>
<li><code>page_styles</code> / <code>page_scripts</code> for page-specific assets</li>
<li><code>meta</code> for SEO metadata</li>
<li><code>header</code> / <code>footer</code> / <code>sidebar</code> for layout areas</li>
</ul>
</li>
</ol>
<a class="header" href="print.html#example-complete-blog-post-template" id="example-complete-blog-post-template"><h3>Example: Complete Blog Post Template</h3></a>
<p><strong>Layout</strong> (<code>views/layouts/blog.html</code>):</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;@{M.title} - My Blog&lt;/title&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    @{section('meta')}
    @{css('/css/blog.css')}
    @{section('styles')}
&lt;/head&gt;
&lt;body&gt;
    &lt;header class=&quot;site-header&quot;&gt;
        &lt;h1&gt;My Blog&lt;/h1&gt;
        @{section('breadcrumbs')}
    &lt;/header&gt;
    
    &lt;div class=&quot;content-wrapper&quot;&gt;
        &lt;article&gt;
            @{section('article_header')}
            @{body}
        &lt;/article&gt;
        
        &lt;aside class=&quot;sidebar&quot;&gt;
            @{section('sidebar')}
        &lt;/aside&gt;
    &lt;/div&gt;
    
    &lt;footer&gt;
        @{section('comments')}
        &lt;p&gt;&amp;copy; 2025 My Blog&lt;/p&gt;
    &lt;/footer&gt;
    
    @{js('/js/blog.js')}
    @{section('scripts')}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Blog Post</strong> (<code>views/blog/post.html</code>):</p>
<pre><code class="language-html">@{section meta}
&lt;meta name=&quot;description&quot; content=&quot;@{M.excerpt}&quot;&gt;
&lt;meta name=&quot;author&quot; content=&quot;@{M.author}&quot;&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;@{M.featured_image}&quot;&gt;
@{end}

@{section breadcrumbs}
&lt;a href=&quot;/blog&quot;&gt;Blog&lt;/a&gt; &amp;gt;
&lt;a href=&quot;/blog/@{M.category}&quot;&gt;@{M.category_name}&lt;/a&gt;
@{end}

@{section article_header}
&lt;h1&gt;@{M.title}&lt;/h1&gt;
&lt;div class=&quot;meta&quot;&gt;
    By @{M.author} on @{M.published_date}
&lt;/div&gt;
&lt;img src=&quot;@{M.featured_image}&quot; alt=&quot;@{M.title}&quot;&gt;
@{end}

&lt;!-- Main article content --&gt;
&lt;div class=&quot;article-body&quot;&gt;
    @{M.content}
&lt;/div&gt;

@{section sidebar}
&lt;h3&gt;About the Author&lt;/h3&gt;
&lt;p&gt;@{M.author_bio}&lt;/p&gt;

&lt;h3&gt;Related Posts&lt;/h3&gt;
@{foreach post in M.related_posts}
    &lt;a href=&quot;/blog/@{post.slug}&quot;&gt;@{post.title}&lt;/a&gt;
@{end}
@{end}

@{section comments}
&lt;div class=&quot;comments&quot;&gt;
    &lt;h3&gt;Comments (@{M.comment_count})&lt;/h3&gt;
    @{foreach comment in M.comments}
        &lt;div class=&quot;comment&quot;&gt;
            &lt;strong&gt;@{comment.author}&lt;/strong&gt;
            &lt;p&gt;@{comment.text}&lt;/p&gt;
        &lt;/div&gt;
    @{end}
&lt;/div&gt;
@{end}

@{section scripts}
&lt;script src=&quot;/js/syntax-highlighter.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;highlightCode();&lt;/script&gt;
@{end}
</code></pre>
<a class="header" href="print.html#storage-options" id="storage-options"><h2>Storage Options</h2></a>
<a class="header" href="print.html#filesystem-development" id="filesystem-development"><h3>Filesystem (Development)</h3></a>
<ul>
<li>Templates loaded from disk at runtime</li>
<li>Supports hot-reloading</li>
<li>Easy to modify during development</li>
<li>Configure with: <code>storage = &quot;filesystem&quot;</code></li>
</ul>
<a class="header" href="print.html#embedded-production" id="embedded-production"><h3>Embedded (Production)</h3></a>
<ul>
<li>Templates compiled into binary</li>
<li>Faster startup, no file I/O</li>
<li>Requires <code>embedded-views</code> feature</li>
<li>Configure with: <code>storage = &quot;embedded&quot;</code></li>
</ul>
<a class="header" href="print.html#advanced-features-1" id="advanced-features-1"><h2>Advanced Features</h2></a>
<a class="header" href="print.html#custom-template-functions" id="custom-template-functions"><h3>Custom Template Functions</h3></a>
<p>Register custom functions for Total.js templates:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::views::TotalJsEngine;

// In your app setup
let mut engine = TotalJsEngine::new(&quot;views&quot;);
engine.register_function(&quot;format_price&quot;, |args| {
    if let Some(Value::Number(n)) = args.first() {
        Value::String(format!(&quot;${:.2}&quot;, n.as_f64().unwrap_or(0.0)))
    } else {
        Value::String(&quot;$0.00&quot;.to_string())
    }
});

// Use in template
// @{format_price(19.99)} =&gt; &quot;$19.99&quot;
#}</code></pre></pre>
<a class="header" href="print.html#csrf-protection" id="csrf-protection"><h3>CSRF Protection</h3></a>
<p>Automatic CSRF token injection:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// In controller - generate token and render view
ctx.generate_csrf()?;
ctx.view(&quot;form&quot;, data)
#}</code></pre></pre>
<pre><code class="language-html">&lt;!-- In template - Total.js --&gt;
&lt;form method=&quot;POST&quot;&gt;
    @{csrf_field}  &lt;!-- Renders hidden input with token --&gt;
    &lt;!-- or manually --&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;@{csrf_token}&quot;&gt;
&lt;/form&gt;
</code></pre>
<a class="header" href="print.html#repository-system" id="repository-system"><h3>Repository System</h3></a>
<p>RustF provides two repository systems for sharing data between controllers and views:</p>
<a class="header" href="print.html#context-repository-per-request" id="context-repository-per-request"><h4>Context Repository (Per-Request)</h4></a>
<p>The context repository is request-scoped data that controllers can set to share with templates. It's useful for page-specific settings, user permissions, or any data that's specific to the current request.</p>
<p><strong>Setting in Controllers:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Requires mut ctx for repository operations
async fn dashboard(mut ctx: Context) -&gt; Result&lt;Response&gt; {
    // Set various types of repository data
    ctx.repository_set(&quot;current_section&quot;, &quot;analytics&quot;)
       .repository_set(&quot;sidebar_expanded&quot;, true)
       .repository_set(&quot;user_role&quot;, &quot;admin&quot;)
       .repository_set(&quot;available_actions&quot;, json!([&quot;view&quot;, &quot;edit&quot;, &quot;delete&quot;]))
       .repository_set(&quot;theme&quot;, json!({
           &quot;primary_color&quot;: &quot;#007bff&quot;,
           &quot;mode&quot;: &quot;dark&quot;
       }));
    
    // Repository data is automatically available in templates
    ctx.view(&quot;dashboard/index&quot;, json!({
        &quot;title&quot;: &quot;Dashboard&quot;,
        &quot;stats&quot;: get_stats().await?
    }))
}
#}</code></pre></pre>
<p><strong>Accessing in Templates:</strong></p>
<pre><code class="language-html">&lt;!-- Using R. prefix (recommended, shorter) --&gt;
@{if R.user_role == 'admin'}
    &lt;div class=&quot;admin-panel&quot;&gt;
        @{foreach action in R.available_actions}
            &lt;button&gt;@{action}&lt;/button&gt;
        @{end}
    &lt;/div&gt;
@{fi}

&lt;!-- Using repository. prefix (alternative) --&gt;
&lt;div class=&quot;sidebar @{if repository.sidebar_expanded}expanded@{fi}&quot;&gt;
    Current Section: @{repository.current_section}
&lt;/div&gt;

&lt;!-- Accessing nested data --&gt;
&lt;style&gt;
    :root {
        --primary-color: @{R.theme.primary_color};
    }
    body.@{R.theme.mode} {
        /* Dark mode styles */
    }
&lt;/style&gt;
</code></pre>
<a class="header" href="print.html#global-repository-appmain" id="global-repository-appmain"><h4>Global Repository (APP/MAIN)</h4></a>
<p>The global repository is application-wide data shared across all requests. It's typically set during application initialization and contains site-wide settings, application metadata, or shared constants.</p>
<p><strong>Setting During Application Setup:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// In your main.rs or app initialization
use rustf::views::TotalJsEngine;

let engine = TotalJsEngine::new(&quot;views&quot;);
engine.set_global_repository(json!({
    &quot;site_name&quot;: &quot;My Application&quot;,
    &quot;version&quot;: &quot;2.1.0&quot;,
    &quot;copyright&quot;: &quot;Â© 2024 MyCompany&quot;,
    &quot;contact_email&quot;: &quot;support@example.com&quot;,
    &quot;features&quot;: {
        &quot;comments&quot;: true,
        &quot;notifications&quot;: true,
        &quot;api_v2&quot;: false
    },
    &quot;social_links&quot;: {
        &quot;twitter&quot;: &quot;https://twitter.com/myapp&quot;,
        &quot;github&quot;: &quot;https://github.com/myapp&quot;
    }
}));
#}</code></pre></pre>
<p><strong>Accessing in Templates:</strong></p>
<pre><code class="language-html">&lt;!-- Using APP. prefix --&gt;
&lt;footer&gt;
    &lt;p&gt;@{APP.copyright}&lt;/p&gt;
    &lt;p&gt;Contact: &lt;a href=&quot;mailto:@{APP.contact_email}&quot;&gt;@{APP.contact_email}&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;Version @{APP.version}&lt;/p&gt;
&lt;/footer&gt;

&lt;!-- Using MAIN. prefix (alias for APP) --&gt;
&lt;title&gt;@{title} - @{MAIN.site_name}&lt;/title&gt;

&lt;!-- Checking features --&gt;
@{if APP.features.comments}
    &lt;div class=&quot;comments-section&quot;&gt;
        &lt;!-- Comments enabled --&gt;
    &lt;/div&gt;
@{fi}

&lt;!-- Social links --&gt;
&lt;div class=&quot;social&quot;&gt;
    @{if APP.social_links.twitter}
        &lt;a href=&quot;@{APP.social_links.twitter}&quot;&gt;Twitter&lt;/a&gt;
    @{fi}
    @{if APP.social_links.github}
        &lt;a href=&quot;@{APP.social_links.github}&quot;&gt;GitHub&lt;/a&gt;
    @{fi}
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#repository-vs-data-whats-the-difference" id="repository-vs-data-whats-the-difference"><h4>Repository vs Data: What's the Difference?</h4></a>
<p><strong>Repository Data (<code>R.</code> or <code>repository.</code>)</strong></p>
<ul>
<li>Available to all views called within the same handler function</li>
<li>Set using <code>ctx.repository_set()</code> before calling views</li>
<li>Ideal for shared UI elements, user info, theme settings</li>
<li>Lives for the duration of the handler function execution</li>
</ul>
<p><strong>View Data (Model)</strong></p>
<ul>
<li>Specific to each individual view call</li>
<li>Passed via <code>ctx.view(template, data)</code></li>
<li>Accessed via <code>@{model.key}</code> or <code>@{M.key}</code> prefix</li>
<li>For page-specific content</li>
<li>Only available in that specific view call</li>
<li>Preferabily used for data flowing from db to form or vis versa</li>
</ul>
<p><strong>Example showing both:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn product_page(mut ctx: Context) -&gt; Result&lt;Response&gt; {
    // Repository: Available to all views called in this handler
    ctx.repository_set(&quot;nav_items&quot;, get_navigation())
       .repository_set(&quot;user&quot;, get_current_user())
       .repository_set(&quot;cart_count&quot;, get_cart_count());
    
    // Could render multiple views, all would have repository access
    if should_show_banner() {
        // This view has access to repository data
        let banner_html = ctx.render_partial(&quot;/partials/banner&quot;, json!({}))?;
    }
    
    // View data: Specific to this view call
    let data = json!({
        &quot;product&quot;: get_product(id),
        &quot;reviews&quot;: get_reviews(id),
        &quot;related&quot;: get_related_products(id)
    });
    
    // Main view also has access to repository data
    ctx.view(&quot;/products/show&quot;, data)
}
#}</code></pre></pre>
<pre><code class="language-html">&lt;!-- Repository data accessible in the template --&gt;
&lt;nav&gt;
    @{foreach item in R.nav_items}
        &lt;a href=&quot;@{item.url}&quot;&gt;@{item.title}&lt;/a&gt;
    @{end}
    &lt;span class=&quot;cart&quot;&gt;Cart (@{R.cart_count})&lt;/span&gt;
&lt;/nav&gt;

&lt;!-- View data (Model) specific to this template --&gt;
&lt;h1&gt;@{model.product.name}&lt;/h1&gt;
&lt;p&gt;@{M.product.description}&lt;/p&gt;
@{foreach review in model.reviews}
    &lt;div class=&quot;review&quot;&gt;@{review.text}&lt;/div&gt;
@{end}
</code></pre>
<a class="header" href="print.html#repository-best-practices" id="repository-best-practices"><h4>Repository Best Practices</h4></a>
<ol>
<li>
<p><strong>Use Context Repository for:</strong></p>
<ul>
<li>Data needed by multiple views within the same handler</li>
<li>User information for the current request</li>
<li>UI state for the current handler (theme, layout settings)</li>
<li>Temporary computed values used across view calls</li>
<li>Avoiding data duplication when rendering multiple views</li>
</ul>
</li>
<li>
<p><strong>Use Global Repository (APP/MAIN) for:</strong></p>
<ul>
<li>Application metadata (name, version, copyright)</li>
<li>Site-wide configuration (features, limits)</li>
<li>Constants needed across the entire application</li>
<li>External service URLs and API keys (non-sensitive)</li>
<li>Data accessible throughout the application, not just in views</li>
</ul>
</li>
<li>
<p><strong>Naming Conventions:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Clear, semantic names
ctx.repository_set(&quot;user_permissions&quot;, permissions);
ctx.repository_set(&quot;page_metadata&quot;, metadata);

// âŒ Bad: Generic or unclear names
ctx.repository_set(&quot;data&quot;, something);
ctx.repository_set(&quot;x&quot;, value);
#}</code></pre></pre>
</li>
<li>
<p><strong>Performance Considerations:</strong></p>
<ul>
<li>Context repository exists only during handler execution (keep it reasonable)</li>
<li>Global repository is shared application-wide (can hold more persistent data)</li>
<li>Context repository is cleared when handler returns</li>
<li>Global repository persists for the application's lifetime</li>
</ul>
</li>
<li>
<p><strong>Common Patterns:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Pattern 1: Set common data at the start of a handler
async fn my_handler(mut ctx: Context) -&gt; Result&lt;Response&gt; {
    // Set repository data first
    ctx.repository_set(&quot;user&quot;, get_current_user(&amp;ctx)?);
    ctx.repository_set(&quot;notifications&quot;, get_notifications(&amp;ctx)?);
    
    // Then render view(s) that need this data
    ctx.view(&quot;/my_template&quot;, specific_data)
}

// Pattern 2: Use repository for feature flags
ctx.repository_set(&quot;features&quot;, json!({
    &quot;new_editor&quot;: is_feature_enabled(&quot;new_editor&quot;),
    &quot;beta_api&quot;: is_feature_enabled(&quot;beta_api&quot;)
}));

// Pattern 3: Breadcrumb builder
ctx.repository_set(&quot;breadcrumbs&quot;, json!([
    {&quot;label&quot;: &quot;Home&quot;, &quot;url&quot;: &quot;/&quot;},
    {&quot;label&quot;: &quot;Products&quot;, &quot;url&quot;: &quot;/products&quot;},
    {&quot;label&quot;: product.name, &quot;url&quot;: null}  // Current page
]));
#}</code></pre></pre>
</li>
</ol>
<a class="header" href="print.html#flash-messages" id="flash-messages"><h3>Flash Messages</h3></a>
<p>Flash messages are one-time messages that survive redirects but are automatically cleared when a view is rendered. They provide a clean way to show user feedback across page redirections.</p>
<a class="header" href="print.html#setting-flash-messages-in-controllers" id="setting-flash-messages-in-controllers"><h4>Setting Flash Messages in Controllers</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Standard convenience methods
ctx.flash_success(&quot;User created successfully!&quot;);
ctx.flash_error(&quot;Invalid credentials&quot;);
ctx.flash_info(&quot;Please check your email&quot;);

// Generic flash setter for any key and serializable value
ctx.flash(&quot;warning_msg&quot;, &quot;This is a warning&quot;)?;
ctx.flash(&quot;user_level&quot;, 42)?;
ctx.flash(&quot;notification&quot;, json!({
    &quot;text&quot;: &quot;You have new messages&quot;,
    &quot;count&quot;: 5
}))?;
ctx.flash(&quot;recent_actions&quot;, vec![&quot;Logged in&quot;, &quot;Updated profile&quot;])?;

// Manual flash management
ctx.flash_clear();                    // Clear all flash messages
ctx.flash_clear_key(&quot;error_msg&quot;);     // Clear specific flash message

// Typical usage pattern
if validation_failed {
    ctx.flash_error(&quot;Please correct the errors below&quot;);
    return ctx.redirect(&quot;/form&quot;);
}

ctx.flash_success(&quot;Form submitted successfully!&quot;);
ctx.redirect(&quot;/dashboard&quot;)
#}</code></pre></pre>
<a class="header" href="print.html#accessing-flash-messages-in-templates" id="accessing-flash-messages-in-templates"><h4>Accessing Flash Messages in Templates</h4></a>
<p>Flash messages are stored in the session but are aliased for convenience, so you can access them directly using <code>@{flash.xxx}</code> instead of <code>@{session.flash.xxx}</code>:</p>
<pre><code class="language-html">&lt;!-- Standard flash messages - Total.js --&gt;
@{if flash.success_msg}
    &lt;div class=&quot;alert alert-success&quot;&gt;@{flash.success_msg}&lt;/div&gt;
@{fi}

@{if flash.error_msg}
    &lt;div class=&quot;alert alert-error&quot;&gt;@{flash.error_msg}&lt;/div&gt;
@{fi}

@{if flash.info_msg}
    &lt;div class=&quot;alert alert-info&quot;&gt;@{flash.info_msg}&lt;/div&gt;
@{fi}

&lt;!-- Custom flash messages --&gt;
@{if flash.warning_msg}
    &lt;div class=&quot;alert alert-warning&quot;&gt;@{flash.warning_msg}&lt;/div&gt;
@{fi}

&lt;!-- Complex flash data --&gt;
@{if flash.notification}
    &lt;div class=&quot;notification&quot;&gt;
        @{flash.notification.text}
        @{if flash.notification.count}
            &lt;span class=&quot;badge&quot;&gt;@{flash.notification.count}&lt;/span&gt;
        @{fi}
    &lt;/div&gt;
@{fi}

&lt;!-- Array flash data --&gt;
@{if flash.recent_actions}
    &lt;div class=&quot;recent-actions&quot;&gt;
        &lt;h4&gt;Recent Actions:&lt;/h4&gt;
        &lt;ul&gt;
        @{foreach action in flash.recent_actions}
            &lt;li&gt;@{action}&lt;/li&gt;
        @{end}
        &lt;/ul&gt;
    &lt;/div&gt;
@{fi}

&lt;!-- Number flash data --&gt;
@{if flash.user_level}
    &lt;div class=&quot;user-level&quot;&gt;Level: @{flash.user_level}&lt;/div&gt;
@{fi}
</code></pre>
<a class="header" href="print.html#flash-message-lifecycle" id="flash-message-lifecycle"><h4>Flash Message Lifecycle</h4></a>
<ul>
<li><strong>Set in controller</strong>: Flash messages are stored in the session</li>
<li><strong>Survive redirects</strong>: Messages persist through HTTP redirects</li>
<li><strong>Auto-cleared on view render</strong>: Messages are automatically removed when any view is rendered</li>
<li><strong>Manual clearing</strong>: Use <code>flash_clear()</code> or <code>flash_clear_key()</code> for explicit control</li>
</ul>
<a class="header" href="print.html#best-practices-3" id="best-practices-3"><h4>Best Practices</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Use specific flash keys for different message types
ctx.flash(&quot;validation_error&quot;, &quot;Email is required&quot;)?;
ctx.flash(&quot;success&quot;, &quot;Account created&quot;)?;
ctx.flash(&quot;warning&quot;, &quot;Trial period expires soon&quot;)?;

// âœ… Good: Clear flash before setting new messages in error scenarios
if let Err(e) = process_data() {
    ctx.flash_clear(); // Clear any existing flash
    ctx.flash_error(&amp;format!(&quot;Processing failed: {}&quot;, e));
    return ctx.redirect(&quot;/retry&quot;);
}

// âœ… Good: Use structured data for complex notifications
ctx.flash(&quot;notification&quot;, json!({
    &quot;type&quot;: &quot;info&quot;,
    &quot;title&quot;: &quot;System Update&quot;,
    &quot;message&quot;: &quot;Maintenance scheduled for tonight&quot;,
    &quot;actions&quot;: [{&quot;text&quot;: &quot;Learn More&quot;, &quot;url&quot;: &quot;/maintenance&quot;}]
}))?;

// âœ… Good: Selective clearing for fine-grained control
ctx.flash_clear_key(&quot;error_msg&quot;); // Keep other flash messages
ctx.flash_success(&quot;Operation completed!&quot;);
#}</code></pre></pre>
<a class="header" href="print.html#static-asset-helpers" id="static-asset-helpers"><h3>Static Asset Helpers</h3></a>
<pre><code class="language-html">&lt;!-- Total.js built-in helpers --&gt;
@{css('/static/css/app.css')}
&lt;!-- Renders: &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/app.css&quot;&gt; --&gt;

@{js('/static/js/app.js')}
&lt;!-- Renders: &lt;script src=&quot;/static/js/app.js&quot;&gt;&lt;/script&gt; --&gt;

&lt;!-- With root path --&gt;
@{css(root + '/static/css/app.css')}
&lt;!-- Renders: &lt;link rel=&quot;stylesheet&quot; href=&quot;/myapp/static/css/app.css&quot;&gt; --&gt;
</code></pre>
<a class="header" href="print.html#translation--internationalization-i18n" id="translation--internationalization-i18n"><h3>Translation &amp; Internationalization (i18n)</h3></a>
<p>RustF provides a Total.js-style translation system using resource files with automatic key generation and view-scoped translations.</p>
<a class="header" href="print.html#template-syntax" id="template-syntax"><h4>Template Syntax</h4></a>
<pre><code class="language-html">&lt;!-- Direct text translation (key generated from text) --&gt;
&lt;h1&gt;@(Welcome to our application)&lt;/h1&gt;
&lt;p&gt;@(Please enter your credentials)&lt;/p&gt;

&lt;!-- Translation by custom key --&gt;
&lt;footer&gt;@(#app.copyright)&lt;/footer&gt;
&lt;nav&gt;@(#nav.home)&lt;/nav&gt;
</code></pre>
<a class="header" href="print.html#resource-file-format" id="resource-file-format"><h4>Resource File Format</h4></a>
<p>Translation files use the <code>.res</code> extension and are stored in the <code>resources/</code> directory:</p>
<pre><code># resources/default.res
[global]
# Common translations used across multiple views
save : &quot;Save&quot;
cancel : &quot;Cancel&quot;
loading : &quot;Loading...&quot;

[views/home/index]
# View-specific translations
welcome_to_our_application : &quot;Welcome to our application&quot;
please_enter_your_credentials : &quot;Please enter your credentials&quot;

[views/layouts/main]
# Layout translations
app.copyright : &quot;Â© 2024 My Company&quot;
nav.home : &quot;Home&quot;
</code></pre>
<a class="header" href="print.html#setting-up-translations" id="setting-up-translations"><h4>Setting Up Translations</h4></a>
<p><strong>Loading translations in your application:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;
use rustf::views::TotalJsEngine;

// During app initialization
let engine = TotalJsEngine::new(&quot;views&quot;);

// Load translations from resources directory
engine.load_translations(Path::new(&quot;resources&quot;))?;

// Or manually with resource translation system
use rustf::views::totaljs::resource_translation::ResourceTranslationSystem;

let mut translator = ResourceTranslationSystem::new();
translator.load_resources_dir(Path::new(&quot;resources&quot;))?;
translator.set_language(&quot;fr&quot;);  // Switch to French
engine.set_resource_translator(translator);
#}</code></pre></pre>
<a class="header" href="print.html#managing-translations-with-cli" id="managing-translations-with-cli"><h4>Managing Translations with CLI</h4></a>
<pre><code class="language-bash"># Scan views and generate default.res with all discovered translations
rustf-cli translations scan

# Output:
# ğŸ” Scanning views for translations...
# âœ… Generated resources/default.res with 45 translations

# Update existing language files with new keys
rustf-cli translations update --lang fr

# Output:
# ğŸ”„ Regenerating default.res...
# ğŸ“ Updating fr.res...
# ğŸ“Š Update Report for fr.res:
#   âœ“ Existing translations preserved: 42
#   âš ï¸  New keys needing translation: 3
#      - welcome_message
#      - user_greeting
#      - logout_confirm

# Check for missing translations
rustf-cli translations check --lang es

# Show translation statistics
rustf-cli translations stats
</code></pre>
<a class="header" href="print.html#translation-workflow" id="translation-workflow"><h4>Translation Workflow</h4></a>
<ol>
<li><strong>Write views with translatable text:</strong></li>
</ol>
<pre><code class="language-html">&lt;!-- views/home/index.html --&gt;
&lt;h1&gt;@(Welcome to RustF)&lt;/h1&gt;
&lt;p&gt;@(Build fast web applications)&lt;/p&gt;
&lt;div&gt;@(#custom.message)&lt;/div&gt;
</code></pre>
<ol start="2">
<li><strong>Generate translation keys:</strong></li>
</ol>
<pre><code class="language-bash">rustf-cli translations scan
</code></pre>
<ol start="3">
<li><strong>Translate to other languages:</strong></li>
</ol>
<pre><code class="language-bash"># Copy default to create language file
cp resources/default.res resources/fr.res

# Edit fr.res and translate the values
vim resources/fr.res
</code></pre>
<ol start="4">
<li><strong>View generated fr.res:</strong></li>
</ol>
<pre><code># resources/fr.res
[global]
save : &quot;Enregistrer&quot;
cancel : &quot;Annuler&quot;
loading : &quot;Chargement...&quot;

[views/home/index]
welcome_to_rustf : &quot;Bienvenue Ã  RustF&quot;
build_fast_web_applications : &quot;Construire des applications web rapides&quot;
custom.message : &quot;&quot;  # TODO: needs translation
</code></pre>
<a class="header" href="print.html#key-generation" id="key-generation"><h4>Key Generation</h4></a>
<ul>
<li>Text in <code>@(text)</code> is converted to a readable slug key (max 30 chars)</li>
<li>Spaces become underscores, special characters removed</li>
<li>Common translations (appearing in 3+ views) are automatically moved to <code>[global]</code></li>
<li>Custom keys using <code>@(#key)</code> are preserved as-is</li>
</ul>
<a class="header" href="print.html#best-practices-4" id="best-practices-4"><h4>Best Practices</h4></a>
<ol>
<li>
<p><strong>Use descriptive custom keys for important text:</strong></p>
<pre><code class="language-html">@(#app.title)       &lt;!-- Good: Clear purpose --&gt;
@(#msg1)           &lt;!-- Bad: Unclear --&gt;
</code></pre>
</li>
<li>
<p><strong>Keep translations organized by view:</strong></p>
<ul>
<li>Each view gets its own section in the .res file</li>
<li>Layouts have their own sections</li>
<li>Common text automatically extracted to global</li>
</ul>
</li>
<li>
<p><strong>Language switching in controllers:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Set language based on user preference
if let Some(lang) = ctx.session_get(&quot;language&quot;) {
    engine.resource_translator.set_language(&amp;lang);
}
#}</code></pre></pre>
</li>
<li>
<p><strong>Fallback language support:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
translator.set_fallback(&quot;en&quot;);  // English as fallback
#}</code></pre></pre>
</li>
</ol>
<a class="header" href="print.html#global-view-api" id="global-view-api"><h2>Global VIEW API</h2></a>
<p>RustF provides a global <code>VIEW</code> API for rendering templates from anywhere in your application without needing a <code>Context</code> instance. This is particularly useful for:</p>
<ul>
<li>Email generation in background workers</li>
<li>PDF/report generation</li>
<li>Dynamic content rendering in services</li>
<li>Template rendering in middleware or utilities</li>
</ul>
<a class="header" href="print.html#basic-usage-1" id="basic-usage-1"><h3>Basic Usage</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;
use serde_json::json;

// Render an inline template string
let html = VIEW::render_string(
    &quot;Hello @{M.name}!&quot;,
    json!({&quot;name&quot;: &quot;Alice&quot;}),
    None
)?;
// Output: &quot;Hello Alice!&quot;

// Render a template file
let html = VIEW::render(
    &quot;emails/welcome&quot;,
    json!({&quot;user&quot;: &quot;Alice&quot;}),
    None,
    Some(&quot;layouts/email&quot;)
)?;
#}</code></pre></pre>
<a class="header" href="print.html#method-signatures" id="method-signatures"><h3>Method Signatures</h3></a>
<a class="header" href="print.html#viewrender_string" id="viewrender_string"><h4><code>VIEW::render_string()</code></h4></a>
<p>Render an inline template string with model and optional repository data.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn render_string(
    template_string: &amp;str,
    model: Value,
    repository: Option&lt;Value&gt;
) -&gt; Result&lt;String&gt;
#}</code></pre></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>template_string</code>: Template content as string</li>
<li><code>model</code>: Main template data (accessible as <code>@{M.key}</code>)</li>
<li><code>repository</code>: Optional context data (accessible as <code>@{R.key}</code>)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let template = &quot;Welcome @{M.user}, your role is @{R.role}&quot;;
let model = json!({&quot;user&quot;: &quot;Alice&quot;});
let repository = json!({&quot;role&quot;: &quot;Admin&quot;});

let html = VIEW::render_string(template, model, Some(repository))?;
// Output: &quot;Welcome Alice, your role is Admin&quot;
#}</code></pre></pre>
<a class="header" href="print.html#viewrender" id="viewrender"><h4><code>VIEW::render()</code></h4></a>
<p>Render a template file with model, repository, and optional layout.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn render(
    template_path: &amp;str,
    model: Value,
    repository: Option&lt;Value&gt;,
    layout: Option&lt;&amp;str&gt;
) -&gt; Result&lt;String&gt;
#}</code></pre></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>template_path</code>: Path to template (relative to views directory, without extension)</li>
<li><code>model</code>: Main template data (accessible as <code>@{M.key}</code>)</li>
<li><code>repository</code>: Optional context data (accessible as <code>@{R.key}</code>)</li>
<li><code>layout</code>: Optional layout template name</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let html = VIEW::render(
    &quot;reports/sales&quot;,
    json!({&quot;month&quot;: &quot;January&quot;, &quot;total&quot;: 50000}),
    Some(json!({&quot;company&quot;: &quot;ACME Corp&quot;, &quot;year&quot;: 2025})),
    Some(&quot;layouts/pdf&quot;)
)?;
#}</code></pre></pre>
<a class="header" href="print.html#model-vs-repository-data" id="model-vs-repository-data"><h3>Model vs Repository Data</h3></a>
<p>The VIEW API maintains the same model/repository separation as controller rendering:</p>
<ul>
<li><strong>Model (<code>@{M.key}</code>)</strong>: Primary template data - the main content</li>
<li><strong>Repository (<code>@{R.key}</code>)</strong>: Context/metadata - site config, user info, etc.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let model = json!({
    &quot;product&quot;: &quot;Widget&quot;,
    &quot;price&quot;: 29.99,
    &quot;quantity&quot;: 5
});

let repository = json!({
    &quot;site_name&quot;: &quot;My Store&quot;,
    &quot;currency&quot;: &quot;USD&quot;,
    &quot;tax_rate&quot;: 0.08
});

let template = r#&quot;
    &lt;h1&gt;@{R.site_name}&lt;/h1&gt;
    &lt;p&gt;Product: @{M.product}&lt;/p&gt;
    &lt;p&gt;Price: @{R.currency} @{M.price}&lt;/p&gt;
&quot;#;

let html = VIEW::render_string(template, model, Some(repository))?;
#}</code></pre></pre>
<a class="header" href="print.html#use-cases" id="use-cases"><h3>Use Cases</h3></a>
<a class="header" href="print.html#email-generation-in-workers" id="email-generation-in-workers"><h4>Email Generation in Workers</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

pub async fn send_welcome_email(ctx: WorkerContext) -&gt; rustf::Result&lt;()&gt; {
    let email_template = r#&quot;
        &lt;html&gt;
        &lt;body&gt;
            &lt;h1&gt;Welcome to @{R.app_name}!&lt;/h1&gt;
            &lt;p&gt;Hello @{M.name},&lt;/p&gt;
            &lt;p&gt;Thanks for signing up. Your username is: @{M.username}&lt;/p&gt;
            &lt;footer&gt;&amp;copy; @{R.year} @{R.company}&lt;/footer&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    &quot;#;
    
    let model = json!({
        &quot;name&quot;: ctx.data[&quot;name&quot;],
        &quot;username&quot;: ctx.data[&quot;username&quot;]
    });
    
    let repository = json!({
        &quot;app_name&quot;: &quot;My App&quot;,
        &quot;year&quot;: 2025,
        &quot;company&quot;: &quot;My Company Inc.&quot;
    });
    
    let html = VIEW::render_string(email_template, model, Some(repository))?;
    
    // Send email with html content
    send_email(&amp;ctx.data[&quot;email&quot;].as_str().unwrap(), &amp;html).await?;
    Ok(())
}
#}</code></pre></pre>
<a class="header" href="print.html#report-generation" id="report-generation"><h4>Report Generation</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

pub fn generate_sales_report(sales_data: Vec&lt;SaleRecord&gt;) -&gt; rustf::Result&lt;String&gt; {
    let template = r#&quot;
        &lt;h1&gt;Sales Report - @{M.period}&lt;/h1&gt;
        &lt;table&gt;
            &lt;tr&gt;&lt;th&gt;Product&lt;/th&gt;&lt;th&gt;Units&lt;/th&gt;&lt;th&gt;Revenue&lt;/th&gt;&lt;/tr&gt;
            @{foreach item in M.items}
            &lt;tr&gt;
                &lt;td&gt;@{item}&lt;/td&gt;
                &lt;td&gt;@{item}&lt;/td&gt;
                &lt;td&gt;$@{item}&lt;/td&gt;
            &lt;/tr&gt;
            @{end}
        &lt;/table&gt;
        &lt;p&gt;Generated: @{R.generated_date}&lt;/p&gt;
    &quot;#;
    
    let model = json!({
        &quot;period&quot;: &quot;Q1 2025&quot;,
        &quot;items&quot;: sales_data
    });
    
    let repository = json!({
        &quot;generated_date&quot;: chrono::Utc::now().to_rfc3339()
    });
    
    VIEW::render_string(template, model, Some(repository))
}
#}</code></pre></pre>
<a class="header" href="print.html#dynamic-content-in-middleware" id="dynamic-content-in-middleware"><h4>Dynamic Content in Middleware</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

pub async fn render_error_page(status: u16, message: &amp;str) -&gt; rustf::Result&lt;String&gt; {
    let template = r#&quot;
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
        &lt;head&gt;&lt;title&gt;Error @{M.status}&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;@{M.status} - @{M.title}&lt;/h1&gt;
            &lt;p&gt;@{M.message}&lt;/p&gt;
            &lt;footer&gt;@{R.app_name}&lt;/footer&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    &quot;#;
    
    let model = json!({
        &quot;status&quot;: status,
        &quot;title&quot;: if status == 404 { &quot;Not Found&quot; } else { &quot;Error&quot; },
        &quot;message&quot;: message
    });
    
    let repository = json!({
        &quot;app_name&quot;: &quot;My Application&quot;
    });
    
    VIEW::render_string(template, model, Some(repository))
}
#}</code></pre></pre>
<a class="header" href="print.html#template-file-rendering" id="template-file-rendering"><h4>Template File Rendering</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// views/emails/order_confirmation.html
// &lt;h1&gt;Order Confirmation&lt;/h1&gt;
// &lt;p&gt;Thank you @{M.customer_name}!&lt;/p&gt;
// &lt;p&gt;Order #@{M.order_id} has been confirmed.&lt;/p&gt;

use rustf::prelude::*;

pub async fn send_order_confirmation(order: Order) -&gt; rustf::Result&lt;()&gt; {
    let html = VIEW::render(
        &quot;emails/order_confirmation&quot;,
        json!({
            &quot;customer_name&quot;: order.customer_name,
            &quot;order_id&quot;: order.id,
            &quot;total&quot;: order.total
        }),
        Some(json!({
            &quot;site_name&quot;: &quot;My Shop&quot;,
            &quot;support_email&quot;: &quot;support@myshop.com&quot;
        })),
        Some(&quot;layouts/email&quot;)  // Use email layout
    )?;
    
    send_email(&amp;order.customer_email, &amp;html).await?;
    Ok(())
}
#}</code></pre></pre>
<a class="header" href="print.html#limitations" id="limitations"><h3>Limitations</h3></a>
<ol>
<li><strong>No Session Data</strong>: Global VIEW API doesn't have access to session data (use <code>ctx.view()</code> in controllers for session access)</li>
<li><strong>Initialization Required</strong>: VIEW must be initialized during app startup (automatic with <code>auto_load()</code>)</li>
<li><strong>Template Features</strong>: All Total.js features work (conditionals, loops, variables, etc.)</li>
</ol>
<a class="header" href="print.html#best-practices-5" id="best-practices-5"><h3>Best Practices</h3></a>
<ol>
<li><strong>Use Model/Repository Separation</strong>: Keep template data (<code>M</code>) separate from context (<code>R</code>)</li>
<li><strong>Validate Before Rendering</strong>: Ensure data is complete before calling VIEW</li>
<li><strong>Handle Errors</strong>: Always handle <code>Result</code> from VIEW methods</li>
<li><strong>Cache Templates</strong>: Use file-based templates for better caching in production</li>
<li><strong>Test Rendering</strong>: Unit test your templates with VIEW::render_string()</li>
</ol>
<a class="header" href="print.html#performance-tips" id="performance-tips"><h2>Performance Tips</h2></a>
<a class="header" href="print.html#development" id="development"><h3>Development</h3></a>
<pre><code class="language-toml">[views]
cache_enabled = false  # Hot-reload templates
</code></pre>
<a class="header" href="print.html#production" id="production"><h3>Production</h3></a>
<pre><code class="language-toml">[views]
cache_enabled = true   # Cache compiled templates
storage = &quot;embedded&quot;   # Embed templates in binary
</code></pre>
<a class="header" href="print.html#template-caching" id="template-caching"><h3>Template Caching</h3></a>
<p>Templates are automatically cached when <code>cache_enabled = true</code>:</p>
<ul>
<li>First request compiles the template</li>
<li>Subsequent requests use cached version</li>
<li>No manual cache management needed</li>
</ul>
<a class="header" href="print.html#directory-structure" id="directory-structure"><h2>Directory Structure</h2></a>
<pre><code>views/
â”œâ”€â”€ layouts/
â”‚   â””â”€â”€ application.html    # Main layout
â”œâ”€â”€ home/
â”‚   â”œâ”€â”€ index.html          # Homepage
â”‚   â””â”€â”€ about.html          # About page
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ login.html          # Login form
â”‚   â””â”€â”€ register.html       # Registration
â””â”€â”€ components/
    â”œâ”€â”€ navbar.html         # Reusable navbar
    â””â”€â”€ footer.html         # Reusable footer
</code></pre>
<a class="header" href="print.html#error-handling-1" id="error-handling-1"><h2>Error Handling</h2></a>
<a class="header" href="print.html#template-not-found" id="template-not-found"><h3>Template Not Found</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Graceful fallback
match ctx.view(&quot;missing-template&quot;, data) {
    Ok(response) =&gt; Ok(response),
    Err(_) =&gt; ctx.view(&quot;errors/404&quot;, json!({&quot;message&quot;: &quot;Page not found&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#syntax-errors" id="syntax-errors"><h3>Syntax Errors</h3></a>
<ul>
<li><strong>Total.js</strong>: Errors shown with line numbers during development</li>
<li><strong>Tera</strong>: Compile-time checking with detailed error messages</li>
</ul>
<a class="header" href="print.html#migration-guide" id="migration-guide"><h2>Migration Guide</h2></a>
<a class="header" href="print.html#from-tera-to-totaljs" id="from-tera-to-totaljs"><h3>From Tera to Total.js</h3></a>
<table><thead><tr><th> Tera </th><th> Total.js </th></tr></thead><tbody>
<tr><td> <code>{{ variable }}</code> </td><td> <code>@{variable}</code> </td></tr>
<tr><td> <code>{% if condition %}</code> </td><td> <code>@{if condition}</code> </td></tr>
<tr><td> <code>{% endif %}</code> </td><td> <code>@{fi}</code> </td></tr>
<tr><td> <code>{% for item in items %}</code> </td><td> <code>@{foreach item in items}</code> </td></tr>
<tr><td> <code>{% endfor %}</code> </td><td> <code>@{end}</code> </td></tr>
<tr><td> <code>{{ var \| escape }}</code> </td><td> <code>@{var}</code> (auto-escaped) </td></tr>
<tr><td> <code>{{ var \| safe }}</code> </td><td> <code>@{!var}</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#from-totaljs-to-tera" id="from-totaljs-to-tera"><h3>From Total.js to Tera</h3></a>
<table><thead><tr><th> Total.js </th><th> Tera </th></tr></thead><tbody>
<tr><td> <code>@{variable}</code> </td><td> <code>{{ variable }}</code> </td></tr>
<tr><td> <code>@{if condition}</code> </td><td> <code>{% if condition %}</code> </td></tr>
<tr><td> <code>@{fi}</code> </td><td> <code>{% endif %}</code> </td></tr>
<tr><td> <code>@{foreach item in items}</code> </td><td> <code>{% for item in items %}</code> </td></tr>
<tr><td> <code>@{end}</code> </td><td> <code>{% endfor %}</code> </td></tr>
<tr><td> <code>@{!raw_html}</code> </td><td> <code>{{ raw_html \| safe }}</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#best-practices-6" id="best-practices-6"><h2>Best Practices</h2></a>
<ol>
<li><strong>Use layouts</strong> - Define common structure once</li>
<li><strong>Escape user input</strong> - Use auto-escaping by default</li>
<li><strong>Cache in production</strong> - Enable template caching</li>
<li><strong>Organize templates</strong> - Group by feature/module</li>
<li><strong>Keep logic minimal</strong> - Complex logic belongs in controllers</li>
<li><strong>Use components</strong> - Create reusable template parts</li>
<li><strong>Validate data</strong> - Don't trust template input</li>
<li><strong>Handle errors</strong> - Provide fallback templates</li>
</ol>
<a class="header" href="print.html#troubleshooting-1" id="troubleshooting-1"><h2>Troubleshooting</h2></a>
<a class="header" href="print.html#templates-not-loading" id="templates-not-loading"><h3>Templates Not Loading</h3></a>
<ul>
<li>Check <code>views.directory</code> in config.toml</li>
<li>Verify file extensions match <code>views.extension</code></li>
<li>Ensure template names don't include extension in controller</li>
</ul>
<a class="header" href="print.html#variables-not-rendering" id="variables-not-rendering"><h3>Variables Not Rendering</h3></a>
<ul>
<li>Check variable names match exactly</li>
<li>Verify data is passed to <code>ctx.view()</code></li>
<li>Use <code>@{json(variable)}</code> to debug data structure</li>
</ul>
<a class="header" href="print.html#layout-issues" id="layout-issues"><h3>Layout Issues</h3></a>
<ul>
<li>Verify layout path is correct</li>
<li>Check <code>@{content}</code> placeholder exists in layout</li>
<li>Ensure child template specifies layout</li>
</ul>
<a class="header" href="print.html#performance-issues" id="performance-issues"><h3>Performance Issues</h3></a>
<ul>
<li>Enable <code>cache_enabled</code> in production</li>
<li>Use <code>embedded</code> storage for deployment</li>
<li>Minimize template complexity</li>
<li>Move heavy logic to controllers</li>
</ul>
<a class="header" href="print.html#examples" id="examples"><h2>Examples</h2></a>
<a class="header" href="print.html#complete-controller-with-views-and-repositories" id="complete-controller-with-views-and-repositories"><h3>Complete Controller with Views and Repositories</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

#[rustf::install]
impl ProductController {
    #[route(GET, &quot;/products&quot;)]
    pub async fn index(mut ctx: Context) -&gt; Result&lt;Response&gt; {
        let products = vec![
            json!({&quot;id&quot;: 1, &quot;name&quot;: &quot;Widget&quot;, &quot;price&quot;: 19.99}),
            json!({&quot;id&quot;: 2, &quot;name&quot;: &quot;Gadget&quot;, &quot;price&quot;: 29.99}),
        ];
        
        // Set context repository for this page
        ctx.repository_set(&quot;view_mode&quot;, &quot;grid&quot;)
           .repository_set(&quot;filters_available&quot;, json!([&quot;price&quot;, &quot;category&quot;, &quot;brand&quot;]))
           .repository_set(&quot;user_preferences&quot;, json!({
               &quot;currency&quot;: &quot;USD&quot;,
               &quot;show_tax&quot;: true
           }));
        
        ctx.view(&quot;products/index&quot;, json!({
            &quot;title&quot;: &quot;Our Products&quot;,
            &quot;products&quot;: products,
            &quot;featured&quot;: true
        }))
    }
    
    #[route(GET, &quot;/products/:id&quot;)]
    pub async fn show(mut ctx: Context) -&gt; Result&lt;Response&gt; {
        let id = ctx.param(&quot;id&quot;)?;
        
        // Fetch product from database
        let product = json!({
            &quot;id&quot;: id,
            &quot;name&quot;: &quot;Premium Widget&quot;,
            &quot;price&quot;: 49.99,
            &quot;description&quot;: &quot;High-quality widget&quot;
        });
        
        // Set repository data for product page
        ctx.repository_set(&quot;breadcrumbs&quot;, json!([
            {&quot;name&quot;: &quot;Home&quot;, &quot;url&quot;: &quot;/&quot;},
            {&quot;name&quot;: &quot;Products&quot;, &quot;url&quot;: &quot;/products&quot;},
            {&quot;name&quot;: &quot;Premium Widget&quot;, &quot;url&quot;: null}
        ]))
        .repository_set(&quot;show_reviews&quot;, true)
        .repository_set(&quot;related_products_count&quot;, 5);
        
        ctx.view(&quot;products/show&quot;, product)
    }
    
    #[route(POST, &quot;/products/:id/buy&quot;)]
    pub async fn purchase(ctx: Context) -&gt; Result&lt;Response&gt; {
        let id = ctx.param(&quot;id&quot;)?;
        
        // Process purchase...
        
        ctx.flash(&quot;success&quot;, &quot;Purchase completed!&quot;);
        ctx.redirect(&amp;format!(&quot;/products/{}&quot;, id))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#template-with-all-features-including-repositories" id="template-with-all-features-including-repositories"><h3>Template with All Features Including Repositories</h3></a>
<pre><code class="language-html">@{layout('layouts/default')}

&lt;!-- Page specific CSS --&gt;
@{css('/static/css/products.css')}

&lt;!-- Breadcrumbs from repository --&gt;
@{if R.breadcrumbs}
    &lt;nav class=&quot;breadcrumbs&quot;&gt;
        @{foreach crumb in R.breadcrumbs}
            @{if crumb.url}
                &lt;a href=&quot;@{crumb.url}&quot;&gt;@{crumb.name}&lt;/a&gt; /
            @{else}
                &lt;span&gt;@{crumb.name}&lt;/span&gt;
            @{fi}
        @{end}
    &lt;/nav&gt;
@{fi}

&lt;div class=&quot;products-page view-@{R.view_mode}&quot;&gt;
    &lt;h1&gt;@{title}&lt;/h1&gt;
    
    &lt;!-- Filters from repository --&gt;
    @{if R.filters_available}
        &lt;div class=&quot;filters&quot;&gt;
            @{foreach filter in R.filters_available}
                &lt;button class=&quot;filter-btn&quot;&gt;Filter by @{filter}&lt;/button&gt;
            @{end}
        &lt;/div&gt;
    @{fi}
    
    &lt;!-- User preferences from repository --&gt;
    &lt;div class=&quot;preferences&quot;&gt;
        Currency: @{R.user_preferences.currency}
        @{if R.user_preferences.show_tax}
            &lt;small&gt;(Prices include tax)&lt;/small&gt;
        @{fi}
    &lt;/div&gt;
    
    &lt;!-- Conditional rendering --&gt;
    @{if featured}
        &lt;div class=&quot;featured-banner&quot;&gt;
            &lt;p&gt;Check out our featured products!&lt;/p&gt;
        &lt;/div&gt;
    @{fi}
    
    &lt;!-- Loop through products --&gt;
    &lt;div class=&quot;product-grid&quot;&gt;
        @{foreach product in products}
            &lt;div class=&quot;product-card&quot;&gt;
                &lt;h3&gt;@{product.name}&lt;/h3&gt;
                &lt;p class=&quot;price&quot;&gt;@{format_price(product.price)}&lt;/p&gt;
                &lt;a href=&quot;@{root}/products/@{product.id}&quot; class=&quot;btn&quot;&gt;
                    View Details
                &lt;/a&gt;
            &lt;/div&gt;
        @{end}
    &lt;/div&gt;
    
    &lt;!-- Reviews section if enabled --&gt;
    @{if R.show_reviews}
        &lt;div class=&quot;reviews-section&quot;&gt;
            &lt;h2&gt;Customer Reviews&lt;/h2&gt;
            &lt;!-- Reviews content --&gt;
        &lt;/div&gt;
    @{fi}
    
    &lt;!-- Related products --&gt;
    @{if R.related_products_count &gt; 0}
        &lt;div class=&quot;related&quot;&gt;
            &lt;p&gt;See @{R.related_products_count} related products&lt;/p&gt;
        &lt;/div&gt;
    @{fi}
    
    &lt;!-- Raw HTML inclusion --&gt;
    @{if marketing_content}
        @{!marketing_content}
    @{fi}
&lt;/div&gt;

&lt;!-- Footer with global repository data --&gt;
&lt;footer&gt;
    &lt;p&gt;@{APP.site_name} v@{APP.version}&lt;/p&gt;
    &lt;p&gt;@{MAIN.copyright}&lt;/p&gt;
    &lt;p&gt;Contact: @{APP.contact_email}&lt;/p&gt;
&lt;/footer&gt;

&lt;!-- Page specific JS --&gt;
@{js('/static/js/products.js')}
</code></pre>
<p>This documentation provides a complete guide to using the RustF view system with practical examples and best practices for both Total.js and Tera template engines.</p>
<a class="header" href="print.html#rustf-middleware-system-documentation" id="rustf-middleware-system-documentation"><h1>RustF Middleware System Documentation</h1></a>
<a class="header" href="print.html#overview-2" id="overview-2"><h2>Overview</h2></a>
<p>RustF provides a comprehensive dual-phase middleware system that separates request processing from response modification. This architecture provides clear separation of concerns and predictable execution order, making it highly suitable for AI-assisted development.</p>
<a class="header" href="print.html#core-architecture" id="core-architecture"><h2>Core Architecture</h2></a>
<a class="header" href="print.html#dual-phase-processing" id="dual-phase-processing"><h3>Dual-Phase Processing</h3></a>
<p>The middleware system operates in two distinct phases:</p>
<ol>
<li><strong>Inbound Phase</strong> - Processes incoming requests before they reach controllers</li>
<li><strong>Outbound Phase</strong> - Modifies responses after controllers have executed</li>
</ol>
<p>This separation allows middleware to cleanly handle both request validation/transformation and response enhancement without complex state management.</p>
<a class="header" href="print.html#core-components-1" id="core-components-1"><h2>Core Components</h2></a>
<a class="header" href="print.html#inboundmiddleware-trait" id="inboundmiddleware-trait"><h3>InboundMiddleware Trait</h3></a>
<p>Processes requests before they reach controllers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use async_trait::async_trait;

#[async_trait]
pub trait InboundMiddleware: Send + Sync + 'static {
    async fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt;;
    
    fn name(&amp;self) -&gt; &amp;'static str { &quot;unnamed&quot; }
    fn priority(&amp;self) -&gt; i32 { 0 }
    fn should_run(&amp;self, ctx: &amp;Context) -&gt; bool { true }
}
#}</code></pre></pre>
<p><strong>Key Methods:</strong></p>
<ul>
<li><code>process_request()</code> - Main processing logic for incoming requests</li>
<li><code>name()</code> - Identifies the middleware for debugging/logging</li>
<li><code>priority()</code> - Execution order (lower numbers run first, -1000 to 1000)</li>
<li><code>should_run()</code> - Conditional execution based on request context</li>
</ul>
<a class="header" href="print.html#inboundaction-enum" id="inboundaction-enum"><h3>InboundAction Enum</h3></a>
<p>Inbound middleware returns one of three actions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub enum InboundAction {
    Continue,           // Continue to next middleware
    Stop,               // Stop chain and return response set on context
    Capture,           // Continue but process response later
}
#}</code></pre></pre>
<ul>
<li><code>Continue</code> - Pass request to next middleware without capturing response</li>
<li><code>Stop</code> - Stop processing and return the response that was set on context using response helpers</li>
<li><code>Capture</code> - Continue processing but ensure outbound phase runs</li>
</ul>
<a class="header" href="print.html#outboundmiddleware-trait" id="outboundmiddleware-trait"><h3>OutboundMiddleware Trait</h3></a>
<p>Modifies responses after controllers execute:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use async_trait::async_trait;

#[async_trait]
pub trait OutboundMiddleware: Send + Sync + 'static {
    async fn process_response(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;()&gt;;
}
#}</code></pre></pre>
<p><strong>Important Change:</strong> The outbound middleware now receives <code>&amp;mut Context</code> instead of separate context and response parameters. The response is accessed and modified through <code>ctx.response</code> field.</p>
<a class="header" href="print.html#dualphasemiddleware-trait" id="dualphasemiddleware-trait"><h3>DualPhaseMiddleware Trait</h3></a>
<p>For middleware that needs both phases:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait DualPhaseMiddleware: InboundMiddleware + OutboundMiddleware {}
#}</code></pre></pre>
<p>Any type implementing both traits automatically implements <code>DualPhaseMiddleware</code>.</p>
<a class="header" href="print.html#-critical-async-middleware-requirements" id="-critical-async-middleware-requirements"><h2>âš ï¸ Critical: Async Middleware Requirements</h2></a>
<p><strong>IMPORTANT</strong>: All middleware in RustF MUST be async to prevent application hangs:</p>
<ol>
<li><strong>Always use <code>#[async_trait]</code></strong> - Required for all middleware trait implementations</li>
<li><strong>Never use <code>block_on</code></strong> - Using <code>futures::executor::block_on</code> will cause the application to hang, especially with database storage</li>
<li><strong>All I/O operations must be async</strong> - Session operations, database queries, and network calls must use async/await</li>
</ol>
<a class="header" href="print.html#why-this-matters" id="why-this-matters"><h3>Why This Matters</h3></a>
<p>The middleware system was redesigned to be fully async to fix a critical issue where applications would hang when using database-backed session storage. The previous implementation used <code>block_on</code> which blocked the async runtime, causing deadlocks with connection pools and async I/O operations.</p>
<a class="header" href="print.html#writing-middleware" id="writing-middleware"><h2>Writing Middleware</h2></a>
<a class="header" href="print.html#simple-inbound-middleware" id="simple-inbound-middleware"><h3>Simple Inbound Middleware</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::middleware::{InboundMiddleware, InboundAction};
use rustf::context::Context;
use rustf::error::Result;
use async_trait::async_trait;

pub struct AuthMiddleware {
    required_role: String,
}

#[async_trait]
impl InboundMiddleware for AuthMiddleware {
    async fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        // Check authentication
        if let Some(user) = ctx.session_get::&lt;User&gt;(&quot;user&quot;) {
            if user.role == self.required_role {
                return Ok(InboundAction::Continue);
            }
        }
        
        // Not authorized - use context helpers to set response
        ctx.throw403(Some(&quot;Unauthorized&quot;))?;
        Ok(InboundAction::Stop)
    }
    
    fn name(&amp;self) -&gt; &amp;'static str {
        &quot;auth&quot;
    }
    
    fn priority(&amp;self) -&gt; i32 {
        -500  // Run early (lower numbers execute first)
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#simple-outbound-middleware" id="simple-outbound-middleware"><h3>Simple Outbound Middleware</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::middleware::OutboundMiddleware;
use rustf::context::Context;
use rustf::error::Result;
use async_trait::async_trait;

pub struct CompressionMiddleware;

#[async_trait]
impl OutboundMiddleware for CompressionMiddleware {
    async fn process_response(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
        // Access the response through ctx.response
        if let Some(response) = ctx.response.as_mut() {
            // Add compression headers
            response.headers.push((
                &quot;Content-Encoding&quot;.to_string(),
                &quot;gzip&quot;.to_string()
            ));
            
            // Compress body (simplified)
            // response.body = compress(response.body);
        }
        
        Ok(())
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#dual-phase-middleware" id="dual-phase-middleware"><h3>Dual-Phase Middleware</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::middleware::{InboundMiddleware, OutboundMiddleware, InboundAction};
use async_trait::async_trait;
use std::time::Instant;

pub struct TimingMiddleware;

#[async_trait]
impl InboundMiddleware for TimingMiddleware {
    async fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        // Store start time
        ctx.set(&quot;request_start&quot;, Instant::now());
        
        // Capture response to add timing header
        Ok(InboundAction::Capture)
    }
}

#[async_trait]
impl OutboundMiddleware for TimingMiddleware {
    async fn process_response(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
        if let Some(start) = ctx.get::&lt;Instant&gt;(&quot;request_start&quot;) {
            let duration = start.elapsed();
            
            // Access response through ctx.response
            if let Some(response) = ctx.response.as_mut() {
                response.headers.push((
                    &quot;X-Response-Time&quot;.to_string(),
                    format!(&quot;{}ms&quot;, duration.as_millis())
                ));
            }
        }
        Ok(())
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#registration" id="registration"><h2>Registration</h2></a>
<a class="header" href="print.html#basic-registration" id="basic-registration"><h3>Basic Registration</h3></a>
<p>There are three ways to register middleware in RustF:</p>
<a class="header" href="print.html#method-1-auto-discovery-recommended-for-custom-middleware" id="method-1-auto-discovery-recommended-for-custom-middleware"><h4>Method 1: Auto-Discovery (Recommended for custom middleware)</h4></a>
<p>Place your middleware in <code>src/middleware/*.rs</code> with an <code>install</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/middleware/auth.rs
pub fn install(registry: &amp;mut MiddlewareRegistry) {
    registry.register_inbound(&quot;auth&quot;, AuthMiddleware::new());
}

// In main.rs
let app = RustF::new()
    .middleware_from(auto_middleware!()); // Auto-discovers all middleware
#}</code></pre></pre>
<a class="header" href="print.html#method-2-manual-registration-with-middleware_from" id="method-2-manual-registration-with-middleware_from"><h4>Method 2: Manual Registration with middleware_from</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = RustF::new()
    .middleware_from(|registry| {
        // Register inbound middleware
        registry.register_inbound(&quot;auth&quot;, AuthMiddleware::new());
        
        // Register outbound middleware  
        registry.register_outbound(&quot;compression&quot;, CompressionMiddleware);
        
        // Register dual-phase middleware
        registry.register_dual(&quot;timing&quot;, TimingMiddleware);
    });
#}</code></pre></pre>
<a class="header" href="print.html#method-3-direct-registration-advanced---requires-mutable-app" id="method-3-direct-registration-advanced---requires-mutable-app"><h4>Method 3: Direct Registration (Advanced - requires mutable app)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Register inbound middleware
app.middleware.register_inbound(&quot;auth&quot;, AuthMiddleware::new());

// Register outbound middleware  
app.middleware.register_outbound(&quot;compression&quot;, CompressionMiddleware);

// Register dual-phase middleware
app.middleware.register_dual(&quot;timing&quot;, TimingMiddleware);
#}</code></pre></pre>
<a class="header" href="print.html#setting-middleware-priority" id="setting-middleware-priority"><h3>Setting Middleware Priority</h3></a>
<p>Priority is set by implementing the <code>priority()</code> method in your middleware trait implementation. Lower numbers execute first (range: -1000 to 1000).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use async_trait::async_trait;

#[async_trait]
impl InboundMiddleware for AuthMiddleware {
    async fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        // Your middleware logic here
        Ok(InboundAction::Continue)
    }
    
    fn priority(&amp;self) -&gt; i32 {
        -500  // Runs early in the chain
    }
}

// Example: Multiple middleware with different priorities
#[async_trait]
impl InboundMiddleware for LoggingMiddleware {
    async fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        // Log request
        Ok(InboundAction::Continue)
    }
    
    fn priority(&amp;self) -&gt; i32 {
        -1000  // Highest priority, runs first
    }
}

#[async_trait]
impl InboundMiddleware for RateLimitMiddleware {
    async fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        // Check rate limits
        Ok(InboundAction::Continue)
    }
    
    fn priority(&amp;self) -&gt; i32 {
        -900  // Runs after logging but before auth
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#default-security-middleware" id="default-security-middleware"><h3>Default Security Middleware</h3></a>
<p>RustF provides built-in security middleware that can be enabled with one call:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = RustF::new()
    .with_default_security();  // Enables security headers, input validation, CSP
#}</code></pre></pre>
<p>Or configure individually using middleware_from:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = RustF::new()
    .middleware_from(|registry| {
        registry.register_outbound(&quot;security_headers&quot;, SecurityHeadersMiddleware::new());
        registry.register_inbound(&quot;input_validation&quot;, InputValidationMiddleware::new());
        registry.register_dual(&quot;csp&quot;, CspMiddleware::permissive());
        registry.register_inbound(&quot;rate_limit&quot;, RateLimitMiddleware::new());
    });
#}</code></pre></pre>
<a class="header" href="print.html#built-in-middleware" id="built-in-middleware"><h2>Built-in Middleware</h2></a>
<p><strong>Note</strong>: All built-in middleware properly implement async traits without any blocking operations. They are safe to use with database-backed session storage and other async I/O operations.</p>
<a class="header" href="print.html#security-middleware" id="security-middleware"><h3>Security Middleware</h3></a>
<ol>
<li>
<p><strong>SecurityHeadersMiddleware</strong> (Outbound)</p>
<ul>
<li>Adds comprehensive security headers (X-Frame-Options, X-Content-Type-Options, etc.)</li>
<li>Configurable for development/production environments</li>
</ul>
</li>
<li>
<p><strong>InputValidationMiddleware</strong> (Inbound)</p>
<ul>
<li>Validates input for SQL injection, XSS, path traversal</li>
<li>Configurable patterns and exclusions</li>
</ul>
</li>
<li>
<p><strong>CspMiddleware</strong> (Dual-Phase)</p>
<ul>
<li>Content Security Policy with nonce generation</li>
<li>Inbound: generates nonces for inline scripts/styles</li>
<li>Outbound: adds CSP headers with nonces</li>
</ul>
</li>
<li>
<p><strong>RateLimitMiddleware</strong> (Inbound)</p>
<ul>
<li>IP-based rate limiting with configurable windows</li>
<li>DashMap-based for thread-safe operation</li>
<li>Automatic cleanup of old entries</li>
</ul>
</li>
</ol>
<a class="header" href="print.html#utility-middleware" id="utility-middleware"><h3>Utility Middleware</h3></a>
<ol>
<li>
<p><strong>LoggingMiddleware</strong> (Dual-Phase)</p>
<ul>
<li>Logs requests with timing information</li>
<li>Inbound: logs incoming request</li>
<li>Outbound: logs response with duration</li>
</ul>
</li>
<li>
<p><strong>CorsMiddleware</strong> (Dual-Phase)</p>
<ul>
<li>Handles CORS preflight and headers</li>
<li>Inbound: responds to OPTIONS requests</li>
<li>Outbound: adds CORS headers to responses</li>
</ul>
</li>
<li>
<p><strong>SessionMiddleware</strong> (Dual-Phase)</p>
<ul>
<li>Session management with cookie handling</li>
<li>Inbound: loads session from cookie (async, no blocking)</li>
<li>Outbound: saves session to cookie (async, no blocking)</li>
<li><strong>Fixed</strong>: Previously used <code>block_on</code> causing hangs with database storage - now fully async</li>
</ul>
</li>
<li>
<p><strong>ValidationMiddleware</strong> (Inbound)</p>
<ul>
<li>Form validation with configurable rules</li>
<li>CSRF protection integration</li>
<li>Automatic error response generation</li>
</ul>
</li>
</ol>
<a class="header" href="print.html#execution-order" id="execution-order"><h2>Execution Order</h2></a>
<a class="header" href="print.html#priority-system" id="priority-system"><h3>Priority System</h3></a>
<p>Middleware executes based on priority (lower numbers first):</p>
<pre><code>-1000: Logging (capture everything)
 -900: Rate limiting (block early)
 -800: Security headers
 -700: CSP 
 -600: Input validation
 -500: CORS
 -400: Authentication
 -300: Session loading
    0: Default priority
 +100: Business logic
 +500: Caching
+1000: Final cleanup
</code></pre>
<a class="header" href="print.html#phase-execution" id="phase-execution"><h3>Phase Execution</h3></a>
<ol>
<li>
<p><strong>Inbound Phase</strong> (before controller):</p>
<ul>
<li>Middleware sorted by priority (ascending)</li>
<li>Each middleware's <code>should_run()</code> checked</li>
<li><code>process_request()</code> called sequentially</li>
<li>Chain stops if any returns <code>Stop</code> (using response set on context)</li>
</ul>
</li>
<li>
<p><strong>Controller Execution</strong>:</p>
<ul>
<li>Only if all inbound middleware returned <code>Continue</code> or <code>Capture</code></li>
</ul>
</li>
<li>
<p><strong>Outbound Phase</strong> (after controller):</p>
<ul>
<li>Only for middleware that returned <code>Capture</code> or registered as outbound</li>
<li>Executes in reverse order of inbound</li>
<li>Each modifies response in place</li>
</ul>
</li>
</ol>
<a class="header" href="print.html#accessing-response-in-outbound-phase" id="accessing-response-in-outbound-phase"><h2>Accessing Response in Outbound Phase</h2></a>
<p>With the new architecture, outbound middleware accesses the response through the Context's <code>response</code> field:</p>
<a class="header" href="print.html#response-access-pattern" id="response-access-pattern"><h3>Response Access Pattern</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl OutboundMiddleware for MyMiddleware {
    fn process_response(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
        // The response might be None if an error occurred
        if let Some(response) = ctx.response.as_mut() {
            // Modify response headers
            response.headers.push((&quot;X-Custom&quot;.to_string(), &quot;value&quot;.to_string()));
            
            // Check status
            if response.status.is_server_error() {
                // Handle error responses differently
                response.headers.push((&quot;X-Error&quot;.to_string(), &quot;true&quot;.to_string()));
            }
            
            // Modify body if needed
            if response.status == StatusCode::OK {
                // Can inspect or modify response.body
            }
        }
        Ok(())
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#when-response-might-be-none" id="when-response-might-be-none"><h3>When Response Might Be None</h3></a>
<p>The response field will be <code>None</code> in rare cases:</p>
<ul>
<li>If a panic occurred before the response was set</li>
<li>If middleware or handler failed to set any response</li>
</ul>
<p>In practice, the framework ensures a response is always set, even for errors.</p>
<a class="header" href="print.html#important-notes-1" id="important-notes-1"><h3>Important Notes</h3></a>
<ol>
<li><strong>InboundAction::Stop</strong> - Uses the response set on context via helpers like <code>ctx.json()</code>, <code>ctx.throw403()</code>, etc.</li>
<li><strong>Handler Responses</strong> - Controllers set response via <code>ctx.json()</code>, <code>ctx.view()</code>, etc.</li>
<li><strong>Error Responses</strong> - Error methods like <code>ctx.throw404()</code> also set the response</li>
<li><strong>Middleware Order</strong> - Outbound middleware runs in reverse order of inbound</li>
<li><strong>Context Initialization</strong> - Context now initializes with a default 200 OK response, enabling response helpers everywhere</li>
</ol>
<a class="header" href="print.html#advanced-patterns" id="advanced-patterns"><h2>Advanced Patterns</h2></a>
<a class="header" href="print.html#conditional-middleware" id="conditional-middleware"><h3>Conditional Middleware</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use async_trait::async_trait;

#[async_trait]
impl InboundMiddleware for ApiAuthMiddleware {
    fn should_run(&amp;self, ctx: &amp;Context) -&gt; bool {
        // Only run for API routes
        ctx.request.uri.starts_with(&quot;/api/&quot;)
    }
    
    async fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        // API authentication logic
        Ok(InboundAction::Continue)
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#state-sharing-between-phases" id="state-sharing-between-phases"><h3>State Sharing Between Phases</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use async_trait::async_trait;

#[async_trait]
impl InboundMiddleware for MetricsMiddleware {
    async fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        // Store request data for metrics
        ctx.set(&quot;metrics_start&quot;, Instant::now());
        ctx.set(&quot;metrics_path&quot;, ctx.request.uri.clone());
        
        Ok(InboundAction::Capture)
    }
}

#[async_trait]
impl OutboundMiddleware for MetricsMiddleware {
    async fn process_response(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
        if let Some(start) = ctx.get::&lt;Instant&gt;(&quot;metrics_start&quot;) {
            let path = ctx.get::&lt;String&gt;(&quot;metrics_path&quot;).unwrap_or_default();
            let duration = start.elapsed();
            
            // Get status from response
            let status = ctx.response.as_ref()
                .map(|r| r.status.as_u16())
                .unwrap_or(500);
            
            // Record metrics
            record_metric(&amp;path, status, duration);
        }
        Ok(())
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#early-response-pattern" id="early-response-pattern"><h3>Early Response Pattern</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use async_trait::async_trait;

#[async_trait]
impl InboundMiddleware for CacheMiddleware {
    async fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        let cache_key = generate_cache_key(&amp;ctx.request);
        
        if let Some(cached) = self.cache.get(&amp;cache_key) {
            // Return cached response immediately
            ctx.set_response(cached);
            return Ok(InboundAction::Stop);
        }
        
        // Store key for outbound phase
        ctx.set(&quot;cache_key&quot;, cache_key);
        Ok(InboundAction::Capture)
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#testing-middleware" id="testing-middleware"><h2>Testing Middleware</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use rustf::http::Request;
    use rustf::views::ViewEngine;
    use std::sync::Arc;
    
    #[tokio::test]
    async fn test_auth_middleware() {
        let middleware = AuthMiddleware::new(&quot;admin&quot;);
        
        // Create test context
        let request = Request::default();
        let views = Arc::new(ViewEngine::from_directory(&quot;views&quot;));
        let mut ctx = Context::new(request, views);
        
        // Test without auth
        let action = middleware.process_request(&amp;mut ctx).await.unwrap();
        assert!(matches!(action, InboundAction::Stop));
        // Check that response was set on context
        assert!(ctx.response.is_some());
        
        // Test with auth
        ctx.session_set(&quot;user&quot;, User { role: &quot;admin&quot;.into() });
        let action = middleware.process_request(&amp;mut ctx).await.unwrap();
        assert!(matches!(action, InboundAction::Continue));
    }
    
    #[tokio::test]
    async fn test_outbound_middleware() {
        let middleware = CompressionMiddleware;
        
        // Create test context with response
        let request = Request::default();
        let views = Arc::new(ViewEngine::from_directory(&quot;views&quot;));
        let mut ctx = Context::new(request, views);
        
        // Process response
        middleware.process_response(&amp;mut ctx).await.unwrap();
        
        // Verify headers were added
        if let Some(response) = &amp;ctx.response {
            let has_encoding = response.headers.iter()
                .any(|(k, _)| k == &quot;Content-Encoding&quot;);
            assert!(has_encoding);
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#best-practices-7" id="best-practices-7"><h2>Best Practices</h2></a>
<ol>
<li>
<p><strong>Use appropriate phase</strong>:</p>
<ul>
<li>Input validation â†’ Inbound</li>
<li>Response headers â†’ Outbound</li>
<li>Timing/metrics â†’ Dual-phase</li>
</ul>
</li>
<li>
<p><strong>Set meaningful priorities</strong>:</p>
<ul>
<li>Security checks: -900 to -500</li>
<li>Business logic: -100 to +100</li>
<li>Response modification: +500 to +900</li>
</ul>
</li>
<li>
<p><strong>Minimize state in middleware</strong>:</p>
<ul>
<li>Use context for request-scoped data</li>
<li>Use Arc for shared immutable data</li>
</ul>
</li>
<li>
<p><strong>Handle errors gracefully</strong>:</p>
<ul>
<li>Return appropriate HTTP status codes</li>
<li>Log errors for debugging</li>
</ul>
</li>
<li>
<p><strong>Keep middleware focused</strong>:</p>
<ul>
<li>Single responsibility principle</li>
<li>Compose multiple middleware for complex logic</li>
</ul>
</li>
</ol>
<a class="header" href="print.html#migration-from-expresstotaljs" id="migration-from-expresstotaljs"><h2>Migration from Express/Total.js</h2></a>
<table><thead><tr><th> Express/Total.js </th><th> RustF Equivalent </th></tr></thead><tbody>
<tr><td> <code>app.use(middleware)</code> </td><td> <code>registry.register_inbound()</code> or <code>registry.register_dual()</code> </td></tr>
<tr><td> <code>next()</code> </td><td> <code>Ok(InboundAction::Continue)</code> </td></tr>
<tr><td> <code>res.send()</code> in middleware </td><td> Set response on context, return <code>Ok(InboundAction::Stop)</code> </td></tr>
<tr><td> Error middleware </td><td> Implement error handling in middleware </td></tr>
<tr><td> Route-specific middleware </td><td> Use <code>should_run()</code> method </td></tr>
<tr><td> Middleware priority/order </td><td> Implement <code>priority()</code> method (lower = earlier) </td></tr>
<tr><td> Synchronous middleware </td><td> <strong>All middleware MUST be async in RustF</strong> </td></tr>
</tbody></table>
<a class="header" href="print.html#migration-from-old-rustf-blocking-middleware" id="migration-from-old-rustf-blocking-middleware"><h2>Migration from Old RustF Blocking Middleware</h2></a>
<p>If you have existing RustF middleware using the old blocking pattern:</p>
<a class="header" href="print.html#old-pattern-deprecated---will-cause-hangs" id="old-pattern-deprecated---will-cause-hangs"><h3>Old Pattern (DEPRECATED - Will cause hangs)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// DON'T DO THIS - Will cause application hangs
impl InboundMiddleware for MyMiddleware {
    fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        // This would use block_on internally for async operations
        let session = futures::executor::block_on(load_session()); // WRONG!
        Ok(InboundAction::Continue)
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#new-async-pattern-required" id="new-async-pattern-required"><h3>New Async Pattern (REQUIRED)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use async_trait::async_trait;

#[async_trait]
impl InboundMiddleware for MyMiddleware {
    async fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        // Properly await async operations
        let session = load_session().await?; // CORRECT!
        Ok(InboundAction::Continue)
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#key-changes" id="key-changes"><h3>Key Changes</h3></a>
<ol>
<li>Add <code>#[async_trait]</code> to all middleware implementations</li>
<li>Change <code>fn</code> to <code>async fn</code> for process methods</li>
<li>Replace any <code>block_on</code> calls with <code>.await</code></li>
<li>Ensure all I/O operations use async versions</li>
</ol>
<a class="header" href="print.html#ai-development-guidelines" id="ai-development-guidelines"><h2>AI Development Guidelines</h2></a>
<p>When developing middleware with AI assistance:</p>
<ol>
<li>
<p><strong>Always use async traits</strong>:</p>
<ul>
<li>Include <code>use async_trait::async_trait;</code> at the top</li>
<li>Add <code>#[async_trait]</code> before every middleware impl block</li>
<li>Use <code>async fn</code> for <code>process_request()</code> and <code>process_response()</code></li>
</ul>
</li>
<li>
<p><strong>Never use blocking operations</strong>:</p>
<ul>
<li><strong>CRITICAL</strong>: Never use <code>futures::executor::block_on</code> - it will hang the application</li>
<li>All I/O operations must be async (database, file system, network)</li>
<li>Session operations are async - use <code>.await</code> properly</li>
</ul>
</li>
<li>
<p><strong>Specify the phase</strong>: Clearly indicate if middleware should be inbound, outbound, or dual-phase</p>
</li>
<li>
<p><strong>Define the action</strong>: Specify when to Continue, Stop, or Capture</p>
</li>
<li>
<p><strong>Set priorities</strong>: Indicate relative execution order needs (-1000 to 1000)</p>
</li>
<li>
<p><strong>Handle errors</strong>: Specify error response formats</p>
</li>
<li>
<p><strong>Use built-in middleware</strong>: Leverage existing security middleware when applicable</p>
</li>
<li>
<p><strong>Test thoroughly</strong>:</p>
<ul>
<li>Use <code>#[tokio::test]</code> for async tests</li>
<li>Test both phases if dual-phase</li>
<li>Verify <code>.await</code> is used for all async operations</li>
</ul>
</li>
</ol>
<a class="header" href="print.html#example-ai-prompt" id="example-ai-prompt"><h3>Example AI Prompt</h3></a>
<pre><code>Create an authentication middleware that:
- Runs in the inbound phase only
- Checks for JWT token in Authorization header
- Uses async database queries to validate user
- Returns 401 if unauthorized
- Has priority -400 (after rate limiting)
- MUST use async/await pattern
</code></pre>
<a class="header" href="print.html#conclusion" id="conclusion"><h2>Conclusion</h2></a>
<p>The RustF dual-phase middleware system provides a clean, predictable architecture for request/response processing. The separation of inbound and outbound phases eliminates complex state management while maintaining the flexibility needed for sophisticated middleware implementations.</p>
<a class="header" href="print.html#rustf-session-system-documentation" id="rustf-session-system-documentation"><h1>RustF Session System Documentation</h1></a>
<a class="header" href="print.html#overview-3" id="overview-3"><h2>Overview</h2></a>
<p>RustF provides a comprehensive session management system with support for multiple storage backends, flash messages, and thread-safe concurrent access. The session system is designed to handle both persistent data and temporary flash messages with automatic expiration and cleanup.</p>
<blockquote>
<p><strong>New in 2025</strong>: Custom session storage can now be implemented via the <a href="schemas.md">Definitions System</a>, providing a simpler, convention-based approach. See <a href="print.html#custom-session-storage-via-definitions-system-recommended">Custom Session Storage via Definitions</a> for details.</p>
</blockquote>
<a class="header" href="print.html#core-components-2" id="core-components-2"><h2>Core Components</h2></a>
<a class="header" href="print.html#session-data-structure" id="session-data-structure"><h3>Session Data Structure</h3></a>
<p>The <code>Session</code> struct provides lock-free concurrent access using <code>DashMap</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Session {
    id: String,
    data: Arc&lt;DashMap&lt;String, Value&gt;&gt;,       // Persistent session data
    flash: Arc&lt;DashMap&lt;String, Value&gt;&gt;,      // Flash messages (consumed when read)
}
#}</code></pre></pre>
<a class="header" href="print.html#session-storage-backends" id="session-storage-backends"><h3>Session Storage Backends</h3></a>
<p>RustF supports multiple storage backends through the <code>SessionStorage</code> trait:</p>
<ul>
<li><strong>Memory Storage</strong> - Fast in-memory storage with automatic cleanup (implemented, default)</li>
<li><strong>Redis Storage</strong> - Persistent storage with connection pooling (implemented, built-in)</li>
<li><strong>Database Storage</strong> - Planned but not yet implemented (configuration exists)</li>
</ul>
<a class="header" href="print.html#basic-session-usage" id="basic-session-usage"><h2>Basic Session Usage</h2></a>
<a class="header" href="print.html#accessing-session-in-controllers" id="accessing-session-in-controllers"><h3>Accessing Session in Controllers</h3></a>
<p>Sessions are available through the <code>Context</code> object in controllers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

async fn login(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Set session data
    ctx.session_set(&quot;user_id&quot;, 123)?;
    ctx.session_set(&quot;username&quot;, &quot;john_doe&quot;)?;

    // Get session data
    let user_id: Option&lt;i32&gt; = ctx.session_get(&quot;user_id&quot;);
    let username: Option&lt;String&gt; = ctx.session_get(&quot;username&quot;);

    ctx.json(json!({
        &quot;message&quot;: &quot;Login successful&quot;,
        &quot;user_id&quot;: user_id,
        &quot;username&quot;: username
    }))
}

async fn logout(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Clear all session data but keep session active for tracking
    ctx.session_clear();

    // Alternative: completely destroy the session
    // ctx.session_destroy();

    ctx.flash_success(&quot;You have been logged out successfully&quot;);
    ctx.redirect(&quot;/login&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#session-data-types" id="session-data-types"><h3>Session Data Types</h3></a>
<p>Sessions support any serializable data type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Basic types
ctx.session_set(&quot;counter&quot;, 42)?;
ctx.session_set(&quot;is_admin&quot;, true)?;
ctx.session_set(&quot;email&quot;, &quot;user@example.com&quot;)?;

// Complex types
let user_data = json!({
    &quot;id&quot;: 123,
    &quot;roles&quot;: [&quot;user&quot;, &quot;moderator&quot;],
    &quot;preferences&quot;: {
        &quot;theme&quot;: &quot;dark&quot;,
        &quot;language&quot;: &quot;en&quot;
    }
});
ctx.session_set(&quot;user&quot;, user_data)?;

// Custom structs (must implement Serialize/Deserialize)
#[derive(Serialize, Deserialize)]
struct UserProfile {
    id: i32,
    name: String,
    preferences: HashMap&lt;String, String&gt;,
}

let profile = UserProfile { /* ... */ };
ctx.session_set(&quot;profile&quot;, profile)?;
#}</code></pre></pre>
<a class="header" href="print.html#flash-messages-1" id="flash-messages-1"><h2>Flash Messages</h2></a>
<p>Flash messages are temporary messages that are consumed when read, perfect for displaying one-time notifications.</p>
<a class="header" href="print.html#setting-flash-messages" id="setting-flash-messages"><h3>Setting Flash Messages</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Convenience methods for common message types
ctx.flash_success(&quot;Account created successfully!&quot;);
ctx.flash_error(&quot;Invalid credentials&quot;);
ctx.flash_info(&quot;Please verify your email&quot;);

// Custom flash messages
ctx.flash_set(&quot;warning&quot;, &quot;Your session will expire soon&quot;)?;
ctx.flash_set(&quot;custom_data&quot;, json!({&quot;type&quot;: &quot;notification&quot;, &quot;data&quot;: 123}))?;
#}</code></pre></pre>
<a class="header" href="print.html#reading-flash-messages" id="reading-flash-messages"><h3>Reading Flash Messages</h3></a>
<p>Flash messages are automatically consumed when read:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get specific flash message (consumes it)
let error_msg: Option&lt;String&gt; = ctx.flash_get(&quot;error&quot;);
let success_msg: Option&lt;String&gt; = ctx.flash_get(&quot;success&quot;);

// Get all flash messages at once (consumes all)
let all_flash: HashMap&lt;String, Value&gt; = ctx.flash_get_all();
#}</code></pre></pre>
<a class="header" href="print.html#flash-messages-in-views" id="flash-messages-in-views"><h3>Flash Messages in Views</h3></a>
<p>Flash messages are automatically included in view contexts:</p>
<pre><code class="language-html">&lt;!-- views/layouts/default.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;My App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Flash messages are available in 'flash' variable --&gt;
    @{if flash.success}
        &lt;div class=&quot;alert alert-success&quot;&gt;@{flash.success}&lt;/div&gt;
    @{fi}

    @{if flash.erro}
        &lt;div class=&quot;alert alert-error&quot;&gt;@{flash.error}&lt;/div&gt;
    @{fi}

    @{if flash.info}
        &lt;div class=&quot;alert alert-info&quot;&gt;@{flash.info}&lt;/div&gt;
    @{fi}

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<a class="header" href="print.html#session-configuration" id="session-configuration"><h2>Session Configuration</h2></a>
<a class="header" href="print.html#default-memory-storage" id="default-memory-storage"><h3>Default Memory Storage</h3></a>
<p>The default session store uses in-memory storage with automatic cleanup:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Default configuration (30 minutes timeout, 5 minutes cleanup interval)
let app = RustF::new(); // Uses MemorySessionStorage by default
#}</code></pre></pre>
<a class="header" href="print.html#custom-memory-storage" id="custom-memory-storage"><h3>Custom Memory Storage</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::session::storage::MemorySessionStorage;
use std::time::Duration;

// Custom timeout settings
let storage = MemorySessionStorage::with_timeout(
    Duration::from_secs(60 * 60),    // 1 hour session timeout
    Duration::from_secs(10 * 60)     // 10 minutes cleanup interval
);

let session_store = SessionStore::with_storage(Arc::new(storage));
#}</code></pre></pre>
<a class="header" href="print.html#redis-storage" id="redis-storage"><h3>Redis Storage</h3></a>
<p>For production environments, use Redis for persistent session storage:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::session::redis::RedisSessionStorage;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Default Redis connection (redis://localhost:6379)
    let redis_storage = RedisSessionStorage::new().await?;

    // Custom Redis configuration
    let redis_storage = RedisSessionStorage::from_url(
        &quot;redis://localhost:6379&quot;,
        &quot;myapp:session:&quot;,  // Key prefix
        20                 // Pool size
    ).await?;

    let session_store = SessionStore::with_storage(Arc::new(redis_storage));

    // Configure app with Redis sessions
    let app = RustF::new()
        .with_session_store(session_store)
        .controllers(auto_controllers!());

    app.serve(None).await
}
</code></pre></pre>
<a class="header" href="print.html#session-lifecycle-management" id="session-lifecycle-management"><h2>Session Lifecycle Management</h2></a>
<a class="header" href="print.html#standard-session-methods" id="standard-session-methods"><h3>Standard Session Methods</h3></a>
<p>RustF provides industry-standard session lifecycle methods:</p>
<table><thead><tr><th> Method </th><th> Purpose </th><th> Scope </th><th> When to Use </th></tr></thead><tbody>
<tr><td> <code>clear()</code> </td><td> Remove all data, keep session active </td><td> Memory only </td><td> Partial logout, data reset </td></tr>
<tr><td> <code>flush()</code> </td><td> Alias for <code>clear()</code> </td><td> Memory only </td><td> Laravel compatibility </td></tr>
<tr><td> <code>destroy()</code> </td><td> Mark for destruction, clear data </td><td> Memory only </td><td> Local cleanup </td></tr>
<tr><td> <code>regenerate_id()</code> </td><td> New ID, keep data </td><td> Memory only </td><td> Security after login </td></tr>
</tbody></table>
<a class="header" href="print.html#sessionstore-methods-with-storage" id="sessionstore-methods-with-storage"><h3>SessionStore Methods (with Storage)</h3></a>
<table><thead><tr><th> Method </th><th> Purpose </th><th> Scope </th><th> When to Use </th></tr></thead><tbody>
<tr><td> <code>destroy_session()</code> </td><td> Complete removal </td><td> Memory + Storage </td><td> Full logout, security breach </td></tr>
<tr><td> <code>regenerate_session_id()</code> </td><td> New ID + storage update </td><td> Memory + Storage </td><td> Session fixation protection </td></tr>
<tr><td> <code>clear_session()</code> </td><td> Clear data, keep in storage </td><td> Memory + Storage </td><td> Reset user data </td></tr>
</tbody></table>
<a class="header" href="print.html#usage-examples" id="usage-examples"><h3>Usage Examples</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Partial logout - clear data but keep session for analytics
ctx.session_clear();

// Complete logout - remove session entirely
// (requires access to SessionStore)
session_store.destroy_session(&amp;session_id).await?;

// Security after login - regenerate ID to prevent fixation
session.regenerate_id();

// Or with storage backend update
if let Some(new_session) = session_store.regenerate_session_id(&amp;old_id).await? {
    // Session ID changed, update any client-side references
    log::info!(&quot;New session ID: {}&quot;, new_session.id());
}
#}</code></pre></pre>
<a class="header" href="print.html#session-security" id="session-security"><h2>Session Security</h2></a>
<a class="header" href="print.html#session-id-generation" id="session-id-generation"><h3>Session ID Generation</h3></a>
<p>Session IDs are cryptographically secure 32-character alphanumeric strings:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Automatically generated for each new session
let session_id = storage.generate_id(); // e.g., &quot;a7b8c9d0e1f2g3h4i5j6k7l8m9n0o1p2&quot;
#}</code></pre></pre>
<a class="header" href="print.html#session-expiration" id="session-expiration"><h3>Session Expiration</h3></a>
<p>Sessions automatically expire based on last access time:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Configure session timeout
let storage = MemorySessionStorage::with_timeout(
    Duration::from_secs(30 * 60), // 30 minutes of inactivity
    Duration::from_secs(5 * 60)   // Cleanup every 5 minutes
);
#}</code></pre></pre>
<a class="header" href="print.html#session-cleanup" id="session-cleanup"><h3>Session Cleanup</h3></a>
<p>Both storage backends handle automatic cleanup:</p>
<ul>
<li><strong>Memory Storage</strong>: Background task removes expired sessions</li>
<li><strong>Redis Storage</strong>: Redis TTL automatically expires sessions</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Manual cleanup (returns number of sessions cleaned)
let cleaned_count = session_store.cleanup_expired().await?;
log::info!(&quot;Cleaned up {} expired sessions&quot;, cleaned_count);
#}</code></pre></pre>
<a class="header" href="print.html#custom-session-storage-via-definitions-system-recommended" id="custom-session-storage-via-definitions-system-recommended"><h2>Custom Session Storage via Definitions System (Recommended)</h2></a>
<p>RustF now provides a modern, convention-based approach to implementing custom session storage through the Definitions System. This is the <strong>recommended method</strong> for adding database or custom storage backends.</p>
<a class="header" href="print.html#quick-setup-with-definitions" id="quick-setup-with-definitions"><h3>Quick Setup with Definitions</h3></a>
<a class="header" href="print.html#step-1-create-session-storage-definition" id="step-1-create-session-storage-definition"><h4>Step 1: Create Session Storage Definition</h4></a>
<p>Create <code>src/definitions/session_storage.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::definitions::Definitions;
use rustf::session::{SessionStorage, SessionData, StorageStats};
use rustf::config::SessionConfig;
use rustf::error::Result;
use async_trait::async_trait;
use sqlx::PgPool;
use std::sync::Arc;
use std::time::Duration;

/// Install function called by auto-discovery
/// This MUST be present in every definitions file
pub fn install(defs: &amp;mut Definitions) {
    log::info!(&quot;Installing custom session storage from definitions&quot;);
    defs.set_session_storage_factory(create_session_storage);
}

/// Factory function that creates our custom session storage
/// This is called by the framework when initializing sessions
fn create_session_storage(
    config: &amp;SessionConfig
) -&gt; Result&lt;Arc&lt;dyn SessionStorage&gt;&gt; {
    // Get database URL from environment or config
    let database_url = std::env::var(&quot;DATABASE_URL&quot;)
        .unwrap_or_else(|_| &quot;postgresql://localhost/myapp&quot;.to_string());

    // Create your custom storage
    let storage = PostgresSessionStorage::new(&amp;database_url)?;
    Ok(Arc::new(storage))
}

// Your SessionStorage implementation (see detailed example below)
pub struct PostgresSessionStorage {
    pool: PgPool,
}

// ... implement SessionStorage trait (see complete example in previous section)
#}</code></pre></pre>
<a class="header" href="print.html#step-2-use-auto-discovery" id="step-2-use-auto-discovery"><h4>Step 2: Use Auto-Discovery</h4></a>
<p>In your <code>main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">#[rustf::auto_discover]
#[tokio::main]
async fn main() -&gt; rustf::Result&lt;()&gt; {
    let app = RustF::new()
        .definitions_from(auto_definitions!())  // Automatically finds session_storage.rs
        .controllers(auto_controllers!());

    // Your custom session storage is now active!
    app.start().await
}
</code></pre></pre>
<p>That's it! Your custom session storage is automatically discovered and integrated.</p>
<p><strong>Important</strong>: The <code>install()</code> function is mandatory - it's how the auto-discovery system knows what to register.</p>
<a class="header" href="print.html#benefits-of-the-definitions-approach" id="benefits-of-the-definitions-approach"><h3>Benefits of the Definitions Approach</h3></a>
<ol>
<li><strong>Zero Configuration</strong> - Just create the file in the right place</li>
<li><strong>Auto-Discovery</strong> - No manual registration needed</li>
<li><strong>Convention-Based</strong> - Follow the pattern, it just works</li>
<li><strong>Type-Safe</strong> - Compile-time checking of your implementation</li>
<li><strong>Testable</strong> - Easy to unit test in isolation</li>
</ol>
<a class="header" href="print.html#complete-example-postgresql-storage-via-definitions" id="complete-example-postgresql-storage-via-definitions"><h3>Complete Example: PostgreSQL Storage via Definitions</h3></a>
<p>Here's a complete, production-ready implementation using the definitions system:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/definitions/session_storage.rs
use rustf::definitions::Definitions;
use rustf::session::{SessionStorage, SessionData, StorageStats};
use rustf::config::SessionConfig;
use rustf::error::Result;
use async_trait::async_trait;
use sqlx::{PgPool, postgres::PgPoolOptions};
use std::sync::Arc;
use std::time::Duration;
use std::collections::HashMap;
use serde_json;

/// Install function called by auto-discovery - REQUIRED!
pub fn install(defs: &amp;mut Definitions) {
    log::info!(&quot;Installing PostgreSQL session storage from definitions&quot;);
    defs.set_session_storage_factory(create_session_storage);
}

/// Factory function for session storage
fn create_session_storage(
    config: &amp;SessionConfig
) -&gt; Result&lt;Arc&lt;dyn SessionStorage&gt;&gt; {
    // Configuration can come from multiple sources
    let database_url = std::env::var(&quot;DATABASE_URL&quot;)
        .or_else(|_| std::env::var(&quot;SESSION_DATABASE_URL&quot;))
        .unwrap_or_else(|_| &quot;postgresql://localhost/myapp&quot;.to_string());

    // Create storage with configuration
    let storage = PostgresSessionStorage::new(
        &amp;database_url,
        config.idle_timeout.as_secs(),
        config.cookie_name.clone()
    )?;

    Ok(Arc::new(storage))
}

pub struct PostgresSessionStorage {
    pool: PgPool,
    default_ttl_seconds: u64,
    table_name: String,
}

impl PostgresSessionStorage {
    pub fn new(
        database_url: &amp;str,
        default_ttl_seconds: u64,
        cookie_name: String
    ) -&gt; Result&lt;Self&gt; {
        // Create connection pool synchronously for the factory
        let pool = futures::executor::block_on(async {
            PgPoolOptions::new()
                .max_connections(5)
                .connect(database_url)
                .await
        }).map_err(|e| rustf::error::Error::internal(
            format!(&quot;Failed to connect to database: {}&quot;, e)
        ))?;

        // Create sessions table
        futures::executor::block_on(async {
            sqlx::query(&amp;format!(
                &quot;CREATE TABLE IF NOT EXISTS sessions_{} (
                    id VARCHAR(64) PRIMARY KEY,
                    data JSONB NOT NULL,
                    expires_at TIMESTAMP NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    ip_address INET,
                    user_agent TEXT
                )&quot;,
                sanitize_table_name(&amp;cookie_name)
            ))
            .execute(&amp;pool)
            .await
        }).map_err(|e| rustf::error::Error::internal(
            format!(&quot;Failed to create sessions table: {}&quot;, e)
        ))?;

        // Create indexes for performance
        futures::executor::block_on(async {
            sqlx::query(&amp;format!(
                &quot;CREATE INDEX IF NOT EXISTS idx_sessions_{}_expires
                 ON sessions_{} (expires_at)&quot;,
                sanitize_table_name(&amp;cookie_name),
                sanitize_table_name(&amp;cookie_name)
            ))
            .execute(&amp;pool)
            .await
        }).ok(); // Index creation failure is non-fatal

        Ok(Self {
            pool,
            default_ttl_seconds,
            table_name: format!(&quot;sessions_{}&quot;, sanitize_table_name(&amp;cookie_name)),
        })
    }
}

#[async_trait]
impl SessionStorage for PostgresSessionStorage {
    async fn get(&amp;self, session_id: &amp;str) -&gt; Result&lt;Option&lt;SessionData&gt;&gt; {
        let query = format!(
            &quot;SELECT data FROM {}
             WHERE id = $1 AND expires_at &gt; NOW()&quot;,
            self.table_name
        );

        let row = sqlx::query(&amp;query)
            .bind(session_id)
            .fetch_optional(&amp;self.pool)
            .await
            .map_err(|e| rustf::error::Error::internal(
                format!(&quot;Failed to get session: {}&quot;, e)
            ))?;

        match row {
            Some(row) =&gt; {
                let data: serde_json::Value = row.try_get(&quot;data&quot;)
                    .map_err(|e| rustf::error::Error::internal(
                        format!(&quot;Failed to deserialize session: {}&quot;, e)
                    ))?;

                let mut session_data: SessionData = serde_json::from_value(data)
                    .map_err(|e| rustf::error::Error::internal(
                        format!(&quot;Invalid session data format: {}&quot;, e)
                    ))?;

                // Update last accessed time
                session_data.touch();

                // Update in database (fire and forget for performance)
                let update_query = format!(
                    &quot;UPDATE {} SET updated_at = NOW() WHERE id = $1&quot;,
                    self.table_name
                );

                let _ = sqlx::query(&amp;update_query)
                    .bind(session_id)
                    .execute(&amp;self.pool)
                    .await;

                Ok(Some(session_data))
            }
            None =&gt; Ok(None)
        }
    }

    async fn set(
        &amp;self,
        session_id: &amp;str,
        data: &amp;SessionData,
        ttl: Duration
    ) -&gt; Result&lt;()&gt; {
        let expires_at = chrono::Utc::now() +
            chrono::Duration::seconds(ttl.as_secs() as i64);

        let json_data = serde_json::to_value(data)
            .map_err(|e| rustf::error::Error::internal(
                format!(&quot;Failed to serialize session: {}&quot;, e)
            ))?;

        let query = format!(
            &quot;INSERT INTO {} (id, data, expires_at, updated_at)
             VALUES ($1, $2, $3, NOW())
             ON CONFLICT (id) DO UPDATE
             SET data = $2, expires_at = $3, updated_at = NOW()&quot;,
            self.table_name
        );

        sqlx::query(&amp;query)
            .bind(session_id)
            .bind(json_data)
            .bind(expires_at)
            .execute(&amp;self.pool)
            .await
            .map_err(|e| rustf::error::Error::internal(
                format!(&quot;Failed to save session: {}&quot;, e)
            ))?;

        Ok(())
    }

    async fn delete(&amp;self, session_id: &amp;str) -&gt; Result&lt;()&gt; {
        let query = format!(
            &quot;DELETE FROM {} WHERE id = $1&quot;,
            self.table_name
        );

        sqlx::query(&amp;query)
            .bind(session_id)
            .execute(&amp;self.pool)
            .await
            .map_err(|e| rustf::error::Error::internal(
                format!(&quot;Failed to delete session: {}&quot;, e)
            ))?;

        Ok(())
    }

    async fn exists(&amp;self, session_id: &amp;str) -&gt; Result&lt;bool&gt; {
        let query = format!(
            &quot;SELECT 1 FROM {}
             WHERE id = $1 AND expires_at &gt; NOW()
             LIMIT 1&quot;,
            self.table_name
        );

        let exists = sqlx::query(&amp;query)
            .bind(session_id)
            .fetch_optional(&amp;self.pool)
            .await
            .map_err(|e| rustf::error::Error::internal(
                format!(&quot;Failed to check session existence: {}&quot;, e)
            ))?
            .is_some();

        Ok(exists)
    }

    async fn cleanup_expired(&amp;self) -&gt; Result&lt;usize&gt; {
        let query = format!(
            &quot;DELETE FROM {} WHERE expires_at &lt;= NOW()&quot;,
            self.table_name
        );

        let result = sqlx::query(&amp;query)
            .execute(&amp;self.pool)
            .await
            .map_err(|e| rustf::error::Error::internal(
                format!(&quot;Failed to cleanup sessions: {}&quot;, e)
            ))?;

        Ok(result.rows_affected() as usize)
    }

    fn backend_name(&amp;self) -&gt; &amp;'static str {
        &quot;postgresql-definitions&quot;
    }

    async fn stats(&amp;self) -&gt; Result&lt;StorageStats&gt; {
        let total_query = format!(
            &quot;SELECT COUNT(*) as count FROM {}&quot;,
            self.table_name
        );

        let active_query = format!(
            &quot;SELECT COUNT(*) as count FROM {} WHERE expires_at &gt; NOW()&quot;,
            self.table_name
        );

        let total: i64 = sqlx::query(&amp;total_query)
            .fetch_one(&amp;self.pool)
            .await
            .and_then(|row| row.try_get(&quot;count&quot;))
            .unwrap_or(0);

        let active: i64 = sqlx::query(&amp;active_query)
            .fetch_one(&amp;self.pool)
            .await
            .and_then(|row| row.try_get(&quot;count&quot;))
            .unwrap_or(0);

        Ok(StorageStats {
            total_sessions: total as usize,
            active_sessions: active as usize,
            expired_sessions: (total - active) as usize,
            backend_metrics: HashMap::new(),
        })
    }
}

fn sanitize_table_name(name: &amp;str) -&gt; String {
    name.chars()
        .filter(|c| c.is_alphanumeric() || *c == '_')
        .collect::&lt;String&gt;()
        .to_lowercase()
}
#}</code></pre></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>The <code>install(defs: &amp;mut Definitions)</code> function is mandatory for auto-discovery</li>
<li>The factory function (<code>create_session_storage</code>) should be private since it's registered via <code>install()</code></li>
<li>The factory receives <code>&amp;SessionConfig</code> from <code>rustf::config::SessionConfig</code>, not the session manager's config</li>
</ul>
<a class="header" href="print.html#how-it-works" id="how-it-works"><h3>How It Works</h3></a>
<ol>
<li><strong>Auto-Discovery</strong>: The <code>auto_definitions!()</code> macro finds <code>session_storage.rs</code> with an <code>install()</code> function</li>
<li><strong>Registration</strong>: The <code>install()</code> function is called and registers your factory via <code>defs.set_session_storage_factory()</code></li>
<li><strong>Factory Pattern</strong>: When sessions are initialized, RustF calls your registered factory function</li>
<li><strong>Integration</strong>: Your storage replaces the default memory storage automatically</li>
<li><strong>Configuration</strong>: The factory receives <code>SessionConfig</code> for customization</li>
</ol>
<a class="header" href="print.html#when-to-use-definitions-vs-manual-integration" id="when-to-use-definitions-vs-manual-integration"><h3>When to Use Definitions vs Manual Integration</h3></a>
<p><strong>Use Definitions (Recommended) When:</strong></p>
<ul>
<li>You want the simplest setup</li>
<li>Following conventions is acceptable</li>
<li>You're building a standard application</li>
<li>You want auto-discovery benefits</li>
</ul>
<p><strong>Use Manual Integration When:</strong></p>
<ul>
<li>You need complex initialization logic</li>
<li>You want full control over the storage lifecycle</li>
<li>You're building a library or framework</li>
<li>You have special requirements that don't fit the convention</li>
</ul>
<p>For more details on the Definitions System, see <a href="schemas.md">Schemas &amp; Definitions</a>.</p>
<a class="header" href="print.html#advanced-usage" id="advanced-usage"><h2>Advanced Usage</h2></a>
<a class="header" href="print.html#session-management-methods" id="session-management-methods"><h3>Session Management Methods</h3></a>
<p>RustF provides comprehensive session management methods:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn session_management(ctx: Context) -&gt; Result&lt;Response&gt; {
    let session = &amp;ctx.session;

    // Basic session operations
    session.set(&quot;user_id&quot;, 123)?;
    let user_id: Option&lt;i32&gt; = session.get(&quot;user_id&quot;);
    let removed_value = session.remove(&quot;temp_data&quot;);

    // Session lifecycle management
    session.clear();        // Clear all data but keep session active
    session.flush();        // Alias for clear() (Laravel compatibility)
    session.destroy();      // Mark session for destruction

    // Session information
    let session_id = session.id();
    let is_empty = session.is_empty();
    let data_count = session.data_count();
    let flash_count = session.flash_count();

    ctx.json(json!({
        &quot;session_id&quot;: session_id,
        &quot;is_empty&quot;: is_empty,
        &quot;data_entries&quot;: data_count,
        &quot;flash_messages&quot;: flash_count
    }))
}

// Security: Session ID regeneration for fixation protection
async fn regenerate_session(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Get mutable reference to session
    let session = &amp;mut ctx.session;

    // Regenerate session ID while keeping all data
    session.regenerate_id();

    ctx.flash_info(&quot;Session ID regenerated for security&quot;);
    ctx.json(json!({&quot;new_session_id&quot;: session.id()}))
}

// Context convenience methods
async fn context_session_methods(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Convenience methods available on Context
    ctx.session_set(&quot;key&quot;, &quot;value&quot;)?;
    let value: Option&lt;String&gt; = ctx.session_get(&quot;key&quot;);
    ctx.session_clear();     // Clear all session data
    ctx.session_flush();     // Alias for clear
    ctx.session_destroy();   // Mark for destruction

    ctx.json(json!({&quot;status&quot;: &quot;ok&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#session-store-operations" id="session-store-operations"><h3>Session Store Operations</h3></a>
<p>Perform operations on the session store itself:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::session::{SessionStore, SessionData};

async fn session_store_management(session_store: &amp;SessionStore) -&gt; Result&lt;()&gt; {
    let session_id = &quot;user_123_session&quot;;

    // Basic session store operations
    let exists = session_store.exists(session_id).await?;
    let session_opt = session_store.get(session_id).await?;

    // Complete session destruction (removes from storage)
    session_store.destroy_session(session_id).await?;

    // Regenerate session ID with storage backend updates
    if let Some(new_session) = session_store.regenerate_session_id(session_id).await? {
        log::info!(&quot;Session regenerated: {}&quot;, new_session.id());
    }

    // Clear session data but keep it in storage
    session_store.clear_session(session_id).await?;

    // Storage statistics and monitoring
    let stats = session_store.stats().await?;
    log::info!(&quot;Total sessions: {}, Active: {}&quot;,
               stats.total_sessions,
               stats.active_sessions);

    let backend = session_store.backend_name();
    log::info!(&quot;Using {} storage backend&quot;, backend);

    Ok(())
}
#}</code></pre></pre>
<a class="header" href="print.html#custom-storage-backend-manual-approach" id="custom-storage-backend-manual-approach"><h3>Custom Storage Backend (Manual Approach)</h3></a>
<blockquote>
<p><strong>Note</strong>: The Definitions System approach (described above) is now the recommended way to implement custom session storage. The manual approach below is still supported for advanced use cases requiring full control.</p>
</blockquote>
<a class="header" href="print.html#understanding-sessiondata-structure" id="understanding-sessiondata-structure"><h4>Understanding SessionData Structure</h4></a>
<p>Before implementing custom storage, understand the <code>SessionData</code> structure:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use serde::{Serialize, Deserialize};
use serde_json::Value;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionData {
    /// Session data as JSON object
    pub data: Value,
    /// Flash messages as JSON object
    pub flash: Value,
    /// Security fingerprint containing IP and user agent info
    pub fingerprint: Option&lt;SessionFingerprint&gt;,
    /// Session creation timestamp (Unix seconds)
    pub created_at: u64,
    /// Last accessed timestamp (Unix seconds)
    pub last_accessed: u64,
    /// Absolute timeout timestamp (Unix seconds)
    pub absolute_timeout: u64,
    /// Current privilege level (for security escalation tracking)
    pub privilege_level: u32,
}

impl SessionData {
    /// Update last accessed time to current timestamp
    pub fn touch(&amp;mut self) {
        self.last_accessed = unix_timestamp();
    }

    /// Check if session has expired based on dual timeout
    pub fn is_expired(&amp;self, idle_timeout_secs: u64) -&gt; bool {
        let now = unix_timestamp();

        // Check absolute timeout
        if now &gt; self.absolute_timeout {
            return true;
        }

        // Check idle timeout
        (now - self.last_accessed) &gt; idle_timeout_secs
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#understanding-sessionfingerprint-structure" id="understanding-sessionfingerprint-structure"><h4>Understanding SessionFingerprint Structure</h4></a>
<p>The <code>SessionFingerprint</code> structure captures client information for session security validation:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionFingerprint {
    /// IP prefix for soft validation (first 3 octets for IPv4, first 3 segments for IPv6)
    pub ip_prefix: String,
    /// Hashed user agent for privacy (stored as u64 hash, not plaintext)
    pub user_agent_hash: u64,
    /// Original creation IP address for audit logging
    pub created_ip: String,
    /// Creation timestamp (Unix seconds)
    pub created_at: u64,
}

impl SessionFingerprint {
    /// Create fingerprint from request (called automatically by session middleware)
    pub fn from_request(request: &amp;Request) -&gt; Self {
        let created_at = unix_timestamp();
        let created_ip = request.client_ip();  // Supports X-Forwarded-For and X-Real-IP
        let ip_prefix = Self::extract_ip_prefix(&amp;created_ip);
        let user_agent_hash = Self::hash_user_agent(request.user_agent());

        Self {
            ip_prefix,
            user_agent_hash,
            created_ip,
            created_at,
        }
    }

    /// Validate fingerprint against request based on FingerprintMode
    pub fn validate(&amp;self, request: &amp;Request, mode: FingerprintMode) -&gt; bool {
        // Implementation varies based on mode (see FingerprintMode below)
    }
}
#}</code></pre></pre>
<p><strong>Important Notes:</strong></p>
<ul>
<li>IP address and user agent are <strong>automatically captured</strong> when a session is created</li>
<li>User agent is stored as a hash for privacy protection</li>
<li>The <code>created_ip</code> field stores the full original IP for audit purposes</li>
<li>The <code>ip_prefix</code> is used for soft validation (allows some IP mobility)</li>
</ul>
<a class="header" href="print.html#fingerprintmode-enum" id="fingerprintmode-enum"><h4>FingerprintMode Enum</h4></a>
<p>Controls how strictly sessions are bound to client characteristics:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum FingerprintMode {
    /// No fingerprint validation - sessions work from any IP/browser
    Disabled,

    /// Soft validation (default) - validates IP prefix + user agent hash
    /// Allows mobility within same subnet (e.g., WiFi to cellular on same network)
    Soft,

    /// Strict validation - exact IP and user agent must match
    /// Maximum security but may cause issues with mobile users or dynamic IPs
    Strict,
}

impl Default for FingerprintMode {
    fn default() -&gt; Self {
        Self::Soft  // Balanced security and usability
    }
}
#}</code></pre></pre>
<p><strong>Validation Behavior:</strong></p>
<ul>
<li><strong>Disabled</strong>: No validation, session works from anywhere</li>
<li><strong>Soft</strong>: IP must match first 3 octets (IPv4) or first 3 segments (IPv6), and user agent hash must match</li>
<li><strong>Strict</strong>: Exact IP address and user agent hash must match</li>
</ul>
<p><strong>Accessing Fingerprint Data in Controllers:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn show_session_info(ctx: Context) -&gt; Result&lt;Response&gt; {
    if let Some(session) = ctx.session() {
        // Get the fingerprint if it exists
        if let Some(fingerprint) = session.fingerprint() {
            // Access captured client information
            let created_ip = &amp;fingerprint.created_ip;
            let created_at = fingerprint.created_at;
            let ip_prefix = &amp;fingerprint.ip_prefix;

            return ctx.json(json!({
                &quot;session_id&quot;: session.id(),
                &quot;created_from_ip&quot;: created_ip,
                &quot;created_at&quot;: created_at,
                &quot;ip_prefix&quot;: ip_prefix,
                // Note: user_agent_hash is a u64, not human-readable
                &quot;user_agent_hash&quot;: fingerprint.user_agent_hash,
            }));
        }
    }

    ctx.json(json!({&quot;error&quot;: &quot;No session found&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#complete-database-storage-implementation-with-sqlx" id="complete-database-storage-implementation-with-sqlx"><h4>Complete Database Storage Implementation with SQLx</h4></a>
<p>Here's a complete working example using SQLx for PostgreSQL:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use async_trait::async_trait;
use rustf::session::{SessionStorage, SessionData, StorageStats};
use sqlx::{PgPool, Row};
use std::time::Duration;
use serde_json;

pub struct DatabaseSessionStorage {
    pool: PgPool,
    table_name: String,
}

impl DatabaseSessionStorage {
    pub async fn new(database_url: &amp;str) -&gt; Result&lt;Self&gt; {
        // Create connection pool
        let pool = PgPool::connect(database_url).await?;

        // Create sessions table if not exists
        sqlx::query(&amp;format!(r#&quot;
            CREATE TABLE IF NOT EXISTS sessions (
                id VARCHAR(64) PRIMARY KEY,
                data JSONB NOT NULL,
                expires_at TIMESTAMP NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        &quot;#)).execute(&amp;pool).await?;

        // Create index for cleanup
        sqlx::query(&quot;CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at)&quot;)
            .execute(&amp;pool).await?;

        Ok(Self {
            pool,
            table_name: &quot;sessions&quot;.to_string(),
        })
    }
}

#[async_trait]
impl SessionStorage for DatabaseSessionStorage {
    async fn get(&amp;self, session_id: &amp;str) -&gt; Result&lt;Option&lt;SessionData&gt;&gt; {
        let query = format!(
            &quot;SELECT data FROM {} WHERE id = $1 AND expires_at &gt; NOW()&quot;,
            self.table_name
        );

        let row = sqlx::query(&amp;query)
            .bind(session_id)
            .fetch_optional(&amp;self.pool)
            .await?;

        match row {
            Some(row) =&gt; {
                let data: serde_json::Value = row.get(&quot;data&quot;);
                let mut session_data: SessionData = serde_json::from_value(data)?;

                // Update last accessed time
                session_data.touch();

                // Update in database
                let update_query = format!(
                    &quot;UPDATE {} SET updated_at = NOW() WHERE id = $1&quot;,
                    self.table_name
                );
                sqlx::query(&amp;update_query)
                    .bind(session_id)
                    .execute(&amp;self.pool)
                    .await?;

                Ok(Some(session_data))
            }
            None =&gt; Ok(None),
        }
    }

    async fn set(&amp;self, session_id: &amp;str, data: &amp;SessionData, ttl: Duration) -&gt; Result&lt;()&gt; {
        let expires_at = chrono::Utc::now() + chrono::Duration::seconds(ttl.as_secs() as i64);
        let json_data = serde_json::to_value(data)?;

        let query = format!(r#&quot;
            INSERT INTO {} (id, data, expires_at, updated_at)
            VALUES ($1, $2, $3, NOW())
            ON CONFLICT (id) DO UPDATE
            SET data = $2, expires_at = $3, updated_at = NOW()
        &quot;#, self.table_name);

        sqlx::query(&amp;query)
            .bind(session_id)
            .bind(json_data)
            .bind(expires_at)
            .execute(&amp;self.pool)
            .await?;

        Ok(())
    }

    async fn delete(&amp;self, session_id: &amp;str) -&gt; Result&lt;()&gt; {
        let query = format!(&quot;DELETE FROM {} WHERE id = $1&quot;, self.table_name);
        sqlx::query(&amp;query)
            .bind(session_id)
            .execute(&amp;self.pool)
            .await?;
        Ok(())
    }

    async fn exists(&amp;self, session_id: &amp;str) -&gt; Result&lt;bool&gt; {
        let query = format!(
            &quot;SELECT 1 FROM {} WHERE id = $1 AND expires_at &gt; NOW()&quot;,
            self.table_name
        );

        let exists = sqlx::query(&amp;query)
            .bind(session_id)
            .fetch_optional(&amp;self.pool)
            .await?
            .is_some();

        Ok(exists)
    }

    async fn cleanup_expired(&amp;self) -&gt; Result&lt;usize&gt; {
        let query = format!(&quot;DELETE FROM {} WHERE expires_at &lt;= NOW()&quot;, self.table_name);
        let result = sqlx::query(&amp;query)
            .execute(&amp;self.pool)
            .await?;

        Ok(result.rows_affected() as usize)
    }

    fn backend_name(&amp;self) -&gt; &amp;'static str {
        &quot;database&quot;
    }

    async fn stats(&amp;self) -&gt; Result&lt;StorageStats&gt; {
        let total_query = format!(&quot;SELECT COUNT(*) as count FROM {}&quot;, self.table_name);
        let active_query = format!(
            &quot;SELECT COUNT(*) as count FROM {} WHERE expires_at &gt; NOW()&quot;,
            self.table_name
        );

        let total: i64 = sqlx::query(&amp;total_query)
            .fetch_one(&amp;self.pool)
            .await?
            .get(&quot;count&quot;);

        let active: i64 = sqlx::query(&amp;active_query)
            .fetch_one(&amp;self.pool)
            .await?
            .get(&quot;count&quot;);

        Ok(StorageStats {
            total_sessions: total as usize,
            active_sessions: active as usize,
            expired_sessions: (total - active) as usize,
            backend_metrics: HashMap::new(),
        })
    }
}

// Integration (see &quot;How Session Storage Integration Works&quot; section for details)
// You'll use this storage with SessionMiddleware::with_storage()
#}</code></pre></pre>
<a class="header" href="print.html#complete-working-example-putting-it-all-together" id="complete-working-example-putting-it-all-together"><h2>Complete Working Example: Putting It All Together</h2></a>
<p>Here's a complete, working example that shows exactly how to integrate custom database storage:</p>
<pre><pre class="playpen"><code class="language-rust">// main.rs
use rustf::prelude::*;
use rustf::middleware::builtin::session::SessionMiddleware;
use rustf::session::{SessionStorage, SessionData, StorageStats, manager::SessionConfig};
use rustf::config::AppConfig;
use async_trait::async_trait;
use sqlx::PgPool;
use std::sync::Arc;
use std::time::Duration;
use serde_json;

// Your custom database storage implementation
pub struct DatabaseSessionStorage {
    pool: PgPool,
}

impl DatabaseSessionStorage {
    pub async fn new(database_url: &amp;str) -&gt; Result&lt;Self&gt; {
        let pool = PgPool::connect(database_url).await?;

        // Create sessions table
        sqlx::query(
            &quot;CREATE TABLE IF NOT EXISTS sessions (
                id VARCHAR(64) PRIMARY KEY,
                data JSONB NOT NULL,
                expires_at TIMESTAMP NOT NULL
            )&quot;
        ).execute(&amp;pool).await?;

        Ok(Self { pool })
    }
}

#[async_trait]
impl SessionStorage for DatabaseSessionStorage {
    async fn get(&amp;self, session_id: &amp;str) -&gt; Result&lt;Option&lt;SessionData&gt;&gt; {
        let row = sqlx::query!(
            &quot;SELECT data FROM sessions WHERE id = $1 AND expires_at &gt; NOW()&quot;,
            session_id
        )
        .fetch_optional(&amp;self.pool)
        .await?;

        match row {
            Some(row) =&gt; {
                let mut data: SessionData = serde_json::from_value(row.data)?;
                data.touch();
                Ok(Some(data))
            }
            None =&gt; Ok(None)
        }
    }

    async fn set(&amp;self, session_id: &amp;str, data: &amp;SessionData, ttl: Duration) -&gt; Result&lt;()&gt; {
        let expires_at = chrono::Utc::now() + chrono::Duration::seconds(ttl.as_secs() as i64);
        let json_data = serde_json::to_value(data)?;

        sqlx::query!(
            &quot;INSERT INTO sessions (id, data, expires_at)
             VALUES ($1, $2, $3)
             ON CONFLICT (id) DO UPDATE
             SET data = $2, expires_at = $3&quot;,
            session_id,
            json_data,
            expires_at
        )
        .execute(&amp;self.pool)
        .await?;

        Ok(())
    }

    async fn delete(&amp;self, session_id: &amp;str) -&gt; Result&lt;()&gt; {
        sqlx::query!(&quot;DELETE FROM sessions WHERE id = $1&quot;, session_id)
            .execute(&amp;self.pool)
            .await?;
        Ok(())
    }

    async fn exists(&amp;self, session_id: &amp;str) -&gt; Result&lt;bool&gt; {
        let exists = sqlx::query!(
            &quot;SELECT 1 as exists FROM sessions WHERE id = $1 AND expires_at &gt; NOW()&quot;,
            session_id
        )
        .fetch_optional(&amp;self.pool)
        .await?
        .is_some();

        Ok(exists)
    }

    async fn cleanup_expired(&amp;self) -&gt; Result&lt;usize&gt; {
        let result = sqlx::query!(&quot;DELETE FROM sessions WHERE expires_at &lt;= NOW()&quot;)
            .execute(&amp;self.pool)
            .await?;
        Ok(result.rows_affected() as usize)
    }

    fn backend_name(&amp;self) -&gt; &amp;'static str {
        &quot;postgresql&quot;
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    env_logger::init();

    // Step 1: Load config but disable auto session
    let mut config = AppConfig::from_file(&quot;config.toml&quot;)?;
    config.session.enabled = false;  // IMPORTANT: Disable auto-creation

    // Step 2: Create RustF app without auto session
    let app = RustF::with_config(config.clone());

    // Step 3: Create your custom database storage
    let db_storage = Arc::new(
        DatabaseSessionStorage::new(&amp;config.database.url).await?
    );

    // Step 4: Configure session settings
    let session_config = SessionConfig {
        cookie_name: config.session.cookie_name,
        idle_timeout: Duration::from_secs(config.session.idle_timeout),
        absolute_timeout: Duration::from_secs(config.session.absolute_timeout),
        exempt_routes: config.session.exempt_routes,
        same_site: parse_same_site(&amp;config.session.same_site),
        enabled: true,
        ..Default::default()
    };

    // Step 5: Create session middleware with your storage
    let session_middleware = SessionMiddleware::with_storage(
        db_storage,
        session_config
    );

    // Step 6: Register everything and start
    let app = app
        .middleware_from(|registry| {
            // Register your custom session middleware
            registry.register_dual(&quot;session&quot;, session_middleware);

            // Add other middleware as needed
            registry.register_dual(&quot;cors&quot;, CorsMiddleware::new());
        })
        .controllers(auto_controllers!())
        .models(auto_models!());

    println!(&quot;ğŸš€ Server starting with PostgreSQL session storage&quot;);
    app.start().await
}

fn parse_same_site(value: &amp;str) -&gt; rustf::session::SameSite {
    match value.to_lowercase().as_str() {
        &quot;strict&quot; =&gt; rustf::session::SameSite::Strict,
        &quot;lax&quot; =&gt; rustf::session::SameSite::Lax,
        &quot;none&quot; =&gt; rustf::session::SameSite::None,
        _ =&gt; rustf::session::SameSite::Lax,
    }
}

## Session Data Serialization

Sessions use JSON serialization internally via `serde_json`:

```rust
// These types work automatically
ctx.session_set(&quot;string&quot;, &quot;Hello&quot;)?;
ctx.session_set(&quot;number&quot;, 42)?;
ctx.session_set(&quot;boolean&quot;, true)?;
ctx.session_set(&quot;array&quot;, vec![1, 2, 3])?;
ctx.session_set(&quot;object&quot;, json!({&quot;key&quot;: &quot;value&quot;}))?;

// Custom types need Serialize/Deserialize
#[derive(Serialize, Deserialize)]
struct CustomData {
    id: i32,
    name: String,
}

let custom = CustomData { id: 1, name: &quot;test&quot;.to_string() };
ctx.session_set(&quot;custom&quot;, custom)?;

let retrieved: Option&lt;CustomData&gt; = ctx.session_get(&quot;custom&quot;);
</code></pre></pre>
<a class="header" href="print.html#error-handling-2" id="error-handling-2"><h2>Error Handling</h2></a>
<p>Session operations return <code>Result&lt;T&gt;</code> for proper error handling:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn safe_session_usage(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Handle serialization errors
    match ctx.session_set(&quot;user_id&quot;, 123) {
        Ok(()) =&gt; log::info!(&quot;Session data saved&quot;),
        Err(e) =&gt; log::error!(&quot;Failed to save session: {}&quot;, e),
    }

    // Handle deserialization
    match ctx.session_get::&lt;i32&gt;(&quot;user_id&quot;) {
        Some(id) =&gt; log::info!(&quot;User ID: {}&quot;, id),
        None =&gt; log::info!(&quot;No user ID in session&quot;),
    }

    // Flash message errors are typically ignored
    let _ = ctx.flash_set(&quot;message&quot;, &quot;Hello&quot;);

    ctx.json(json!({&quot;status&quot;: &quot;ok&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#storage-backend-comparison" id="storage-backend-comparison"><h2>Storage Backend Comparison</h2></a>
<a class="header" href="print.html#memory-storage-implemented" id="memory-storage-implemented"><h3>Memory Storage (Implemented)</h3></a>
<p><strong>Pros:</strong></p>
<ul>
<li>Very fast (in-memory access)</li>
<li>No external dependencies</li>
<li>Automatic cleanup with background tasks</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Sessions lost on server restart</li>
<li>Not suitable for multi-server deployments</li>
<li>Memory usage grows with active sessions</li>
</ul>
<p><strong>Best for:</strong> Development, single-server deployments, temporary sessions</p>
<a class="header" href="print.html#redis-storage-implemented" id="redis-storage-implemented"><h3>Redis Storage (Implemented)</h3></a>
<p><strong>Pros:</strong></p>
<ul>
<li>Persistent across server restarts</li>
<li>Supports multiple server instances</li>
<li>Automatic TTL expiration</li>
<li>High performance with connection pooling</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Requires Redis server</li>
<li>Network latency for session access</li>
<li>Additional infrastructure complexity</li>
</ul>
<p><strong>Best for:</strong> Production deployments, multi-server setups, persistent sessions</p>
<a class="header" href="print.html#database-storage-user-implementation-required" id="database-storage-user-implementation-required"><h3>Database Storage (User Implementation Required)</h3></a>
<p><strong>Configuration structure exists but implementation is intentionally delegated to users:</strong></p>
<pre><code class="language-toml"># config.toml (configuration structure exists)
[session.storage]
type = &quot;database&quot;
table = &quot;sessions&quot;
connection_url = &quot;postgresql://localhost/myapp&quot;
cleanup_interval = 300
</code></pre>
<p><strong>Important:</strong> When you configure database storage, the framework will return an error with instructions:</p>
<pre><code>Database session storage must be implemented by the application.
Please implement the SessionStorage trait for your database backend.
See the documentation for examples using SQLx or other database libraries.
</code></pre>
<p>This is by design - database storage should be implemented by users to:</p>
<ul>
<li>Support any database backend (PostgreSQL, MySQL, SQLite, etc.)</li>
<li>Allow custom table schemas and optimization</li>
<li>Enable integration with your existing database infrastructure</li>
<li>Provide flexibility in storage strategies (JSON, normalized, etc.)</li>
</ul>
<a class="header" href="print.html#how-session-storage-integration-works" id="how-session-storage-integration-works"><h2>How Session Storage Integration Works</h2></a>
<a class="header" href="print.html#architecture-overview" id="architecture-overview"><h3>Architecture Overview</h3></a>
<p>Session storage in RustF is integrated through middleware, not directly through the application builder:</p>
<pre><code>RustF â†’ SessionMiddleware â†’ SessionManager â†’ SessionStorage (Your Implementation)
         â†‘
    Auto-created from config.toml if session.enabled = true
</code></pre>
<a class="header" href="print.html#default-behavior" id="default-behavior"><h3>Default Behavior</h3></a>
<p>When you create a RustF application, it automatically creates session middleware if <code>session.enabled = true</code> in your config:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// This happens automatically in RustF::with_config() (app.rs line 64)
if let Some(session_middleware) = create_session_middleware(&amp;config) {
    middleware.register_dual(&quot;session&quot;, session_middleware);
}
#}</code></pre></pre>
<p>The default session middleware uses <code>MemorySessionStorage</code>. To use custom storage, you must override this behavior.</p>
<a class="header" href="print.html#integrating-custom-storage" id="integrating-custom-storage"><h2>Integrating Custom Storage</h2></a>
<a class="header" href="print.html#method-1-override-default-session-middleware" id="method-1-override-default-session-middleware"><h3>Method 1: Override Default Session Middleware</h3></a>
<p><strong>Step 1:</strong> Disable automatic session middleware in config:</p>
<pre><code class="language-toml"># config.toml
[session]
enabled = false  # Disable auto-creation of session middleware
</code></pre>
<p><strong>Step 2:</strong> Create and register your custom session middleware:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;
use rustf::middleware::builtin::session::SessionMiddleware;
use rustf::session::manager::SessionConfig;
use std::sync::Arc;
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Load config with sessions disabled
    let mut config = AppConfig::from_file(&quot;config.toml&quot;)?;
    config.session.enabled = false;  // Ensure auto-session is disabled

    // Create RustF without auto session middleware
    let app = RustF::with_config(config.clone());

    // Create your custom storage
    let custom_storage = Arc::new(
        DatabaseSessionStorage::new(&quot;postgresql://localhost/myapp&quot;).await?
    );

    // Create session configuration
    let session_config = SessionConfig {
        cookie_name: config.session.cookie_name.clone(),
        idle_timeout: Duration::from_secs(config.session.idle_timeout),
        absolute_timeout: Duration::from_secs(config.session.absolute_timeout),
        exempt_routes: config.session.exempt_routes.clone(),
        enabled: true,  // Re-enable for our custom middleware
        ..Default::default()
    };

    // Create session middleware with custom storage
    let session_middleware = SessionMiddleware::with_storage(
        custom_storage,
        session_config
    );

    // Register the custom session middleware
    let app = app.middleware_from(|registry| {
        registry.register_dual(&quot;session&quot;, session_middleware);
    })
    .controllers(auto_controllers!());

    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#method-2-custom-session-manager" id="method-2-custom-session-manager"><h3>Method 2: Custom Session Manager</h3></a>
<p>Create a custom SessionManager and use it in middleware:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::session::manager::{SessionManager, SessionConfig};
use rustf::middleware::builtin::session::SessionMiddleware;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Disable auto session
    let mut config = AppConfig::default();
    config.session.enabled = false;

    let app = RustF::with_config(config);

    // Create custom storage
    let storage = Arc::new(MyCustomStorage::new().await?);

    // Create custom manager
    let session_manager = SessionManager::new(storage, SessionConfig::default());

    // Create middleware with custom manager
    let session_middleware = SessionMiddleware::with_manager(session_manager);

    // Register it
    let app = app.middleware_from(|registry| {
        registry.register_dual(&quot;session&quot;, session_middleware);
    })
    .controllers(auto_controllers!());

    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#method-3-factory-pattern-for-multiple-environments" id="method-3-factory-pattern-for-multiple-environments"><h3>Method 3: Factory Pattern for Multiple Environments</h3></a>
<p>Create a factory that handles different storage backends based on configuration:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::session::factory::SessionStorageFactory;
use rustf::config::SessionStorageConfig;

pub struct MyAppSessionFactory;

impl MyAppSessionFactory {
    pub async fn create_middleware(
        app_config: &amp;AppConfig
    ) -&gt; Result&lt;SessionMiddleware&gt; {
        // Create storage based on config
        let storage = match &amp;app_config.session.storage {
            SessionStorageConfig::Memory { .. } =&gt; {
                // Use built-in factory for memory
                SessionStorageFactory::create_storage(&amp;app_config.session.storage).await?
            }
            SessionStorageConfig::Redis { .. } =&gt; {
                // Use built-in factory for Redis
                SessionStorageFactory::create_storage(&amp;app_config.session.storage).await?
            }
            SessionStorageConfig::Database { connection_url, .. } =&gt; {
                // Use your custom database storage
                Arc::new(DatabaseSessionStorage::new(connection_url).await?)
            }
        };

        // Convert config
        let session_config: SessionConfig = app_config.session.clone().into();

        // Create middleware
        Ok(SessionMiddleware::with_storage(storage, session_config))
    }
}

// Usage in main.rs
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let mut config = AppConfig::from_file(&quot;config.toml&quot;)?;
    config.session.enabled = false;  // Disable auto-creation

    let app = RustF::with_config(config.clone());

    // Create custom middleware based on config
    let session_middleware = MyAppSessionFactory::create_middleware(&amp;config).await?;

    let app = app.middleware_from(|registry| {
        registry.register_dual(&quot;session&quot;, session_middleware);
    })
    .controllers(auto_controllers!());

    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#important-notes-2" id="important-notes-2"><h2>Important Notes</h2></a>
<a class="header" href="print.html#what-doesnt-work" id="what-doesnt-work"><h3>What DOESN'T Work</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ WRONG - These methods don't exist:
app.with_session_store(session_store)  // No such method
SessionStore::with_storage(storage)    // SessionStore is internal to SessionManager
#}</code></pre></pre>
<a class="header" href="print.html#what-does-work" id="what-does-work"><h3>What DOES Work</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… CORRECT - Use SessionMiddleware methods:
SessionMiddleware::with_storage(storage, config)  // Custom storage
SessionMiddleware::with_manager(manager)          // Custom manager
SessionMiddleware::new(config)                    // Default memory storage
#}</code></pre></pre>
<a class="header" href="print.html#key-integration-points" id="key-integration-points"><h3>Key Integration Points</h3></a>
<ol>
<li><strong>SessionMiddleware</strong> - The main integration point for custom storage</li>
<li><strong>SessionManager</strong> - Manages session lifecycle and storage interaction</li>
<li><strong>SessionStorage trait</strong> - Your custom implementation goes here</li>
<li><strong>config.session.enabled</strong> - Must be <code>false</code> to prevent auto-creation</li>
</ol>
<a class="header" href="print.html#monitoring-and-statistics" id="monitoring-and-statistics"><h2>Monitoring and Statistics</h2></a>
<p>Currently implemented storage backends provide statistics for monitoring:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Access statistics through your storage implementation
async fn session_monitoring(storage: &amp;Arc&lt;dyn SessionStorage&gt;) -&gt; Result&lt;()&gt; {
    let stats = storage.stats().await?;

    println!(&quot;Session Statistics:&quot;);
    println!(&quot;  Total sessions: {}&quot;, stats.total_sessions);
    println!(&quot;  Active sessions: {}&quot;, stats.active_sessions);
    println!(&quot;  Expired sessions: {}&quot;, stats.expired_sessions);
    println!(&quot;  Backend: {}&quot;, session_store.backend_name());

    // Backend-specific metrics
    for (key, value) in &amp;stats.backend_metrics {
        println!(&quot;  {}: {}&quot;, key, value);
    }

    Ok(())
}
#}</code></pre></pre>
<a class="header" href="print.html#memory-storage-metrics" id="memory-storage-metrics"><h3>Memory Storage Metrics</h3></a>
<ul>
<li><code>total_data_entries</code>: Total data entries across all sessions</li>
<li><code>total_flash_entries</code>: Total flash messages across all sessions</li>
<li><code>oldest_session_age_secs</code>: Age of oldest session in seconds</li>
<li><code>session_timeout_secs</code>: Session timeout configuration</li>
<li><code>cleanup_interval_secs</code>: Cleanup interval configuration</li>
</ul>
<a class="header" href="print.html#redis-storage-metrics" id="redis-storage-metrics"><h3>Redis Storage Metrics</h3></a>
<ul>
<li><code>redis_pattern</code>: Key pattern used for sessions</li>
<li><code>scan_method</code>: Scanning method used (non-blocking)</li>
<li><code>redis_memory_used</code>: Current Redis memory usage</li>
<li><code>redis_memory_peak</code>: Peak Redis memory usage</li>
</ul>
<a class="header" href="print.html#best-practices-8" id="best-practices-8"><h2>Best Practices</h2></a>
<a class="header" href="print.html#1-keep-session-data-small" id="1-keep-session-data-small"><h3>1. Keep Session Data Small</h3></a>
<p>Store only essential data in sessions to minimize memory/storage usage:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Good: Store minimal user info
ctx.session_set(&quot;user_id&quot;, 123)?;
ctx.session_set(&quot;role&quot;, &quot;admin&quot;)?;

// Less ideal: Store large objects
ctx.session_set(&quot;full_user_profile&quot;, large_user_object)?;
#}</code></pre></pre>
<a class="header" href="print.html#2-use-flash-messages-for-ui-feedback" id="2-use-flash-messages-for-ui-feedback"><h3>2. Use Flash Messages for UI Feedback</h3></a>
<p>Flash messages are perfect for one-time user notifications:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn create_user(ctx: Context) -&gt; Result&lt;Response&gt; {
    match create_user_in_db(&amp;user_data).await {
        Ok(_) =&gt; {
            ctx.flash_success(&quot;User created successfully!&quot;);
            ctx.redirect(&quot;/users&quot;)
        }
        Err(e) =&gt; {
            ctx.flash_error(&amp;format!(&quot;Failed to create user: {}&quot;, e));
            ctx.redirect(&quot;/users/new&quot;)
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#3-handle-session-expiration-gracefully" id="3-handle-session-expiration-gracefully"><h3>3. Handle Session Expiration Gracefully</h3></a>
<p>Check for required session data and handle missing sessions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn protected_route(ctx: Context) -&gt; Result&lt;Response&gt; {
    match ctx.session_get::&lt;i32&gt;(&quot;user_id&quot;) {
        Some(user_id) =&gt; {
            // User is logged in, continue
            handle_authenticated_request(ctx, user_id).await
        }
        None =&gt; {
            ctx.flash_info(&quot;Please log in to continue&quot;);
            ctx.redirect(&quot;/login&quot;)
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#4-use-appropriate-storage-backend" id="4-use-appropriate-storage-backend"><h3>4. Use Appropriate Storage Backend</h3></a>
<ul>
<li><strong>Development</strong>: Memory storage is fine</li>
<li><strong>Single server production</strong>: Memory storage with sufficient RAM</li>
<li><strong>Multi-server production</strong>: Redis storage for session sharing</li>
</ul>
<a class="header" href="print.html#5-configure-appropriate-timeouts" id="5-configure-appropriate-timeouts"><h3>5. Configure Appropriate Timeouts</h3></a>
<p>Balance security and user experience:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Short timeout for sensitive data
let secure_storage = MemorySessionStorage::with_timeout(
    Duration::from_secs(15 * 60), // 15 minutes
    Duration::from_secs(2 * 60)   // 2 minutes cleanup
);

// Longer timeout for general use
let general_storage = MemorySessionStorage::with_timeout(
    Duration::from_secs(2 * 60 * 60), // 2 hours
    Duration::from_secs(10 * 60)      // 10 minutes cleanup
);
#}</code></pre></pre>
<a class="header" href="print.html#6-use-appropriate-session-lifecycle-methods" id="6-use-appropriate-session-lifecycle-methods"><h3>6. Use Appropriate Session Lifecycle Methods</h3></a>
<p>Choose the right method for different scenarios:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// User logout - clear data but keep session for analytics
async fn logout(ctx: Context) -&gt; Result&lt;Response&gt; {
    ctx.session_clear();  // Keep session ID for tracking
    ctx.flash_success(&quot;You have been logged out&quot;);
    ctx.redirect(&quot;/login&quot;)
}

// Security incident - completely destroy session
async fn security_logout(ctx: Context, session_store: &amp;SessionStore) -&gt; Result&lt;Response&gt; {
    let session_id = ctx.session.id();
    session_store.destroy_session(session_id).await?;  // Complete removal
    ctx.redirect(&quot;/login&quot;)
}

// After login - regenerate ID to prevent session fixation
async fn after_login(ctx: Context) -&gt; Result&lt;Response&gt; {
    ctx.session.regenerate_id();  // Security best practice
    ctx.session_set(&quot;user_id&quot;, user.id)?;
    ctx.redirect(&quot;/dashboard&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#integration-with-application" id="integration-with-application"><h2>Integration with Application</h2></a>
<p>Sessions are automatically available in all controllers and middleware:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::new()
        .controllers(auto_controllers!())
        .middleware_from(auto_middleware!());

    // Sessions work automatically - no additional configuration needed
    app.serve(None).await
}
</code></pre></pre>
<p>The session system integrates seamlessly with the RustF context system, providing a consistent API across controllers, middleware, and views for managing user state and temporary messages.</p>
<a class="header" href="print.html#rustf-database--model-layer-documentation" id="rustf-database--model-layer-documentation"><h1>RustF Database &amp; Model Layer Documentation</h1></a>
<a class="header" href="print.html#overview-4" id="overview-4"><h2>Overview</h2></a>
<p>RustF provides a modern, ergonomic database layer with:</p>
<ul>
<li><strong>Transparent database access</strong> - No need to pass database connections around</li>
<li><strong>Multi-database support</strong> - PostgreSQL, MySQL/MariaDB, SQLite</li>
<li><strong>Type-safe query builders</strong> - Compile-time query validation</li>
<li><strong>Laravel-style model queries</strong> - Chainable, intuitive API</li>
<li><strong>Schema-driven development</strong> - YAML schemas generate type-safe models</li>
<li><strong>Smart change tracking</strong> - Only update modified fields</li>
</ul>
<a class="header" href="print.html#quick-start-1" id="quick-start-1"><h2>Quick Start</h2></a>
<a class="header" href="print.html#basic-usage-2" id="basic-usage-2"><h3>Basic Usage</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

// Find a user by ID
let user = Users::find(123).await?;

// Count all active users
let active_count = Users::query()?
    .where_eq(&quot;is_active&quot;, true)
    .count()
    .await?;

// Get paginated results
let users = Users::paginate(1, 20).await?;

// Delete a record
if let Some(user) = Users::find(456).await? {
    user.delete().await?;
}
#}</code></pre></pre>
<a class="header" href="print.html#database-configuration" id="database-configuration"><h2>Database Configuration</h2></a>
<a class="header" href="print.html#initial-setup" id="initial-setup"><h3>Initial Setup</h3></a>
<p>Configure your database in <code>config.toml</code>:</p>
<pre><code class="language-toml">[database]
url = &quot;postgresql://user:password@localhost/mydb&quot;  # or mysql:// or sqlite://
max_connections = 10
timeout = 30
</code></pre>
<p>The database connection is automatically initialized when your app starts. No manual setup required!</p>
<a class="header" href="print.html#global-database-access" id="global-database-access"><h3>Global Database Access</h3></a>
<p>RustF uses a global <code>DB</code> singleton that's initialized once at startup:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::database::DB;

// Check if database is initialized
if DB::is_initialized() {
    // Database is ready
}

// Get the backend type
let backend = DB::backend(); // Some(DatabaseBackend::Postgres)
#}</code></pre></pre>
<a class="header" href="print.html#model-system" id="model-system"><h2>Model System</h2></a>
<a class="header" href="print.html#generated-models" id="generated-models"><h3>Generated Models</h3></a>
<p>Models are generated from YAML schemas using the RustF CLI. Each model consists of:</p>
<ol>
<li><strong>Base model</strong> (<code>base/*.inc.rs</code>) - Auto-generated, never edit</li>
<li><strong>Wrapper model</strong> (<code>*.rs</code>) - Your business logic, safe to edit</li>
</ol>
<a class="header" href="print.html#creating-a-schema" id="creating-a-schema"><h3>Creating a Schema</h3></a>
<p>Create a YAML schema in <code>schemas/users.yaml</code>:</p>
<pre><code class="language-yaml">table: users
description: User accounts for the application
fields:
  - name: id
    type: integer
    primary_key: true
    auto_increment: true
    
  - name: email
    type: string
    max_length: 255
    nullable: false
    unique: true
    description: User's email address
    
  - name: username
    type: string
    max_length: 100
    nullable: false
    
  - name: is_active
    type: boolean
    default: true
    
  - name: created_at
    type: datetime
    nullable: true
    
  - name: status
    type: enum
    values: [&quot;active&quot;, &quot;inactive&quot;, &quot;pending&quot;]
    default: &quot;pending&quot;
    description: Account status
    
  - name: role
    type: enum  
    values: [&quot;admin&quot;, &quot;user&quot;, &quot;moderator&quot;]
    nullable: false
    default: &quot;user&quot;
    description: User role in the system
    
  - name: updated_at
    type: datetime
    nullable: true

indexes:
  - columns: [email]
    unique: true
  - columns: [username]
    unique: true
</code></pre>
<a class="header" href="print.html#generating-models" id="generating-models"><h3>Generating Models</h3></a>
<pre><code class="language-bash"># Generate models from schemas
rustf-cli schema generate models

# Force regeneration (backs up existing files)
rustf-cli schema generate models --force
</code></pre>
<p>This creates:</p>
<ul>
<li><code>src/models/base/users.inc.rs</code> - Generated base model</li>
<li><code>src/models/users.rs</code> - Wrapper for your business logic (if doesn't exist)</li>
</ul>
<a class="header" href="print.html#crud-operations" id="crud-operations"><h2>CRUD Operations</h2></a>
<a class="header" href="print.html#finding-records" id="finding-records"><h3>Finding Records</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Find by ID - returns Option&lt;Model&gt;
let user = Users::find(123).await?;

// Find first record
let first_user = Users::first().await?;

// Find all records (use with caution!)
let all_users = Users::all().await?;

// Find with conditions
let active_users = Users::query()?
    .where_eq(&quot;is_active&quot;, true)
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#creating-records" id="creating-records"><h3>Creating Records</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Using the builder pattern (recommended)
let new_user = Users::builder()
    .email(&quot;user@example.com&quot;)
    .username(&quot;johndoe&quot;)
    .is_active(true)
    .save()  // Saves directly to database
    .await?;

// Manual creation (for complex cases)
let user = Users {
    id: 0,  // Will be set by database
    email: &quot;user@example.com&quot;.to_string(),
    username: &quot;johndoe&quot;.to_string(),
    is_active: true,
    created_at: Some(Utc::now()),
    updated_at: None,
    // ... other fields
};
// Then save using your custom method
#}</code></pre></pre>
<a class="header" href="print.html#updating-records" id="updating-records"><h3>Updating Records</h3></a>
<p>Models track changes automatically - only modified fields are updated:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Find and update
let mut user = Users::find(123).await?.unwrap();

// Setters automatically track changes
user.set_email(&quot;newemail@example.com&quot;);
user.set_is_active(false);

// Only updates email and is_active fields
user.update().await?;

// Check if there are changes
if user.has_changes() {
    println!(&quot;User has unsaved changes&quot;);
}
#}</code></pre></pre>
<a class="header" href="print.html#deleting-records" id="deleting-records"><h3>Deleting Records</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Delete by finding first
if let Some(user) = Users::find(123).await? {
    user.delete().await?;
}

// Delete with query
let deleted_count = Users::query()?
    .where_eq(&quot;is_active&quot;, false)
    .where_lt(&quot;last_login&quot;, &quot;2024-01-01&quot;)
    .delete()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#query-builder" id="query-builder"><h2>Query Builder</h2></a>
<a class="header" href="print.html#basic-queries" id="basic-queries"><h3>Basic Queries</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Simple equality check
let users = Users::query()?
    .where_eq(&quot;role&quot;, &quot;admin&quot;)
    .get()
    .await?;

// Multiple conditions (AND)
let active_admins = Users::query()?
    .where_eq(&quot;role&quot;, &quot;admin&quot;)
    .where_eq(&quot;is_active&quot;, true)
    .where_not_null(&quot;email_verified&quot;)
    .get()
    .await?;

// OR conditions
let users = Users::query()?
    .where_eq(&quot;role&quot;, &quot;admin&quot;)
    .or_where_eq(&quot;role&quot;, &quot;moderator&quot;)
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#available-query-methods" id="available-query-methods"><h3>Available Query Methods</h3></a>
<a class="header" href="print.html#where-conditions" id="where-conditions"><h4>WHERE Conditions</h4></a>
<ul>
<li><code>where_eq(column, value)</code> - Equal to</li>
<li><code>where_ne(column, value)</code> - Not equal to</li>
<li><code>where_gt(column, value)</code> - Greater than</li>
<li><code>where_lt(column, value)</code> - Less than</li>
<li><code>where_gte(column, value)</code> - Greater than or equal</li>
<li><code>where_lte(column, value)</code> - Less than or equal</li>
<li><code>where_like(column, pattern)</code> - LIKE pattern matching</li>
<li><code>where_not_like(column, pattern)</code> - NOT LIKE</li>
<li><code>where_in(column, vec![values])</code> - IN list</li>
<li><code>where_not_in(column, vec![values])</code> - NOT IN</li>
<li><code>where_between(column, start, end)</code> - BETWEEN range</li>
<li><code>where_null(column)</code> - IS NULL</li>
<li><code>where_not_null(column)</code> - IS NOT NULL</li>
</ul>
<a class="header" href="print.html#or-conditions" id="or-conditions"><h4>OR Conditions</h4></a>
<p>All WHERE methods have <code>or_where_*</code> variants:</p>
<ul>
<li><code>or_where_eq(column, value)</code></li>
<li><code>or_where_gt(column, value)</code></li>
<li><code>or_where_null(column)</code></li>
<li>etc.</li>
</ul>
<a class="header" href="print.html#modifiers" id="modifiers"><h4>Modifiers</h4></a>
<ul>
<li><code>order_by(column, OrderDirection::Asc/Desc)</code></li>
<li><code>limit(n)</code></li>
<li><code>offset(n)</code></li>
<li><code>paginate(page, per_page)</code></li>
</ul>
<a class="header" href="print.html#field-selection" id="field-selection"><h4>Field Selection</h4></a>
<ul>
<li><code>select(&amp;[columns])</code> - Select specific fields instead of SELECT *</li>
<li><code>select_raw(&amp;[expressions])</code> - Select with SQL expressions and aggregations</li>
<li><code>alias(&quot;name&quot;)</code> - Set a table alias for complex queries</li>
</ul>
<a class="header" href="print.html#grouping" id="grouping"><h4>Grouping</h4></a>
<ul>
<li><code>group_by(&amp;[columns])</code> - Group results by specified columns</li>
</ul>
<a class="header" href="print.html#execution-methods" id="execution-methods"><h4>Execution Methods</h4></a>
<ul>
<li><code>get()</code> - Get all matching records as model instances</li>
<li><code>get_raw()</code> - Get results as JSON (useful for aggregations and JOINs)</li>
<li><code>first()</code> - Get first record</li>
<li><code>count()</code> - Count matching records</li>
<li><code>exists()</code> - Check if any records exist</li>
<li><code>delete()</code> - Delete matching records</li>
</ul>
<a class="header" href="print.html#complex-queries" id="complex-queries"><h3>Complex Queries</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Pagination with conditions
let users = Users::query()?
    .where_eq(&quot;is_active&quot;, true)
    .where_like(&quot;email&quot;, &quot;%@company.com&quot;)
    .order_by(&quot;created_at&quot;, OrderDirection::Desc)
    .paginate(2, 20)  // Page 2, 20 per page
    .get()
    .await?;

// Count with conditions
let admin_count = Users::query()?
    .where_eq(&quot;role&quot;, &quot;admin&quot;)
    .where_not_null(&quot;verified_at&quot;)
    .count()
    .await?;

// Check existence
let has_admins = Users::query()?
    .where_eq(&quot;role&quot;, &quot;admin&quot;)
    .exists()
    .await?;

// Complex date queries
let recent_users = Users::query()?
    .where_gt(&quot;created_at&quot;, &quot;2024-01-01&quot;)
    .where_between(&quot;age&quot;, 18, 65)
    .where_in(&quot;status&quot;, vec![&quot;active&quot;, &quot;pending&quot;])
    .order_by(&quot;created_at&quot;, OrderDirection::Desc)
    .limit(100)
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#reusable-query-filters-modelfilter" id="reusable-query-filters-modelfilter"><h2>Reusable Query Filters (ModelFilter)</h2></a>
<p>ModelFilter allows you to build reusable query conditions that can be applied to multiple queries. This is especially useful for common filtering patterns across your application.</p>
<a class="header" href="print.html#basic-usage-3" id="basic-usage-3"><h3>Basic Usage</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::models::ModelFilter;

// Create a reusable filter
let active_users = ModelFilter::new()
    .where_eq(&quot;is_active&quot;, true)
    .where_not_null(&quot;verified_at&quot;);

// Apply the same filter to different queries
let count = Users::query()?
    .apply_filter(&amp;active_users)
    .count()
    .await?;

let users = Users::query()?
    .apply_filter(&amp;active_users)
    .order_by(&quot;created_at&quot;, OrderDirection::Desc)
    .limit(10)
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#conditional-filter-building" id="conditional-filter-building"><h3>Conditional Filter Building</h3></a>
<p>ModelFilter supports conditional building by reassigning the filter variable:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Start with an empty filter
let mut filter = ModelFilter::new();

// Always apply base conditions
filter = filter.where_eq(&quot;is_active&quot;, true);

// Conditionally add filters based on user input
if let Some(search) = ctx.query(&quot;search&quot;) {
    filter = filter.where_like(&quot;name&quot;, &amp;format!(&quot;%{}%&quot;, search));
}

if let Some(role) = ctx.query(&quot;role&quot;) {
    filter = filter.where_eq(&quot;role&quot;, role);
}

if let Some(min_age) = ctx.query(&quot;min_age&quot;) {
    filter = filter.where_gte(&quot;age&quot;, min_age.parse::&lt;i32&gt;()?);
}

// Use the conditionally built filter
let results = Users::query()?
    .apply_filter(&amp;filter)
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#combining-filters" id="combining-filters"><h3>Combining Filters</h3></a>
<p>You can combine multiple filters using the <code>and()</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Create base filters
let active_filter = ModelFilter::new()
    .where_eq(&quot;is_active&quot;, true);

let verified_filter = ModelFilter::new()
    .where_not_null(&quot;email_verified_at&quot;)
    .where_not_null(&quot;phone_verified_at&quot;);

// Combine filters
let combined = active_filter.and(verified_filter);

// Use combined filter
let users = Users::query()?
    .apply_filter(&amp;combined)
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#common-filter-patterns" id="common-filter-patterns"><h3>Common Filter Patterns</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Pagination filter with search
let mut filter = ModelFilter::new();
if let Some(search) = search_term {
    filter = filter.where_like(&quot;name&quot;, &amp;format!(&quot;%{}%&quot;, search));
    // Note: OR conditions not yet supported, use multiple queries if needed
}
filter = filter.where_eq(&quot;is_active&quot;, true);

// Date range filter
let date_filter = ModelFilter::new()
    .where_gte(&quot;created_at&quot;, start_date)
    .where_lte(&quot;created_at&quot;, end_date);

// Complex status filter
let status_filter = ModelFilter::new()
    .where_in(&quot;status&quot;, vec![&quot;active&quot;, &quot;pending&quot;, &quot;verified&quot;])
    .where_not_null(&quot;approved_at&quot;);

// Null checks filter
let complete_profile = ModelFilter::new()
    .where_not_null(&quot;email&quot;)
    .where_not_null(&quot;phone&quot;)
    .where_not_null(&quot;address&quot;);
#}</code></pre></pre>
<a class="header" href="print.html#reusable-application-filters" id="reusable-application-filters"><h3>Reusable Application Filters</h3></a>
<p>Create application-wide filters as functions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// In your models or a filters module
impl Users {
    pub fn active_filter() -&gt; ModelFilter {
        ModelFilter::new()
            .where_eq(&quot;is_active&quot;, true)
            .where_not_null(&quot;email_verified_at&quot;)
    }
    
    pub fn admin_filter() -&gt; ModelFilter {
        ModelFilter::new()
            .where_eq(&quot;role&quot;, &quot;admin&quot;)
            .where_eq(&quot;is_active&quot;, true)
    }
}

// Usage
let admins = Users::query()?
    .apply_filter(&amp;Users::admin_filter())
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#advanced-query-features" id="advanced-query-features"><h2>Advanced Query Features</h2></a>
<a class="header" href="print.html#selecting-specific-fields" id="selecting-specific-fields"><h3>Selecting Specific Fields</h3></a>
<p>Instead of fetching all columns with SELECT *, you can specify exactly which fields you need:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Select specific fields only
let users = Users::query()?
    .select(&amp;[&quot;id&quot;, &quot;name&quot;, &quot;email&quot;])
    .where_eq(&quot;is_active&quot;, true)
    .get()
    .await?;

// With table prefixes (useful for JOINs)
let results = Posts::query()?
    .alias(&quot;p&quot;)
    .select(&amp;[&quot;p.id&quot;, &quot;p.title&quot;, &quot;u.name as author_name&quot;])
    .join(&quot;users AS u&quot;, &quot;u.id = p.user_id&quot;)
    .get_raw()
    .await?;

// Raw SQL expressions for aggregations
let stats = Users::query()?
    .select_raw(&amp;[
        &quot;department&quot;,
        &quot;COUNT(*) as user_count&quot;,
        &quot;AVG(salary) as avg_salary&quot;
    ])
    .group_by(&amp;[&quot;department&quot;])
    .get_raw()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#table-aliasing" id="table-aliasing"><h3>Table Aliasing</h3></a>
<p>Use <code>alias()</code> to set a table alias, essential for self-joins and improving query readability:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Simple aliasing
let users = Users::query()?
    .alias(&quot;u&quot;)
    .select(&amp;[&quot;u.id&quot;, &quot;u.name&quot;, &quot;u.email&quot;])
    .where_eq(&quot;u.is_active&quot;, true)
    .get()
    .await?;

// Self-join for hierarchical data (employee-manager)
let employees = Users::query()?
    .alias(&quot;emp&quot;)
    .select(&amp;[
        &quot;emp.id as employee_id&quot;,
        &quot;emp.name as employee_name&quot;,
        &quot;mgr.id as manager_id&quot;,
        &quot;mgr.name as manager_name&quot;
    ])
    .left_join(&quot;users AS mgr&quot;, &quot;mgr.id = emp.manager_id&quot;)
    .get_raw()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#advanced-join-queries" id="advanced-join-queries"><h3>Advanced JOIN Queries</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Simple JOIN
let posts_with_authors = Posts::query()?
    .join(&quot;users&quot;, &quot;users.id = posts.user_id&quot;)
    .where_eq(&quot;users.is_active&quot;, true)
    .get()
    .await?;

// LEFT JOIN with aliases to avoid column conflicts
let posts = Posts::query()?
    .alias(&quot;p&quot;)
    .select(&amp;[
        &quot;p.id as post_id&quot;,
        &quot;p.title&quot;,
        &quot;p.created_at as post_date&quot;,
        &quot;u.id as user_id&quot;,
        &quot;u.name as author_name&quot;,
        &quot;COUNT(c.id) as comment_count&quot;
    ])
    .join(&quot;users AS u&quot;, &quot;u.id = p.user_id&quot;)
    .left_join(&quot;comments AS c&quot;, &quot;c.post_id = p.id&quot;)
    .where_eq(&quot;p.is_published&quot;, true)
    .group_by(&amp;[&quot;p.id&quot;, &quot;p.title&quot;, &quot;p.created_at&quot;, &quot;u.id&quot;, &quot;u.name&quot;])
    .get_raw()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#handling-column-name-conflicts-in-joins" id="handling-column-name-conflicts-in-joins"><h4>Handling Column Name Conflicts in JOINs</h4></a>
<p>When joining tables with identical column names (like <code>id</code>, <code>created_at</code>), always use column aliases:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ BAD: Ambiguous column names
let results = Posts::query()?
    .join(&quot;users&quot;, &quot;users.id = posts.user_id&quot;)
    .get_raw()
    .await?;
// Which 'id' is which? posts.id or users.id?

// âœ… GOOD: Clear column aliases
let results = Posts::query()?
    .alias(&quot;p&quot;)
    .select(&amp;[
        &quot;p.id as post_id&quot;,
        &quot;p.created_at as post_date&quot;,
        &quot;u.id as user_id&quot;,
        &quot;u.created_at as user_joined&quot;
    ])
    .join(&quot;users AS u&quot;, &quot;u.id = p.user_id&quot;)
    .get_raw()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#group-by-and-aggregations" id="group-by-and-aggregations"><h3>GROUP BY and Aggregations</h3></a>
<p>Perform aggregate queries using <code>group_by()</code> with <code>select_raw()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Department statistics
let dept_stats = Users::query()?
    .alias(&quot;u&quot;)
    .select_raw(&amp;[
        &quot;u.department&quot;,
        &quot;COUNT(*) as total_users&quot;,
        &quot;AVG(u.salary) as avg_salary&quot;,
        &quot;MAX(u.salary) as max_salary&quot;,
        &quot;MIN(u.salary) as min_salary&quot;
    ])
    .where_eq(&quot;u.is_active&quot;, true)
    .group_by(&amp;[&quot;u.department&quot;])
    .order_by(&quot;total_users&quot;, OrderDirection::Desc)
    .get_raw()
    .await?;

// Posts per user with filtering
let user_post_counts = Users::query()?
    .alias(&quot;u&quot;)
    .select_raw(&amp;[
        &quot;u.id&quot;,
        &quot;u.name&quot;,
        &quot;COUNT(p.id) as post_count&quot;,
        &quot;MAX(p.created_at) as latest_post&quot;
    ])
    .left_join(&quot;posts AS p&quot;, &quot;p.user_id = u.id AND p.is_published = true&quot;)
    .group_by(&amp;[&quot;u.id&quot;, &quot;u.name&quot;])
    .order_by(&quot;post_count&quot;, OrderDirection::Desc)
    .limit(10)
    .get_raw()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#working-with-raw-query-results" id="working-with-raw-query-results"><h3>Working with Raw Query Results</h3></a>
<p>The <code>get_raw()</code> method returns <code>Vec&lt;serde_json::Value&gt;</code> for flexible result handling:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Execute raw query
let results = Users::query()?
    .alias(&quot;u&quot;)
    .select_raw(&amp;[
        &quot;u.department&quot;,
        &quot;COUNT(*) as count&quot;,
        &quot;AVG(u.salary) as avg_salary&quot;
    ])
    .group_by(&amp;[&quot;u.department&quot;])
    .get_raw()
    .await?;

// Loop over results
for row in &amp;results {
    let dept = row[&quot;department&quot;].as_str().unwrap_or(&quot;Unknown&quot;);
    let count = row[&quot;count&quot;].as_i64().unwrap_or(0);
    let avg = row[&quot;avg_salary&quot;].as_f64().unwrap_or(0.0);
    
    println!(&quot;Department: {} - {} users, avg salary: ${:.2}&quot;, dept, count, avg);
}

// Transform for view consumption
let view_data = results.iter().map(|row| {
    json!({
        &quot;department&quot;: row[&quot;department&quot;],
        &quot;userCount&quot;: row[&quot;count&quot;],
        &quot;avgSalary&quot;: format!(&quot;${:.2}&quot;, row[&quot;avg_salary&quot;].as_f64().unwrap_or(0.0))
    })
}).collect::&lt;Vec&lt;_&gt;&gt;();

// Pass to controller view
ctx.view(&quot;departments&quot;, json!({
    &quot;stats&quot;: view_data,
    &quot;total&quot;: results.len()
}))
#}</code></pre></pre>
<a class="header" href="print.html#combining-filters-with-complex-queries" id="combining-filters-with-complex-queries"><h3>Combining Filters with Complex Queries</h3></a>
<p>ModelFilter works seamlessly with all the new query features:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Create reusable filter
let active_filter = ModelFilter::new()
    .where_eq(&quot;u.is_active&quot;, true)
    .where_not_null(&quot;u.verified_at&quot;);

// Use with SELECT and JOIN
let users = Users::query()?
    .alias(&quot;u&quot;)
    .select(&amp;[&quot;u.id&quot;, &quot;u.name&quot;, &quot;COUNT(p.id) as posts&quot;])
    .apply_filter(&amp;active_filter)
    .left_join(&quot;posts AS p&quot;, &quot;p.user_id = u.id&quot;)
    .group_by(&amp;[&quot;u.id&quot;, &quot;u.name&quot;])
    .get_raw()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#working-with-models" id="working-with-models"><h2>Working with Models</h2></a>
<a class="header" href="print.html#field-access" id="field-access"><h3>Field Access</h3></a>
<p>Generated models provide getters and setters:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let user = Users::find(123).await?.unwrap();

// Getters
let email = user.email();        // &amp;str for String fields
let id = user.id();              // i32/i64 for ID
let active = user.is_active();   // bool
let status = user.status();      // Option&lt;&amp;str&gt; for enum
let created = user.created_at(); // Option&lt;DateTime&lt;Utc&gt;&gt;

// Setters (track changes automatically)
let mut user = user;
user.set_email(&quot;new@example.com&quot;);
user.set_is_active(false);

// Enum setters - PostgreSQL type casting is automatic
user.set_status(Some(Users::STATUS_ACTIVE));  // Uses constant
user.set_role(&quot;admin&quot;);  // Direct string also works

// Check what changed
if user.is_changed(&quot;email&quot;) {
    println!(&quot;Email was modified&quot;);
}

let changed_fields = user.changed_fields(); // Vec&lt;String&gt;
#}</code></pre></pre>
<a class="header" href="print.html#working-with-null-values" id="working-with-null-values"><h3>Working with NULL Values</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Setting NULL values
user.set_email_verified(None);  // Sets to NULL
user.set_email_verified(Some(Utc::now()));  // Sets value

// Checking for NULL
let users = Users::query()?
    .where_null(&quot;email_verified&quot;)
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#working-with-enums" id="working-with-enums"><h3>Working with Enums</h3></a>
<p>RustF provides intelligent enum handling with automatic PostgreSQL type casting:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Enum constants are generated for each enum field
user.set_status(Some(Users::STATUS_ACTIVE));      // &quot;active&quot;
user.set_role(Users::ROLE_ADMIN);                 // &quot;admin&quot;

// PostgreSQL setters automatically handle type casting
// The setter adds ::enum_type_name suffix when needed
user.set_status(Some(&quot;active&quot;));  // Becomes &quot;active::status_enum&quot; for PostgreSQL

// For query builders, use field-specific converter methods
let active_users = Users::query()?
    .where_eq(&quot;status&quot;, Users::as_status_enum(&quot;active&quot;))
    .get()
    .await?;

// Converter methods handle database-specific requirements:
// PostgreSQL: Returns &quot;active::status_enum&quot; 
// MySQL/SQLite: Returns &quot;active&quot; (pass-through)
let admins = Users::query()?
    .where_eq(&quot;role&quot;, Users::as_role_enum(&quot;admin&quot;))
    .where_eq(&quot;status&quot;, Users::as_status_enum(&quot;active&quot;))
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#enum-constants" id="enum-constants"><h4>Enum Constants</h4></a>
<p>Generated models include constants for all enum values:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Generated constants in your model
pub const STATUS_ACTIVE: &amp;'static str = &quot;active&quot;;
pub const STATUS_INACTIVE: &amp;'static str = &quot;inactive&quot;;
pub const STATUS_PENDING: &amp;'static str = &quot;pending&quot;;

pub const ROLE_ADMIN: &amp;'static str = &quot;admin&quot;;
pub const ROLE_USER: &amp;'static str = &quot;user&quot;;
pub const ROLE_MODERATOR: &amp;'static str = &quot;moderator&quot;;
#}</code></pre></pre>
<a class="header" href="print.html#enum-converter-methods" id="enum-converter-methods"><h4>Enum Converter Methods</h4></a>
<p>Each enum field gets a converter method for query builder compatibility:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Generated converter methods
pub fn as_status_enum(value: &amp;str) -&gt; String {
    // PostgreSQL: Adds type suffix
    // MySQL/SQLite: Pass-through
}

pub fn as_role_enum(value: &amp;str) -&gt; String {
    // Database-specific handling
}
#}</code></pre></pre>
<a class="header" href="print.html#custom-business-logic" id="custom-business-logic"><h3>Custom Business Logic</h3></a>
<p>Add your methods to the wrapper model:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/models/users.rs
impl Users {
    // Custom finder
    pub async fn find_by_email(email: &amp;str) -&gt; Result&lt;Option&lt;Self&gt;&gt; {
        Self::query()?
            .where_eq(&quot;email&quot;, email)
            .first()
            .await
    }
    
    // Business logic
    pub async fn verify_email(&amp;mut self) -&gt; Result&lt;()&gt; {
        self.set_email_verified(Some(Utc::now()));
        self.set_is_active(true);
        self.update().await
    }
    
    // Complex queries
    pub async fn find_inactive_users(days: i64) -&gt; Result&lt;Vec&lt;Self&gt;&gt; {
        let cutoff = Utc::now() - Duration::days(days);
        Self::query()?
            .where_eq(&quot;is_active&quot;, false)
            .where_lt(&quot;last_login&quot;, cutoff.to_rfc3339())
            .get()
            .await
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#type-safety" id="type-safety"><h2>Type Safety</h2></a>
<a class="header" href="print.html#using-type-constants" id="using-type-constants"><h3>Using Type Constants</h3></a>
<p>Instead of magic strings, use generated type constants:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ Avoid
let users = Users::query()?.where_eq(&quot;email&quot;, email).get().await?;

// âœ… Prefer (compile-time checked)
let users = Users::query()?
    .where_eq(Users::columns::EMAIL, email)
    .get()
    .await?;

// For enums, use converter methods in queries
// âŒ Avoid - Won't work correctly with PostgreSQL
let users = Users::query()?
    .where_eq(&quot;status&quot;, &quot;active&quot;)
    .get()
    .await?;

// âœ… Correct - Handles database-specific enum types
let users = Users::query()?
    .where_eq(&quot;status&quot;, Users::as_status_enum(&quot;active&quot;))
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#sqlvalue-conversions" id="sqlvalue-conversions"><h3>SqlValue Conversions</h3></a>
<p>The query builder accepts many types through <code>Into&lt;SqlValue&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// All of these work
query.where_eq(&quot;age&quot;, 25);           // i32
query.where_eq(&quot;age&quot;, 25i64);        // i64
query.where_eq(&quot;name&quot;, &quot;John&quot;);      // &amp;str
query.where_eq(&quot;name&quot;, String::from(&quot;John&quot;)); // String
query.where_eq(&quot;name&quot;, &amp;name);       // &amp;String (reference)
query.where_eq(&quot;active&quot;, true);      // bool
query.where_eq(&quot;created&quot;, Utc::now()); // DateTime
query.where_eq(&quot;data&quot;, json!({&quot;key&quot;: &quot;value&quot;})); // JSON
#}</code></pre></pre>
<a class="header" href="print.html#counting-and-aggregation" id="counting-and-aggregation"><h2>Counting and Aggregation</h2></a>
<a class="header" href="print.html#count-operations" id="count-operations"><h3>Count Operations</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Count all records
let total = Users::count().await?;

// Count with conditions
let active_count = Users::query()?
    .where_eq(&quot;is_active&quot;, true)
    .count()
    .await?;

// Count by group (using raw SQL for now)
// Future: Add group_by support
#}</code></pre></pre>
<a class="header" href="print.html#existence-checks" id="existence-checks"><h3>Existence Checks</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Check if any users exist
let has_users = Users::query()?.exists().await?;

// Check with conditions
let has_admins = Users::query()?
    .where_eq(&quot;role&quot;, &quot;admin&quot;)
    .exists()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#pagination" id="pagination"><h2>Pagination</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Simple pagination
let page = 2;
let per_page = 20;
let users = Users::paginate(page, per_page).await?;

// Pagination with conditions
let active_users = Users::query()?
    .where_eq(&quot;is_active&quot;, true)
    .order_by(&quot;created_at&quot;, OrderDirection::Desc)
    .paginate(page, per_page)
    .get()
    .await?;

// Manual limit/offset
let users = Users::query()?
    .limit(20)
    .offset(40)  // Skip first 40
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#error-handling-3" id="error-handling-3"><h2>Error Handling</h2></a>
<p>All database operations return <code>Result&lt;T&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::Result;

async fn get_user(id: i32) -&gt; Result&lt;Users&gt; {
    match Users::find(id).await? {
        Some(user) =&gt; Ok(user),
        None =&gt; Err(rustf::Error::NotFound(format!(&quot;User {} not found&quot;, id))),
    }
}

// Handle different cases
match Users::find(id).await {
    Ok(Some(user)) =&gt; {
        // User found
    },
    Ok(None) =&gt; {
        // User not found
    },
    Err(e) =&gt; {
        // Database error
        log::error!(&quot;Database error: {}&quot;, e);
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#best-practices-9" id="best-practices-9"><h2>Best Practices</h2></a>
<a class="header" href="print.html#1-use-query-builder-over-raw-sql" id="1-use-query-builder-over-raw-sql"><h3>1. Use Query Builder Over Raw SQL</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good - Type-safe, database-agnostic
let users = Users::query()?
    .where_eq(&quot;is_active&quot;, true)
    .get()
    .await?;

// âŒ Avoid - Database-specific, prone to SQL injection
let users = DB::execute_raw(&quot;SELECT * FROM users WHERE is_active = 1&quot;).await?;
#}</code></pre></pre>
<a class="header" href="print.html#2-always-check-option-returns" id="2-always-check-option-returns"><h3>2. Always Check Option Returns</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good - Handle None case
if let Some(user) = Users::find(id).await? {
    // Work with user
} else {
    // Handle not found
}

// âŒ Bad - Will panic on None
let user = Users::find(id).await?.unwrap();
#}</code></pre></pre>
<a class="header" href="print.html#3-use-transactions-for-multiple-operations" id="3-use-transactions-for-multiple-operations"><h3>3. Use Transactions for Multiple Operations</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Future: Transaction support planned
// For now, ensure operations are idempotent
#}</code></pre></pre>
<a class="header" href="print.html#4-leverage-change-tracking" id="4-leverage-change-tracking"><h3>4. Leverage Change Tracking</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good - Only updates changed fields
let mut user = Users::find(id).await?.unwrap();
user.set_email(&quot;new@example.com&quot;);
user.update().await?;  // Only updates email

// âŒ Less efficient - Updates all fields
// (Would update everything if using a different ORM)
#}</code></pre></pre>
<a class="header" href="print.html#5-use-builder-pattern-for-creation" id="5-use-builder-pattern-for-creation"><h3>5. Use Builder Pattern for Creation</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good - Clear, validated
let user = Users::builder()
    .email(&quot;user@example.com&quot;)
    .username(&quot;johndoe&quot;)
    .status(Some(Users::STATUS_ACTIVE))  // Use enum constants
    .role(Users::ROLE_USER)
    .save()
    .await?;

// âŒ More verbose - Manual struct creation
let user = Users { /* all fields */ };
#}</code></pre></pre>
<a class="header" href="print.html#6-use-enum-converter-methods-in-queries" id="6-use-enum-converter-methods-in-queries"><h3>6. Use Enum Converter Methods in Queries</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good - Works across all databases
let active_admins = Users::query()?
    .where_eq(&quot;status&quot;, Users::as_status_enum(&quot;active&quot;))
    .where_eq(&quot;role&quot;, Users::as_role_enum(&quot;admin&quot;))
    .get()
    .await?;

// âŒ Bad - May fail with PostgreSQL enums
let active_admins = Users::query()?
    .where_eq(&quot;status&quot;, &quot;active&quot;)  // Missing type suffix for PostgreSQL
    .where_eq(&quot;role&quot;, &quot;admin&quot;)
    .get()
    .await?;

// âœ… Good - Using constants with converter
let pending = Users::query()?
    .where_eq(&quot;status&quot;, Users::as_status_enum(Users::STATUS_PENDING))
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#configuration-access" id="configuration-access"><h2>Configuration Access</h2></a>
<p>Use the global <code>CONF</code> for configuration values:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::CONF;

// Get database URL
let db_url = CONF::get_string(&quot;database.url&quot;);

// Get with default
let max_conn = CONF::get_or(&quot;database.max_connections&quot;, 10);

// Check feature flags
if CONF::get_bool(&quot;features.advanced_search&quot;).unwrap_or(false) {
    // Advanced search enabled
}
#}</code></pre></pre>
<a class="header" href="print.html#performance-tips-1" id="performance-tips-1"><h2>Performance Tips</h2></a>
<ol>
<li>
<p><strong>Use <code>exists()</code> instead of <code>count() &gt; 0</code></strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Faster
let has_users = Users::query()?.exists().await?;

// âŒ Slower
let has_users = Users::query()?.count().await? &gt; 0;
#}</code></pre></pre>
</li>
<li>
<p><strong>Select only needed columns</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good - Only fetch what you need
let users = Users::query()?
    .select(&amp;[&quot;id&quot;, &quot;name&quot;, &quot;email&quot;])
    .where_eq(&quot;is_active&quot;, true)
    .get()
    .await?;

// âŒ Avoid - Fetches all columns
let users = Users::query()?
    .where_eq(&quot;is_active&quot;, true)
    .get()
    .await?;
#}</code></pre></pre>
</li>
<li>
<p><strong>Use pagination for large datasets</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good
let users = Users::paginate(1, 100).await?;

// âŒ Bad for large tables
let all_users = Users::all().await?;
#}</code></pre></pre>
</li>
<li>
<p><strong>Batch operations when possible</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Future: Bulk insert/update support
#}</code></pre></pre>
</li>
</ol>
<a class="header" href="print.html#debugging" id="debugging"><h2>Debugging</h2></a>
<a class="header" href="print.html#enable-sql-logging" id="enable-sql-logging"><h3>Enable SQL Logging</h3></a>
<pre><code class="language-toml"># In config.toml
[logging]
level = &quot;debug&quot;  # Shows SQL queries
</code></pre>
<a class="header" href="print.html#inspect-generated-sql" id="inspect-generated-sql"><h3>Inspect Generated SQL</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get the SQL without executing
let (sql, params) = Users::query()?
    .where_eq(&quot;email&quot;, &quot;test@example.com&quot;)
    .to_sql()?;
    
println!(&quot;SQL: {}&quot;, sql);
println!(&quot;Params: {:?}&quot;, params);
#}</code></pre></pre>
<a class="header" href="print.html#multi-database-support" id="multi-database-support"><h2>Multi-Database Support</h2></a>
<p>RustF automatically handles dialect differences:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// This works on PostgreSQL, MySQL, and SQLite
let users = Users::query()?
    .where_like(&quot;email&quot;, &quot;%@example.com&quot;)
    .limit(10)
    .get()
    .await?;

// Behind the scenes:
// PostgreSQL: &quot;email LIKE $1 LIMIT 10&quot;
// MySQL: &quot;email LIKE ? LIMIT 10&quot;  
// SQLite: &quot;email LIKE ? LIMIT 10&quot;
#}</code></pre></pre>
<a class="header" href="print.html#limitations--future-features" id="limitations--future-features"><h2>Limitations &amp; Future Features</h2></a>
<a class="header" href="print.html#current-limitations" id="current-limitations"><h3>Current Limitations</h3></a>
<ul>
<li>No transaction support yet</li>
<li>No raw SQL bindings (only MySQL has execute_raw)</li>
<li>No HAVING clause support (GROUP BY is supported)</li>
<li>Limited aggregate function helpers (use select_raw() for now)</li>
</ul>
<a class="header" href="print.html#coming-soon" id="coming-soon"><h3>Coming Soon</h3></a>
<ul>
<li>Transaction support</li>
<li>Migrations integration</li>
<li>Bulk insert/update</li>
<li>Query caching</li>
<li>Connection retry logic</li>
</ul>
<a class="header" href="print.html#summary-1" id="summary-1"><h2>Summary</h2></a>
<p>RustF's database layer provides:</p>
<ul>
<li><strong>Zero boilerplate</strong> - No connection passing</li>
<li><strong>Type safety</strong> - Compile-time query validation</li>
<li><strong>Smart updates</strong> - Change tracking built-in</li>
<li><strong>Multi-database</strong> - Write once, run anywhere</li>
<li><strong>Developer friendly</strong> - Intuitive API inspired by Laravel</li>
</ul>
<p>Start with schemas, generate models, and enjoy a modern database experience in Rust!# ğŸ—„ï¸ RustF Multi-Database Query Builder</p>
<p>A type-safe, AI-friendly SQL query builder for Rust that supports PostgreSQL, MySQL, MariaDB, and SQLite with a unified API. Part of the RustF web framework ecosystem.</p>
<blockquote>
<p>ğŸ“– <strong>Complete Guide:</strong> For comprehensive documentation including model generation, CLI tools, and AI agent guidelines, see the <a href="../advanced/cli.md">CLI Tool Guide</a> and <a href="schemas.md">Schemas Guide</a></p>
</blockquote>
<a class="header" href="print.html#-features" id="-features"><h2>ğŸŒŸ Features</h2></a>
<ul>
<li>ğŸš€ <strong>Type-safe query building</strong> with compile-time validation</li>
<li>ğŸ”„ <strong>Multi-database support</strong> (PostgreSQL, MySQL, MariaDB, SQLite)</li>
<li>ğŸ¤– <strong>AI-friendly design</strong> with predictable method names and clear error messages</li>
<li>ğŸ“ <strong>Automatic SQL dialect handling</strong> for cross-database compatibility</li>
<li>ğŸ›¡ï¸ <strong>SQL injection protection</strong> through parameterized queries</li>
<li>ğŸ“Š <strong>Schema builder</strong> with database-specific type mapping</li>
<li>ğŸ” <strong>Comprehensive WHERE clauses</strong> including LIKE, IN, BETWEEN, NULL checks</li>
<li>ğŸ”— <strong>All JOIN types</strong> (INNER, LEFT, RIGHT, FULL, CROSS)</li>
<li>ğŸ“„ <strong>Built-in pagination</strong> and aggregation helpers</li>
<li>âš¡ <strong>Zero-cost abstractions</strong> leveraging Rust's type system</li>
<li>ğŸ—ï¸ <strong>Framework integration</strong> with RustF model system and CLI tools</li>
</ul>
<a class="header" href="print.html#table-of-contents" id="table-of-contents"><h2>Table of Contents</h2></a>
<ul>
<li><a href="print.html#installation">Installation</a></li>
<li><a href="print.html#quick-start">Quick Start</a></li>
<li><a href="print.html#database-connection">Database Connection</a></li>
<li><a href="print.html#query-building">Query Building</a>
<ul>
<li><a href="print.html#basic-queries">Basic Queries</a></li>
<li><a href="print.html#where-conditions">WHERE Conditions</a></li>
<li><a href="print.html#join-operations">JOIN Operations</a></li>
<li><a href="print.html#aggregations">Aggregations</a></li>
<li><a href="print.html#ordering-and-limiting">Ordering and Limiting</a></li>
</ul>
</li>
<li><a href="print.html#schema-builder">Schema Builder</a></li>
<li><a href="print.html#error-handling">Error Handling</a></li>
<li><a href="print.html#database-specific-features">Database-Specific Features</a></li>
<li><a href="print.html#examples">Examples</a></li>
<li><a href="print.html#api-reference">API Reference</a></li>
</ul>
<a class="header" href="print.html#installation-1" id="installation-1"><h2>Installation</h2></a>
<p>Add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
query-builder = &quot;0.1.0&quot;
sqlx = { version = &quot;0.8&quot;, features = [&quot;postgres&quot;, &quot;mysql&quot;, &quot;sqlite&quot;, &quot;runtime-tokio-rustls&quot;, &quot;uuid&quot;, &quot;chrono&quot;, &quot;rust_decimal&quot;] }
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
thiserror = &quot;1.0&quot;
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
async-trait = &quot;0.1&quot;
</code></pre>
<a class="header" href="print.html#-quick-start" id="-quick-start"><h2>âš¡ Quick Start</h2></a>
<a class="header" href="print.html#1-using-with-rustf-models-recommended" id="1-using-with-rustf-models-recommended"><h3>1. Using with RustF Models (Recommended)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::models::Users;

// Simple model operations
let user = Users::find(123).await?;
let admins = Users::where_eq(&quot;role&quot;, &quot;admin&quot;).await?;

// Model-scoped query builder
let active_users = Users::query()?
    .where_eq(&quot;is_active&quot;, true)
    .where_gt(&quot;age&quot;, 18)
    .where_like(&quot;email&quot;, &quot;%@gmail.com&quot;)
    .order_by(&quot;created_at&quot;, OrderDirection::Desc)
    .limit(10)
    .get()
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#2-direct-query-builder-usage" id="2-direct-query-builder-usage"><h3>2. Direct Query Builder Usage</h3></a>
<pre><pre class="playpen"><code class="language-rust">use rustf::models::{AnyDatabase, QueryBuilder, OrderDirection};

#[tokio::main] 
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Connect to any supported database
    let db = AnyDatabase::connect(&quot;postgresql://localhost/myapp&quot;).await?;
    
    // Build and execute a query
    let (sql, params) = db.query()
        .from(&quot;users&quot;)
        .where_gt(&quot;age&quot;, 18)
        .where_like(&quot;email&quot;, &quot;%@gmail.com&quot;)
        .order_by(&quot;created_at&quot;, OrderDirection::Desc)
        .limit(10)
        .build()?;
    
    println!(&quot;Generated SQL: {}&quot;, sql);
    println!(&quot;Parameters: {:?}&quot;, params);
    
    Ok(())
}
</code></pre></pre>
<a class="header" href="print.html#3-generate-models-from-schema" id="3-generate-models-from-schema"><h3>3. Generate Models from Schema</h3></a>
<pre><code class="language-bash"># Create schema file
cat &gt; schemas/users.yaml &lt;&lt; EOF
name: users
table: users
fields:
  id: { type: integer, primary_key: true, auto_increment: true }
  name: { type: string, max_length: 100, required: true }
  email: { type: string, max_length: 255, unique: true, required: true }
  created_at: { type: timestamp, default: now }
EOF

# Generate models
rustf-cli schema generate models --schema-path schemas --output src/models
</code></pre>
<a class="header" href="print.html#database-connection" id="database-connection"><h2>Database Connection</h2></a>
<p>The library automatically detects the database type from the connection URL:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// PostgreSQL
let pg_db = AnyDatabase::connect(&quot;postgresql://user:pass@localhost/dbname&quot;).await?;

// MySQL
let mysql_db = AnyDatabase::connect(&quot;mysql://user:pass@localhost/dbname&quot;).await?;

// SQLite
let sqlite_db = AnyDatabase::connect(&quot;sqlite://path/to/database.db&quot;).await?;

// In-memory SQLite
let memory_db = AnyDatabase::connect(&quot;sqlite::memory:&quot;).await?;
#}</code></pre></pre>
<a class="header" href="print.html#query-building" id="query-building"><h2>Query Building</h2></a>
<a class="header" href="print.html#basic-queries-1" id="basic-queries-1"><h3>Basic Queries</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Select all columns
let query = db.query()
    .from(&quot;users&quot;)
    .build()?;
// SELECT * FROM &quot;users&quot; (PostgreSQL)
// SELECT * FROM `users` (MySQL)

// Select specific columns
let query = db.query()
    .select(vec![&quot;id&quot;, &quot;name&quot;, &quot;email&quot;])
    .from(&quot;users&quot;)
    .build()?;
// SELECT id, name, email FROM &quot;users&quot;

// Count query
let count = db.query()
    .from(&quot;users&quot;)
    .count()
    .build()?;
// SELECT COUNT(*) FROM &quot;users&quot;
#}</code></pre></pre>
<a class="header" href="print.html#where-conditions-1" id="where-conditions-1"><h3>WHERE Conditions</h3></a>
<p>The library provides a comprehensive set of WHERE operations:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Basic comparisons
query.where_eq(&quot;status&quot;, &quot;active&quot;)      // WHERE status = ?
query.where_ne(&quot;status&quot;, &quot;deleted&quot;)     // WHERE status &lt;&gt; ?
query.where_gt(&quot;age&quot;, 18)               // WHERE age &gt; ?
query.where_gte(&quot;age&quot;, 18)              // WHERE age &gt;= ?
query.where_lt(&quot;price&quot;, 100)            // WHERE price &lt; ?
query.where_lte(&quot;price&quot;, 100)           // WHERE price &lt;= ?

// Pattern matching
query.where_like(&quot;email&quot;, &quot;%@gmail.com&quot;)     // WHERE email LIKE ?
query.where_not_like(&quot;email&quot;, &quot;%spam%&quot;)      // WHERE email NOT LIKE ?

// IN clauses
query.where_in(&quot;status&quot;, vec![&quot;active&quot;, &quot;pending&quot;])      // WHERE status IN (?, ?)
query.where_not_in(&quot;role&quot;, vec![&quot;admin&quot;, &quot;super&quot;])       // WHERE role NOT IN (?, ?)

// NULL checks
query.where_null(&quot;deleted_at&quot;)          // WHERE deleted_at IS NULL
query.where_not_null(&quot;verified_at&quot;)     // WHERE verified_at IS NOT NULL

// Range queries
query.where_between(&quot;age&quot;, 18, 65)      // WHERE age BETWEEN ? AND ?

// OR conditions
query.where_eq(&quot;status&quot;, &quot;active&quot;)
     .or_where_eq(&quot;role&quot;, &quot;admin&quot;)      // WHERE status = ? OR role = ?

// Raw SQL conditions
query.where_raw(&quot;(status = 'active' OR created_at &gt; NOW() - INTERVAL '1 day')&quot;)
#}</code></pre></pre>
<a class="header" href="print.html#combining-conditions" id="combining-conditions"><h3>Combining Conditions</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let users = db.query()
    .from(&quot;users&quot;)
    .where_eq(&quot;active&quot;, true)
    .where_gte(&quot;age&quot;, 18)
    .where_like(&quot;email&quot;, &quot;%@%&quot;)
    .where_not_null(&quot;verified_at&quot;)
    .build()?;
// WHERE active = ? AND age &gt;= ? AND email LIKE ? AND verified_at IS NOT NULL
#}</code></pre></pre>
<a class="header" href="print.html#join-operations" id="join-operations"><h3>JOIN Operations</h3></a>
<p>All standard SQL joins are supported:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// INNER JOIN
query.join(&quot;posts&quot;, &quot;posts.user_id = users.id&quot;)

// LEFT JOIN
query.left_join(&quot;posts&quot;, &quot;posts.user_id = users.id&quot;)

// RIGHT JOIN (not supported in SQLite)
query.right_join(&quot;posts&quot;, &quot;posts.user_id = users.id&quot;)?

// FULL JOIN (not supported in MySQL/MariaDB)
query.full_join(&quot;posts&quot;, &quot;posts.user_id = users.id&quot;)?

// CROSS JOIN
query.cross_join(&quot;categories&quot;)

// Complex join example
let results = db.query()
    .select(vec![&quot;u.name&quot;, &quot;u.email&quot;, &quot;COUNT(p.id) as post_count&quot;])
    .from(&quot;users u&quot;)
    .left_join(&quot;posts p&quot;, &quot;p.user_id = u.id&quot;)
    .where_eq(&quot;u.active&quot;, true)
    .group_by(vec![&quot;u.id&quot;, &quot;u.name&quot;, &quot;u.email&quot;])
    .having(&quot;COUNT(p.id)&quot;, &quot;&gt;&quot;, 5)
    .order_by(&quot;post_count&quot;, OrderDirection::Desc)
    .build()?;
#}</code></pre></pre>
<a class="header" href="print.html#aggregations" id="aggregations"><h3>Aggregations</h3></a>
<p>Built-in aggregation helpers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Simple count
let count = db.query()
    .from(&quot;users&quot;)
    .count()
    .where_eq(&quot;active&quot;, true)
    .build()?;

// Count specific column
let count = db.query()
    .from(&quot;orders&quot;)
    .count_column(&quot;DISTINCT user_id&quot;)
    .build()?;

// Multiple aggregations
let stats = db.query()
    .from(&quot;orders&quot;)
    .aggregate(vec![
        (&quot;COUNT&quot;, &quot;*&quot;),
        (&quot;SUM&quot;, &quot;total&quot;),
        (&quot;AVG&quot;, &quot;total&quot;),
        (&quot;MAX&quot;, &quot;total&quot;),
        (&quot;MIN&quot;, &quot;total&quot;)
    ])
    .where_gte(&quot;created_at&quot;, &quot;2024-01-01&quot;)
    .group_by(vec![&quot;product_id&quot;])
    .build()?;
#}</code></pre></pre>
<a class="header" href="print.html#ordering-and-limiting" id="ordering-and-limiting"><h3>Ordering and Limiting</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Simple ordering
query.order_by(&quot;created_at&quot;, OrderDirection::Desc)

// Multiple order by
query.order_by_multiple(vec![
    (&quot;status&quot;, OrderDirection::Asc),
    (&quot;created_at&quot;, OrderDirection::Desc)
])

// Limiting results
query.limit(10)
query.offset(20)

// Pagination helper
query.paginate(2, 20)  // Page 2, 20 items per page
// Automatically calculates: LIMIT 20 OFFSET 20
#}</code></pre></pre>
<a class="header" href="print.html#schema-builder" id="schema-builder"><h2>Schema Builder</h2></a>
<p>Create database tables with automatic type mapping:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use query_builder::{SchemaBuilder, DatabaseBackend};

let schema = SchemaBuilder::new(DatabaseBackend::Postgres);

let sql = schema.create_table(&quot;users&quot;)
    .id()                                    // SERIAL PRIMARY KEY
    .string(&quot;email&quot;, Some(255))
        .not_null()
        .unique()                           // VARCHAR(255) NOT NULL UNIQUE
    .string(&quot;name&quot;, Some(100))              // VARCHAR(100)
    .boolean(&quot;active&quot;)
        .default(&quot;TRUE&quot;)                    // BOOLEAN DEFAULT TRUE
    .timestamp(&quot;created_at&quot;)
        .default(&quot;CURRENT_TIMESTAMP&quot;)       // TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    .build();

// Different databases get appropriate types:
// PostgreSQL: SERIAL, VARCHAR, BOOLEAN, TIMESTAMP WITH TIME ZONE
// MySQL: INT AUTO_INCREMENT, VARCHAR, TINYINT(1), DATETIME
// SQLite: INTEGER PRIMARY KEY AUTOINCREMENT, TEXT, INTEGER, TEXT
#}</code></pre></pre>
<a class="header" href="print.html#available-column-types" id="available-column-types"><h3>Available Column Types</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.id()                           // Auto-incrementing primary key
.uuid(&quot;column_name&quot;)            // UUID (or equivalent)
.string(&quot;column_name&quot;, Some(255))  // Variable-length string
.boolean(&quot;column_name&quot;)         // Boolean type
.timestamp(&quot;column_name&quot;)       // Timestamp/datetime
.integer(&quot;column_name&quot;)         // Integer
.float(&quot;column_name&quot;)           // Floating point
.text(&quot;column_name&quot;)            // Long text
#}</code></pre></pre>
<a class="header" href="print.html#column-modifiers" id="column-modifiers"><h3>Column Modifiers</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.not_null()                     // NOT NULL constraint
.unique()                       // UNIQUE constraint
.default(&quot;value&quot;)               // DEFAULT value
.primary_key()                  // PRIMARY KEY constraint
#}</code></pre></pre>
<a class="header" href="print.html#error-handling-4" id="error-handling-4"><h2>Error Handling</h2></a>
<p>The library provides AI-friendly error messages:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
match result {
    Err(QueryError::MissingClause { clause }) =&gt; {
        // &quot;Missing required clause: from. Add .from() to your query.&quot;
    },
    Err(QueryError::UnsupportedFeature { backend, feature }) =&gt; {
        // &quot;Feature not supported in PostgreSQL: RIGHT JOIN&quot;
    },
    Err(QueryError::InvalidColumn { column, available }) =&gt; {
        // &quot;Invalid column name: 'usr_name'. Available columns: ['id', 'name', 'email']&quot;
    },
    _ =&gt; {}
}
#}</code></pre></pre>
<a class="header" href="print.html#database-specific-features" id="database-specific-features"><h2>Database-Specific Features</h2></a>
<p>The library automatically handles database differences:</p>
<a class="header" href="print.html#placeholders" id="placeholders"><h3>Placeholders</h3></a>
<ul>
<li>PostgreSQL: <code>$1, $2, $3</code></li>
<li>MySQL/SQLite: <code>?, ?, ?</code></li>
</ul>
<a class="header" href="print.html#identifier-quoting" id="identifier-quoting"><h3>Identifier Quoting</h3></a>
<ul>
<li>PostgreSQL/SQLite: <code>&quot;column_name&quot;</code></li>
<li>MySQL/MariaDB: <code>`column_name`</code></li>
</ul>
<a class="header" href="print.html#returning-clause" id="returning-clause"><h3>RETURNING Clause</h3></a>
<ul>
<li>Supported: PostgreSQL, SQLite</li>
<li>Not supported: MySQL/MariaDB</li>
</ul>
<a class="header" href="print.html#boolean-types" id="boolean-types"><h3>Boolean Types</h3></a>
<ul>
<li>PostgreSQL: <code>BOOLEAN</code></li>
<li>MySQL/MariaDB: <code>TINYINT(1)</code></li>
<li>SQLite: <code>INTEGER</code></li>
</ul>
<a class="header" href="print.html#examples-1" id="examples-1"><h2>Examples</h2></a>
<a class="header" href="print.html#example-1-user-authentication-query" id="example-1-user-authentication-query"><h3>Example 1: User Authentication Query</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let user = db.query()
    .select(vec![&quot;id&quot;, &quot;email&quot;, &quot;password_hash&quot;, &quot;role&quot;])
    .from(&quot;users&quot;)
    .where_eq(&quot;email&quot;, email)
    .where_eq(&quot;active&quot;, true)
    .where_null(&quot;deleted_at&quot;)
    .build()?;
#}</code></pre></pre>
<a class="header" href="print.html#example-2-search-with-pagination" id="example-2-search-with-pagination"><h3>Example 2: Search with Pagination</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let search_term = &quot;%rust%&quot;;
let page = 2;

let posts = db.query()
    .select(vec![&quot;id&quot;, &quot;title&quot;, &quot;content&quot;, &quot;author_id&quot;, &quot;created_at&quot;])
    .from(&quot;posts&quot;)
    .where_like(&quot;title&quot;, &amp;search_term)
    .or_where_like(&quot;content&quot;, &amp;search_term)
    .where_eq(&quot;published&quot;, true)
    .order_by(&quot;created_at&quot;, OrderDirection::Desc)
    .paginate(page, 20)
    .build()?;
#}</code></pre></pre>
<a class="header" href="print.html#example-3-dashboard-statistics" id="example-3-dashboard-statistics"><h3>Example 3: Dashboard Statistics</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let stats = db.query()
    .from(&quot;orders&quot;)
    .aggregate(vec![
        (&quot;COUNT&quot;, &quot;*&quot;),
        (&quot;SUM&quot;, &quot;total_amount&quot;),
        (&quot;AVG&quot;, &quot;total_amount&quot;)
    ])
    .where_between(&quot;created_at&quot;, start_date, end_date)
    .where_eq(&quot;status&quot;, &quot;completed&quot;)
    .group_by(vec![&quot;DATE(created_at)&quot;])
    .order_by(&quot;DATE(created_at)&quot;, OrderDirection::Asc)
    .build()?;
#}</code></pre></pre>
<a class="header" href="print.html#example-4-complex-report-query" id="example-4-complex-report-query"><h3>Example 4: Complex Report Query</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let report = db.query()
    .select(vec![
        &quot;c.name as category&quot;,
        &quot;p.name as product&quot;,
        &quot;SUM(oi.quantity) as total_sold&quot;,
        &quot;SUM(oi.quantity * oi.price) as revenue&quot;
    ])
    .from(&quot;order_items oi&quot;)
    .join(&quot;orders o&quot;, &quot;o.id = oi.order_id&quot;)
    .join(&quot;products p&quot;, &quot;p.id = oi.product_id&quot;)
    .join(&quot;categories c&quot;, &quot;c.id = p.category_id&quot;)
    .where_eq(&quot;o.status&quot;, &quot;completed&quot;)
    .where_between(&quot;o.created_at&quot;, &quot;2024-01-01&quot;, &quot;2024-12-31&quot;)
    .group_by(vec![&quot;c.id&quot;, &quot;c.name&quot;, &quot;p.id&quot;, &quot;p.name&quot;])
    .having(&quot;SUM(oi.quantity)&quot;, &quot;&gt;&quot;, 100)
    .order_by(&quot;revenue&quot;, OrderDirection::Desc)
    .limit(50)
    .build()?;
#}</code></pre></pre>
<a class="header" href="print.html#api-reference" id="api-reference"><h2>API Reference</h2></a>
<a class="header" href="print.html#querybuilder-methods" id="querybuilder-methods"><h3>QueryBuilder Methods</h3></a>
<table><thead><tr><th> Method </th><th> Description </th><th> Example </th></tr></thead><tbody>
<tr><td> <code>select(columns)</code> </td><td> Select specific columns </td><td> <code>.select(vec![&quot;id&quot;, &quot;name&quot;])</code> </td></tr>
<tr><td> <code>from(table)</code> </td><td> Specify table </td><td> <code>.from(&quot;users&quot;)</code> </td></tr>
<tr><td> <code>where_*</code> </td><td> WHERE conditions </td><td> <code>.where_eq(&quot;status&quot;, &quot;active&quot;)</code> </td></tr>
<tr><td> <code>or_where_*</code> </td><td> OR WHERE conditions </td><td> <code>.or_where_eq(&quot;role&quot;, &quot;admin&quot;)</code> </td></tr>
<tr><td> <code>join(table, on)</code> </td><td> INNER JOIN </td><td> <code>.join(&quot;posts&quot;, &quot;posts.user_id = users.id&quot;)</code> </td></tr>
<tr><td> <code>left_join(table, on)</code> </td><td> LEFT JOIN </td><td> <code>.left_join(&quot;posts&quot;, &quot;posts.user_id = users.id&quot;)</code> </td></tr>
<tr><td> <code>group_by(columns)</code> </td><td> GROUP BY </td><td> <code>.group_by(vec![&quot;user_id&quot;])</code> </td></tr>
<tr><td> <code>having(col, op, val)</code> </td><td> HAVING clause </td><td> <code>.having(&quot;COUNT(*)&quot;, &quot;&gt;&quot;, 5)</code> </td></tr>
<tr><td> <code>order_by(col, dir)</code> </td><td> ORDER BY </td><td> <code>.order_by(&quot;created_at&quot;, OrderDirection::Desc)</code> </td></tr>
<tr><td> <code>limit(n)</code> </td><td> LIMIT results </td><td> <code>.limit(10)</code> </td></tr>
<tr><td> <code>offset(n)</code> </td><td> OFFSET results </td><td> <code>.offset(20)</code> </td></tr>
<tr><td> <code>distinct()</code> </td><td> SELECT DISTINCT </td><td> <code>.distinct()</code> </td></tr>
<tr><td> <code>count()</code> </td><td> COUNT(*) </td><td> <code>.count()</code> </td></tr>
<tr><td> <code>paginate(page, per_page)</code> </td><td> Pagination helper </td><td> <code>.paginate(2, 20)</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#where-condition-methods" id="where-condition-methods"><h3>WHERE Condition Methods</h3></a>
<table><thead><tr><th> Method </th><th> SQL Equivalent </th></tr></thead><tbody>
<tr><td> <code>where_eq(col, val)</code> </td><td> <code>WHERE col = val</code> </td></tr>
<tr><td> <code>where_ne(col, val)</code> </td><td> <code>WHERE col &lt;&gt; val</code> </td></tr>
<tr><td> <code>where_gt(col, val)</code> </td><td> <code>WHERE col &gt; val</code> </td></tr>
<tr><td> <code>where_gte(col, val)</code> </td><td> <code>WHERE col &gt;= val</code> </td></tr>
<tr><td> <code>where_lt(col, val)</code> </td><td> <code>WHERE col &lt; val</code> </td></tr>
<tr><td> <code>where_lte(col, val)</code> </td><td> <code>WHERE col &lt;= val</code> </td></tr>
<tr><td> <code>where_like(col, pattern)</code> </td><td> <code>WHERE col LIKE pattern</code> </td></tr>
<tr><td> <code>where_not_like(col, pattern)</code> </td><td> <code>WHERE col NOT LIKE pattern</code> </td></tr>
<tr><td> <code>where_in(col, values)</code> </td><td> <code>WHERE col IN (values)</code> </td></tr>
<tr><td> <code>where_not_in(col, values)</code> </td><td> <code>WHERE col NOT IN (values)</code> </td></tr>
<tr><td> <code>where_between(col, start, end)</code> </td><td> <code>WHERE col BETWEEN start AND end</code> </td></tr>
<tr><td> <code>where_null(col)</code> </td><td> <code>WHERE col IS NULL</code> </td></tr>
<tr><td> <code>where_not_null(col)</code> </td><td> <code>WHERE col IS NOT NULL</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#best-practices-10" id="best-practices-10"><h2>Best Practices</h2></a>
<ol>
<li>
<p><strong>Use parameterized queries</strong>: The library automatically parameterizes all values to prevent SQL injection.</p>
</li>
<li>
<p><strong>Check feature support</strong>: Some features like RIGHT JOIN (SQLite) or FULL JOIN (MySQL) aren't universally supported. The library returns clear errors for unsupported features.</p>
</li>
<li>
<p><strong>Use type-safe values</strong>: Pass proper Rust types that implement <code>Into&lt;SqlValue&gt;</code>.</p>
</li>
<li>
<p><strong>Handle errors appropriately</strong>: Use the detailed error types to provide meaningful feedback to users.</p>
</li>
<li>
<p><strong>Leverage the schema builder</strong>: Use it to ensure consistent table structures across different databases.</p>
</li>
</ol>
<a class="header" href="print.html#-ai-agent-guidelines" id="-ai-agent-guidelines"><h2>ğŸ¤– AI Agent Guidelines</h2></a>
<p>When working with the RustF query builder:</p>
<p><strong>âœ… Recommended:</strong></p>
<ul>
<li>Use model-scoped queries (<code>Users::query()</code>) for type safety</li>
<li>Use type constants (<code>UsersBase::Types::email</code>) instead of hardcoding types</li>
<li>Handle database-specific features gracefully with error checking</li>
<li>Use the unified <code>AnyDatabase</code> API for cross-database compatibility</li>
</ul>
<p><strong>âŒ Avoid:</strong></p>
<ul>
<li>Hardcoding SQL strings when the query builder can generate them</li>
<li>Ignoring database feature limitations (RIGHT JOIN in SQLite, etc.)</li>
<li>Using raw parameters instead of type-safe SqlValue conversion</li>
</ul>
<p><strong>Example AI-Friendly Error Handling:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
match query.right_join(&quot;posts&quot;, &quot;posts.user_id = users.id&quot;) {
    Ok(q) =&gt; q,
    Err(QueryError::UnsupportedFeature { backend, feature }) =&gt; {
        // Fallback to LEFT JOIN for compatibility
        query.left_join(&quot;posts&quot;, &quot;posts.user_id = users.id&quot;)?
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#-related-documentation" id="-related-documentation"><h2>ğŸ”— Related Documentation</h2></a>
<ul>
<li><strong><a href="../advanced/cli.md">CLI Tool Guide</a></strong> - Database tools and code generation</li>
<li><strong><a href="schemas.md">Schemas Guide</a></strong> - Schema-driven development</li>
<li><strong><a href="../../docs/MODEL_GENERATION.md">Model Generation Guide</a></strong> - Schema-driven development</li>
<li><strong><a href="../../docs/CLI_REFERENCE.md">RustF CLI Reference</a></strong> - Database and schema commands</li>
<li><strong><a href="../../docs/MULTI_DATABASE.md">Multi-Database Best Practices</a></strong> - Cross-database compatibility</li>
</ul>
<a class="header" href="print.html#-contributing" id="-contributing"><h2>ğŸ¤ Contributing</h2></a>
<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>
<a class="header" href="print.html#development-setup" id="development-setup"><h3>Development Setup</h3></a>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/rustf/rustf.git
cd rustf

# Run tests
cargo test

# Test with different databases
docker-compose up -d postgres mysql
cargo test --features=&quot;postgres,mysql,sqlite&quot;
</code></pre>
<a class="header" href="print.html#-license" id="-license"><h2>ğŸ“„ License</h2></a>
<a class="header" href="print.html#this-project-is-licensed-under-the-mit-license---see-the-license-file-for-details" id="this-project-is-licensed-under-the-mit-license---see-the-license-file-for-details"><h2>This project is licensed under the MIT License - see the LICENSE file for details.</h2></a>
<a class="header" href="print.html#pagination-helper-guide" id="pagination-helper-guide"><h1>Pagination Helper Guide</h1></a>
<p>RustF provides a built-in pagination helper through the <code>U::paginate()</code> function that makes it easy to implement pagination in your web applications.</p>
<a class="header" href="print.html#overview-5" id="overview-5"><h2>Overview</h2></a>
<p>The pagination helper creates a complete pagination object with:</p>
<ul>
<li>Page navigation (first, last, previous, next)</li>
<li>Page number ranges</li>
<li>URL generation with customizable patterns</li>
<li>Template-friendly JSON output</li>
</ul>
<a class="header" href="print.html#basic-usage-4" id="basic-usage-4"><h2>Basic Usage</h2></a>
<a class="header" href="print.html#in-controllers-1" id="in-controllers-1"><h3>In Controllers</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

async fn list_users(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Parse page from query parameters
    let page = ctx.query(&quot;page&quot;)
        .and_then(|p| p.parse::&lt;u32&gt;().ok())
        .unwrap_or(1);
    
    let per_page = 20;
    
    // Get total count from database
    let total_users = Users::count().await?;
    
    // Fetch paginated data
    let users = Users::paginate(page, per_page).await?;
    
    // Create pagination object
    let pagination = U::paginate(
        total_users,           // Total items
        page,                  // Current page (1-based)
        per_page,              // Items per page
        &quot;/users?page={0}&quot;      // URL pattern with {0} placeholder
    );
    
    // Pass to view
    ctx.view(&quot;users/list&quot;, json!({
        &quot;users&quot;: users,
        &quot;pagination&quot;: pagination.to_json()
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#in-templates-totaljs-syntax" id="in-templates-totaljs-syntax"><h3>In Templates (Total.js Syntax)</h3></a>
<pre><code class="language-html">&lt;!-- Basic pagination controls --&gt;
&lt;div class=&quot;pagination&quot;&gt;
    @{if pagination.isPrev}
        &lt;a href=&quot;@{pagination.prev.url}&quot;&gt;Previous&lt;/a&gt;
    @{fi}
    
    @{foreach page in pagination.range}
        @{if page.selected}
            &lt;span class=&quot;current&quot;&gt;@{page.page}&lt;/span&gt;
        @{else}
            &lt;a href=&quot;@{page.url}&quot;&gt;@{page.page}&lt;/a&gt;
        @{fi}
    @{end}
    
    @{if pagination.isNext}
        &lt;a href=&quot;@{pagination.next.url}&quot;&gt;Next&lt;/a&gt;
    @{fi}
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#complete-navigation-example" id="complete-navigation-example"><h3>Complete Navigation Example</h3></a>
<pre><code class="language-html">&lt;!-- Full pagination with first/last links --&gt;
&lt;div class=&quot;pagination&quot;&gt;
    &lt;!-- First &amp; Previous --&gt;
    @{if !pagination.isFirst}
        &lt;a href=&quot;@{pagination.first.url}&quot;&gt;Â« First&lt;/a&gt;
    @{fi}
    
    @{if pagination.isPrev}
        &lt;a href=&quot;@{pagination.prev.url}&quot;&gt;â€¹ Previous&lt;/a&gt;
    @{else}
        &lt;span class=&quot;disabled&quot;&gt;â€¹ Previous&lt;/span&gt;
    @{fi}
    
    &lt;!-- Page Numbers --&gt;
    @{foreach page in pagination.range}
        @{if page.selected}
            &lt;span class=&quot;current&quot;&gt;@{page.page}&lt;/span&gt;
        @{else}
            &lt;a href=&quot;@{page.url}&quot;&gt;@{page.page}&lt;/a&gt;
        @{fi}
    @{end}
    
    &lt;!-- Next &amp; Last --&gt;
    @{if pagination.isNext}
        &lt;a href=&quot;@{pagination.next.url}&quot;&gt;Next â€º&lt;/a&gt;
    @{else}
        &lt;span class=&quot;disabled&quot;&gt;Next â€º&lt;/span&gt;
    @{fi}
    
    @{if !pagination.isLast}
        &lt;a href=&quot;@{pagination.last.url}&quot;&gt;Last Â»&lt;/a&gt;
    @{fi}
&lt;/div&gt;

&lt;!-- Page info --&gt;
&lt;p&gt;Page @{pagination.page} of @{pagination.count} 
   (@{pagination.items} total items)&lt;/p&gt;
</code></pre>
<a class="header" href="print.html#pagination-object-structure" id="pagination-object-structure"><h2>Pagination Object Structure</h2></a>
<p>The <code>pagination.to_json()</code> method returns:</p>
<pre><code class="language-json">{
  &quot;items&quot;: 157,        // Total number of items
  &quot;page&quot;: 5,           // Current page
  &quot;count&quot;: 16,         // Total pages
  &quot;per_page&quot;: 10,      // Items per page
  &quot;isFirst&quot;: false,    // Is first page?
  &quot;isLast&quot;: false,     // Is last page?
  &quot;isPrev&quot;: true,      // Has previous page?
  &quot;isNext&quot;: true,      // Has next page?
  &quot;first&quot;: {
    &quot;url&quot;: &quot;/users?page=1&quot;
  },
  &quot;last&quot;: {
    &quot;url&quot;: &quot;/users?page=16&quot;
  },
  &quot;prev&quot;: {
    &quot;url&quot;: &quot;/users?page=4&quot;
  },
  &quot;next&quot;: {
    &quot;url&quot;: &quot;/users?page=6&quot;
  },
  &quot;range&quot;: [           // Page numbers for display
    {
      &quot;page&quot;: 3,
      &quot;url&quot;: &quot;/users?page=3&quot;,
      &quot;selected&quot;: false
    },
    {
      &quot;page&quot;: 4,
      &quot;url&quot;: &quot;/users?page=4&quot;,
      &quot;selected&quot;: false
    },
    {
      &quot;page&quot;: 5,
      &quot;url&quot;: &quot;/users?page=5&quot;,
      &quot;selected&quot;: true
    },
    // ... up to 7 pages by default
  ]
}
</code></pre>
<a class="header" href="print.html#advanced-usage-1" id="advanced-usage-1"><h2>Advanced Usage</h2></a>
<a class="header" href="print.html#custom-url-patterns" id="custom-url-patterns"><h3>Custom URL Patterns</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Simple query parameter
let pagination = U::paginate(total, page, 20, &quot;/posts?page={0}&quot;);

// With multiple parameters
let pagination = U::paginate(total, page, 20, &quot;/posts?category=tech&amp;page={0}&quot;);

// Path-based pagination
let pagination = U::paginate(total, page, 20, &quot;/posts/page/{0}&quot;);

// With hash fragments
let pagination = U::paginate(total, page, 20, &quot;/posts?page={0}#results&quot;);
#}</code></pre></pre>
<a class="header" href="print.html#pagination-with-filters" id="pagination-with-filters"><h3>Pagination with Filters</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn search_posts(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let page = ctx.query(&quot;page&quot;)
        .and_then(|p| p.parse::&lt;u32&gt;().ok())
        .unwrap_or(1);
    let search = ctx.query(&quot;q&quot;).unwrap_or(&quot;&quot;);
    let category = ctx.query(&quot;category&quot;).unwrap_or(&quot;all&quot;);
    
    // Build query with filters
    let total = Posts::query()?
        .where_like(&quot;title&quot;, &amp;format!(&quot;%{}%&quot;, search))
        .where_eq(&quot;category&quot;, category)
        .count()
        .await?;
    
    let posts = Posts::query()?
        .where_like(&quot;title&quot;, &amp;format!(&quot;%{}%&quot;, search))
        .where_eq(&quot;category&quot;, category)
        .paginate(page, 20)
        .get()
        .await?;
    
    // Include filters in URL pattern
    let url_pattern = format!(
        &quot;/search?q={}&amp;category={}&amp;page={{0}}&quot;, 
        U::encode(search),
        U::encode(category)
    );
    
    let pagination = U::paginate(total, page, 20, &amp;url_pattern);
    
    ctx.view(&quot;search-results&quot;, json!({
        &quot;posts&quot;: posts,
        &quot;pagination&quot;: pagination.to_json(),
        &quot;search&quot;: search,
        &quot;category&quot;: category
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#styling-example" id="styling-example"><h2>Styling Example</h2></a>
<pre><code class="language-css">.pagination {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin: 20px 0;
}

.pagination a,
.pagination span {
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    text-decoration: none;
}

.pagination a:hover {
    background: #007bff;
    color: white;
}

.pagination .current {
    background: #007bff;
    color: white;
    font-weight: bold;
}

.pagination .disabled {
    color: #999;
    cursor: not-allowed;
}
</code></pre>
<a class="header" href="print.html#api-reference-1" id="api-reference-1"><h2>API Reference</h2></a>
<a class="header" href="print.html#upaginate" id="upaginate"><h3>U::paginate()</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn paginate(
    total: i64,           // Total number of items
    page: u32,            // Current page (1-based)
    per_page: u32,        // Items per page
    url_pattern: &amp;str     // URL pattern with {0} placeholder
) -&gt; Pagination
#}</code></pre></pre>
<a class="header" href="print.html#pagination-methods" id="pagination-methods"><h3>Pagination Methods</h3></a>
<ul>
<li><code>to_json()</code> - Convert to JSON for template use</li>
<li><code>is_first()</code> - Check if on first page</li>
<li><code>is_last()</code> - Check if on last page</li>
<li><code>has_prev()</code> - Check if previous page exists</li>
<li><code>has_next()</code> - Check if next page exists</li>
<li><code>first_url()</code> - Get URL for first page</li>
<li><code>last_url()</code> - Get URL for last page</li>
<li><code>prev_url()</code> - Get URL for previous page</li>
<li><code>next_url()</code> - Get URL for next page</li>
<li><code>range(max_items)</code> - Get page number range for display</li>
</ul>
<a class="header" href="print.html#best-practices-11" id="best-practices-11"><h2>Best Practices</h2></a>
<ol>
<li><strong>Always validate page numbers</strong> - Ensure page is within valid range</li>
<li><strong>Use reasonable per_page limits</strong> - Typically 10-100 items</li>
<li><strong>Cache total counts</strong> - For large datasets, consider caching counts</li>
<li><strong>Include page info</strong> - Show &quot;Page X of Y&quot; for better UX</li>
<li><strong>Provide direct navigation</strong> - Include first/last links for long lists</li>
<li><strong>Make it accessible</strong> - Use proper ARIA labels and semantic HTML</li>
<li><strong>Handle edge cases</strong> - Empty results, single page, invalid page numbers</li>
</ol>
<a class="header" href="print.html#example-complete-implementation" id="example-complete-implementation"><h2>Example: Complete Implementation</h2></a>
<p>See <code>/rustf-example/src/controllers/pagination_demo.rs</code> and <code>/rustf-example/views/pagination-demo.html</code> for a complete working example.</p>
<a class="header" href="print.html#rustf-configuration-guide" id="rustf-configuration-guide"><h1>RustF Configuration Guide</h1></a>
<p><strong>Complete documentation for configuration management in RustF</strong></p>
<a class="header" href="print.html#overview-6" id="overview-6"><h2>Overview</h2></a>
<p>RustF provides a comprehensive configuration system inspired by Total.js, with a global <code>CONF</code> accessor that allows uniform configuration access throughout your application. Configuration can be loaded from TOML files, environment variables, or programmatically, with support for environment-specific settings and hot-reloading during development.</p>
<a class="header" href="print.html#key-features-2" id="key-features-2"><h3>Key Features</h3></a>
<ul>
<li><strong>Global CONF Access</strong> - Single, uniform way to access configuration anywhere</li>
<li><strong>Dot Notation Paths</strong> - Access nested values with <code>&quot;server.port&quot;</code> syntax</li>
<li><strong>Environment Support</strong> - Development and production environments</li>
<li><strong>Multiple Sources</strong> - TOML files, environment variables, and defaults</li>
<li><strong>Type-Safe Access</strong> - Typed getters for strings, integers, booleans, and floats</li>
<li><strong>Custom Settings</strong> - Extensible with application-specific configuration</li>
</ul>
<a class="header" href="print.html#global-configuration-access-conf" id="global-configuration-access-conf"><h2>Global Configuration Access (CONF)</h2></a>
<p>RustF provides a global <code>CONF</code> singleton that gives uniform access to configuration values using dot notation paths. This is the <strong>ONLY</strong> way to access configuration in RustF - there is no configuration access through Context or other means.</p>
<a class="header" href="print.html#basic-usage-5" id="basic-usage-5"><h3>Basic Usage</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;  // CONF is included in the prelude

// Access configuration values with dot notation
let port = CONF::get_int(&quot;server.port&quot;).unwrap_or(8000);
let host = CONF::get_string(&quot;server.host&quot;).unwrap_or_else(|| &quot;127.0.0.1&quot;.to_string());
let db_url = CONF::get_string(&quot;database.url&quot;);

// Check if a configuration path exists
if CONF::has(&quot;database.url&quot;) {
    // Database is configured
}

// Get values with defaults
let timeout = CONF::get_or(&quot;server.timeout&quot;, 30);
let max_files = CONF::get_or(&quot;uploads.max_files&quot;, 5);

// Environment helpers
if CONF::is_production() {
    // Enable production optimizations
}

if CONF::is_development() {
    // Enable development features
}
#}</code></pre></pre>
<a class="header" href="print.html#conf-methods" id="conf-methods"><h3>CONF Methods</h3></a>
<table><thead><tr><th> Method </th><th> Description </th><th> Example </th></tr></thead><tbody>
<tr><td> <code>get&lt;T&gt;(path)</code> </td><td> Get typed value at path </td><td> <code>CONF::get::&lt;u16&gt;(&quot;server.port&quot;)</code> </td></tr>
<tr><td> <code>get_string(path)</code> </td><td> Get string value </td><td> <code>CONF::get_string(&quot;database.url&quot;)</code> </td></tr>
<tr><td> <code>get_int(path)</code> </td><td> Get integer value </td><td> <code>CONF::get_int(&quot;server.port&quot;)</code> </td></tr>
<tr><td> <code>get_bool(path)</code> </td><td> Get boolean value </td><td> <code>CONF::get_bool(&quot;server.ssl_enabled&quot;)</code> </td></tr>
<tr><td> <code>get_float(path)</code> </td><td> Get float value </td><td> <code>CONF::get_float(&quot;custom.rate&quot;)</code> </td></tr>
<tr><td> <code>get_or(path, default)</code> </td><td> Get with default </td><td> <code>CONF::get_or(&quot;server.port&quot;, 8000)</code> </td></tr>
<tr><td> <code>has(path)</code> </td><td> Check if path exists </td><td> <code>CONF::has(&quot;database.url&quot;)</code> </td></tr>
<tr><td> <code>env()</code> </td><td> Get current environment </td><td> <code>CONF::env()</code> </td></tr>
<tr><td> <code>is_production()</code> </td><td> Check if production </td><td> <code>CONF::is_production()</code> </td></tr>
<tr><td> <code>is_development()</code> </td><td> Check if development </td><td> <code>CONF::is_development()</code> </td></tr>
<tr><td> <code>all()</code> </td><td> Get entire config </td><td> <code>CONF::all()</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#accessing-configuration-in-different-contexts" id="accessing-configuration-in-different-contexts"><h3>Accessing Configuration in Different Contexts</h3></a>
<a class="header" href="print.html#in-controllers-2" id="in-controllers-2"><h4>In Controllers</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;  // CONF is included in the prelude

async fn handler(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Configuration is accessed via CONF, not through ctx
    let upload_dir = CONF::get_string(&quot;uploads.directory&quot;).unwrap_or_else(|| &quot;uploads&quot;.to_string());
    let max_size = CONF::get_int(&quot;uploads.max_file_size&quot;).unwrap_or(10485760);
    
    // Use configuration values
    if file.size &gt; max_size as usize {
        return ctx.throw400(Some(&quot;File too large&quot;));
    }
    
    // Save file to upload_dir...
    Ok(Response::ok())
}
#}</code></pre></pre>
<a class="header" href="print.html#in-modulesservices" id="in-modulesservices"><h4>In Modules/Services</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;  // CONF is included in the prelude

pub struct EmailService;

impl EmailService {
    pub fn send_email(&amp;self, to: &amp;str, subject: &amp;str, body: &amp;str) {
        // Access custom configuration sections via CONF
        // All sections (framework or custom) use the same dot notation
        let smtp_host = CONF::get_string(&quot;smtp.host&quot;).unwrap_or_else(|| &quot;localhost&quot;.to_string());
        let smtp_port = CONF::get_int(&quot;smtp.port&quot;).unwrap_or(25);
        let from_email = CONF::get_string(&quot;smtp.user&quot;).unwrap_or_else(|| &quot;noreply@example.com&quot;.to_string());
        
        // Send email using configuration...
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#in-event-handlers" id="in-event-handlers"><h4>In Event Handlers</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;  // CONF is included in the prelude

app.on(&quot;startup&quot;, |ctx| Box::pin(async move {
    // Access configuration during startup
    let db_url = CONF::get_string(&quot;database.url&quot;);
    let pool_size = CONF::get_int(&quot;database.max_connections&quot;).unwrap_or(10);
    
    if let Some(url) = db_url {
        // Initialize database with configuration
        initialize_database(&amp;url, pool_size).await?;
    }
    
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#in-middleware" id="in-middleware"><h4>In Middleware</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;  // CONF is included in the prelude

pub struct RateLimitMiddleware;

impl Middleware for RateLimitMiddleware {
    fn handle(&amp;self, ctx: &amp;mut Context, next: Next) -&gt; MiddlewareResult {
        // Access rate limit configuration
        let max_requests = CONF::get_int(&quot;custom.rate_limit_max&quot;).unwrap_or(100);
        let window_seconds = CONF::get_int(&quot;custom.rate_limit_window&quot;).unwrap_or(60);
        
        // Apply rate limiting...
        next.run(ctx)
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#configuration-structure" id="configuration-structure"><h2>Configuration Structure</h2></a>
<a class="header" href="print.html#appconfig-schema" id="appconfig-schema"><h3>AppConfig Schema</h3></a>
<p>The main configuration structure in RustF:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct AppConfig {
    pub environment: Environment,        // development, staging, production, testing
    pub server: ServerConfig,           // Server settings
    pub views: ViewConfig,              // Template engine settings
    pub session: SessionConfig,         // Session management
    pub static_files: StaticConfig,    // Static file serving
    pub database: DatabaseConfig,      // Database connection
    pub cors: CorsConfig,              // CORS settings
    pub logging: LoggingConfig,        // Logging configuration
    pub uploads: UploadConfig,         // File upload settings
    pub sections: HashMap&lt;String, toml::Value&gt;, // User-defined configuration sections
}
#}</code></pre></pre>
<p>Framework sections (above) are strongly typed for IDE support and compile-time checking. User-defined sections are stored as TOML values and can be deserialized on-demand using <code>config.section::&lt;T&gt;(&quot;name&quot;)</code>.</p>
<a class="header" href="print.html#configuration-sections" id="configuration-sections"><h3>Configuration Sections</h3></a>
<a class="header" href="print.html#server-configuration" id="server-configuration"><h4>Server Configuration</h4></a>
<pre><code class="language-toml">[server]
host = &quot;127.0.0.1&quot;          # Server bind address
port = 8000                 # Server port
timeout = 30                # Request timeout in seconds
ssl_enabled = false         # Enable HTTPS
ssl_cert = &quot;cert.pem&quot;       # SSL certificate path (if ssl_enabled)
ssl_key = &quot;key.pem&quot;         # SSL private key path (if ssl_enabled)
max_connections = 1000      # Maximum concurrent connections
</code></pre>
<a class="header" href="print.html#views-configuration" id="views-configuration"><h4>Views Configuration</h4></a>
<pre><code class="language-toml">[views]
directory = &quot;views&quot;         # Template directory path
default_layout = &quot;layouts/default&quot;  # Default layout template
cache_enabled = false       # Enable template caching
extension = &quot;html&quot;          # Template file extension
storage = &quot;filesystem&quot;      # Storage method: &quot;filesystem&quot; or &quot;embedded&quot;
</code></pre>
<a class="header" href="print.html#session-configuration-1" id="session-configuration-1"><h4>Session Configuration</h4></a>
<pre><code class="language-toml">[session]
secret = &quot;change-me-in-production&quot;  # Session encryption secret
timeout = 3600              # Session timeout in seconds
cookie_name = &quot;rustf_session&quot;       # Session cookie name
secure = false              # Secure cookies (HTTPS only)
http_only = true            # HttpOnly flag for cookies

[session.storage]
type = &quot;memory&quot;             # Storage backend: &quot;memory&quot;, &quot;redis&quot;, or &quot;database&quot;
cleanup_interval = 300      # Cleanup interval in seconds (for memory storage)
</code></pre>
<a class="header" href="print.html#database-configuration-1" id="database-configuration-1"><h4>Database Configuration</h4></a>
<pre><code class="language-toml">[database]
url = &quot;postgresql://user:pass@localhost/myapp&quot;  # Database connection URL
max_connections = 10        # Connection pool size
timeout = 5000              # Connection timeout in milliseconds
</code></pre>
<a class="header" href="print.html#static-files-configuration" id="static-files-configuration"><h4>Static Files Configuration</h4></a>
<pre><code class="language-toml">[static_files]
directory = &quot;public&quot;        # Static files directory
url_prefix = &quot;/static&quot;      # URL prefix for static files
cache_enabled = true        # Enable caching headers
cache_max_age = 86400       # Cache max-age in seconds
</code></pre>
<a class="header" href="print.html#cors-configuration" id="cors-configuration"><h4>CORS Configuration</h4></a>
<pre><code class="language-toml">[cors]
enabled = false             # Enable CORS
allowed_origins = [&quot;*&quot;]     # Allowed origins
allowed_methods = [&quot;GET&quot;, &quot;POST&quot;]  # Allowed HTTP methods
allowed_headers = [&quot;Content-Type&quot;] # Allowed headers
</code></pre>
<a class="header" href="print.html#logging-configuration" id="logging-configuration"><h4>Logging Configuration</h4></a>
<pre><code class="language-toml">[logging]
level = &quot;info&quot;              # Log level: debug, info, warn, error
file = &quot;logs/app.log&quot;       # Optional log file path
</code></pre>
<a class="header" href="print.html#upload-configuration" id="upload-configuration"><h4>Upload Configuration</h4></a>
<pre><code class="language-toml">[uploads]
directory = &quot;uploads&quot;       # Upload directory
max_file_size = 10485760    # Max file size in bytes (10MB)
max_files = 5               # Max files per upload
allowed_extensions = []     # Allowed file extensions (empty = all)
blocked_extensions = [&quot;exe&quot;, &quot;bat&quot;, &quot;sh&quot;, &quot;cmd&quot;]  # Blocked extensions
create_directories = true   # Auto-create upload directories
</code></pre>
<a class="header" href="print.html#custom-application-configuration" id="custom-application-configuration"><h4>Custom Application Configuration</h4></a>
<p>Any sections you define in config.toml are automatically available as configuration sections:</p>
<pre><code class="language-toml">[app]
name = &quot;MyApplication&quot;
version = &quot;1.0.0&quot;
debug_mode = false

[payment]
stripe_key = &quot;sk_test_xxxxx&quot;
paypal_email = &quot;business@example.com&quot;

[smtp]
host = &quot;smtp.gmail.com&quot;
port = 587
user = &quot;noreply@example.com&quot;
password = &quot;${SMTP_PASSWORD}&quot;
</code></pre>
<p>Access custom sections in Rust code using the <code>section()</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;
use serde::Deserialize;

#[derive(Deserialize)]
struct AppConfig {
    name: String,
    version: String,
    debug_mode: bool,
}

#[derive(Deserialize)]
struct PaymentConfig {
    stripe_key: String,
    paypal_email: String,
}

// Get typed access to custom sections
let app_cfg = config.section::&lt;AppConfig&gt;(&quot;app&quot;)?;
println!(&quot;App: {} v{}&quot;, app_cfg.name, app_cfg.version);

let payment = config.section::&lt;PaymentConfig&gt;(&quot;payment&quot;)?;
println!(&quot;Stripe key: {}&quot;, payment.stripe_key);

// Or use CONF global for uniform access
let app_name = CONF::get_string(&quot;app.name&quot;)?;
let stripe_key = CONF::get_string(&quot;payment.stripe_key&quot;)?;
#}</code></pre></pre>
<a class="header" href="print.html#configuration-files-1" id="configuration-files-1"><h2>Configuration Files</h2></a>
<a class="header" href="print.html#file-locations-and-loading-order" id="file-locations-and-loading-order"><h3>File Locations and Loading Order</h3></a>
<ol>
<li><strong>Base Configuration</strong>: <code>config.toml</code></li>
<li><strong>Environment-Specific</strong>: <code>config.{environment}.toml</code></li>
<li><strong>Environment Variables</strong>: <code>RUSTF_*</code> prefixed variables</li>
<li><strong>CLI Arguments</strong>: <code>--config</code> flag</li>
</ol>
<a class="header" href="print.html#example-configtoml" id="example-configtoml"><h3>Example config.toml</h3></a>
<pre><code class="language-toml"># Base configuration for all environments
environment = &quot;development&quot;

[server]
host = &quot;127.0.0.1&quot;
port = 8000
timeout = 30

[views]
directory = &quot;views&quot;
default_layout = &quot;layouts/default&quot;
cache_enabled = false
extension = &quot;html&quot;

[session]
secret = &quot;dev-secret-change-in-production&quot;
timeout = 3600
cookie_name = &quot;rustf_session&quot;

[database]
url = &quot;postgresql://localhost/myapp_dev&quot;
max_connections = 5

[static_files]
directory = &quot;public&quot;
url_prefix = &quot;/static&quot;

[uploads]
directory = &quot;uploads&quot;
max_file_size = 10485760

[custom]
api_endpoint = &quot;http://localhost:3000/api&quot;
feature_x_enabled = &quot;false&quot;
</code></pre>
<a class="header" href="print.html#environment-specific-overrides" id="environment-specific-overrides"><h3>Environment-Specific Overrides</h3></a>
<a class="header" href="print.html#configprodtoml" id="configprodtoml"><h4>config.prod.toml</h4></a>
<pre><code class="language-toml"># Production-specific overrides
environment = &quot;production&quot;

[server]
host = &quot;0.0.0.0&quot;
port = 80
ssl_enabled = true
ssl_cert = &quot;/etc/ssl/certs/app.crt&quot;
ssl_key = &quot;/etc/ssl/private/app.key&quot;
max_connections = 2000

[views]
cache_enabled = true

[session]
secret = &quot;${RUSTF_SESSION_SECRET}&quot;  # Read from environment
secure = true

[database]
url = &quot;${DATABASE_URL}&quot;  # Read from environment
max_connections = 20

[logging]
level = &quot;warn&quot;
file = &quot;/var/log/rustf/app.log&quot;

[custom]
api_endpoint = &quot;https://api.production.com&quot;
feature_x_enabled = &quot;true&quot;
</code></pre>
<a class="header" href="print.html#environment-variables" id="environment-variables"><h2>Environment Variables</h2></a>
<p>All configuration values can be overridden using environment variables with the <code>RUSTF_</code> prefix:</p>
<a class="header" href="print.html#server-settings" id="server-settings"><h3>Server Settings</h3></a>
<pre><code class="language-bash">RUSTF_ENV=production              # Set environment
RUSTF_HOST=0.0.0.0               # Server host
RUSTF_PORT=3000                  # Server port
RUSTF_TIMEOUT=60                 # Request timeout
RUSTF_SSL_ENABLED=true           # Enable SSL
RUSTF_SSL_CERT=/path/to/cert    # SSL certificate
RUSTF_SSL_KEY=/path/to/key      # SSL private key
RUSTF_MAX_CONNECTIONS=5000       # Max connections
</code></pre>
<a class="header" href="print.html#database-settings" id="database-settings"><h3>Database Settings</h3></a>
<pre><code class="language-bash">DATABASE_URL=postgresql://user:pass@host/db  # Database URL (standard)
RUSTF_DATABASE_URL=postgresql://...          # Alternative prefix
RUSTF_DB_MAX_CONNECTIONS=20                  # Pool size
RUSTF_DB_TIMEOUT=10000                       # Timeout in ms
</code></pre>
<a class="header" href="print.html#session-settings" id="session-settings"><h3>Session Settings</h3></a>
<pre><code class="language-bash">RUSTF_SESSION_SECRET=very-secret-key         # Session secret
RUSTF_SESSION_TIMEOUT=7200                   # Session timeout
RUSTF_SESSION_COOKIE_NAME=my_session         # Cookie name
RUSTF_SESSION_SECURE=true                    # Secure cookies
RUSTF_SESSION_HTTP_ONLY=true                 # HttpOnly cookies
</code></pre>
<a class="header" href="print.html#view-settings" id="view-settings"><h3>View Settings</h3></a>
<pre><code class="language-bash">RUSTF_VIEWS_DIR=/app/templates               # Views directory
RUSTF_DEFAULT_LAYOUT=layouts/main            # Default layout
RUSTF_VIEW_CACHE=true                        # Enable caching
RUSTF_TEMPLATE_STORAGE=embedded              # Storage method
</code></pre>
<a class="header" href="print.html#custom-settings" id="custom-settings"><h3>Custom Settings</h3></a>
<pre><code class="language-bash"># Custom settings are accessed with &quot;custom.&quot; prefix in CONF
export RUSTF_CUSTOM_API_KEY=&quot;secret-key&quot;
export RUSTF_CUSTOM_FEATURE_FLAG=&quot;true&quot;

# In code:
let api_key = CONF::get_string(&quot;custom.api_key&quot;);
</code></pre>
<a class="header" href="print.html#loading-configuration" id="loading-configuration"><h2>Loading Configuration</h2></a>
<a class="header" href="print.html#application-startup" id="application-startup"><h3>Application Startup</h3></a>
<p>Configuration is automatically initialized during application startup:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;

#[rustf::auto_discover]
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Configuration is loaded and CONF is initialized automatically
    let app = RustF::with_args()?;  // Loads config with CLI support
    
    // Alternative loading methods:
    // let app = RustF::new();                    // Default config
    // let app = RustF::from_file(&quot;config.toml&quot;)?; // Specific file
    // let app = RustF::from_env()?;              // Environment only
    // let app = RustF::with_config(my_config);   // Programmatic
    
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#cli-arguments" id="cli-arguments"><h3>CLI Arguments</h3></a>
<p>The framework supports configuration via command-line arguments:</p>
<pre><code class="language-bash"># Use default configuration loading
./myapp

# Specify custom config file
./myapp --config /path/to/config.toml
./myapp -c config.prod.toml

# Override views directory (if using filesystem storage)
./myapp --views /path/to/templates
</code></pre>
<a class="header" href="print.html#programmatic-configuration" id="programmatic-configuration"><h3>Programmatic Configuration</h3></a>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;
use rustf::config::AppConfig;

fn main() -&gt; Result&lt;()&gt; {
    // Create configuration programmatically
    let mut config = AppConfig::default();
    config.server.port = 3000;
    config.server.host = &quot;0.0.0.0&quot;.to_string();
    config.database.url = Some(&quot;postgresql://localhost/mydb&quot;.to_string());
    config.custom.insert(&quot;api_key&quot;.to_string(), &quot;secret&quot;.to_string());
    
    // Use the configuration
    let app = RustF::with_config(config);
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#environment-detection" id="environment-detection"><h2>Environment Detection</h2></a>
<p>RustF automatically detects the environment from these sources (in order):</p>
<ol>
<li><code>RUSTF_ENV</code> environment variable</li>
<li><code>RAILS_ENV</code> environment variable (Rails compatibility)</li>
<li><code>NODE_ENV</code> environment variable (Node.js compatibility)</li>
<li>Default: <code>development</code></li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub enum Environment {
    Development,  // Default for local development
    Production,   // Live production environment
}
#}</code></pre></pre>
<a class="header" href="print.html#environment-specific-behavior" id="environment-specific-behavior"><h3>Environment-Specific Behavior</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Check environment in code
let env = CONF::env();  // Returns &quot;development&quot;, &quot;production&quot;, etc.

if CONF::is_production() {
    // Production-specific code
    enable_caching();
    disable_debug_endpoints();
}

if CONF::is_development() {
    // Development-specific code
    enable_hot_reload();
    show_detailed_errors();
}
#}</code></pre></pre>
<a class="header" href="print.html#configuration-validation" id="configuration-validation"><h2>Configuration Validation</h2></a>
<p>RustF validates configuration during startup:</p>
<a class="header" href="print.html#automatic-validation" id="automatic-validation"><h3>Automatic Validation</h3></a>
<ul>
<li>
<p><strong>Required in Production</strong>:</p>
<ul>
<li>Session secret must not be default value</li>
<li>SSL certificate/key paths must exist if SSL is enabled</li>
<li>Database URL is recommended (warns if missing)</li>
</ul>
</li>
<li>
<p><strong>Path Validation</strong>:</p>
<ul>
<li>Views directory should exist (warns if missing)</li>
<li>Static files directory must exist</li>
<li>Upload directory is created if missing</li>
</ul>
</li>
<li>
<p><strong>Type Validation</strong>:</p>
<ul>
<li>Port must be valid (1-65535)</li>
<li>Timeouts must be positive</li>
<li>File sizes must be reasonable</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#custom-validation" id="custom-validation"><h3>Custom Validation</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

app.on(&quot;config.loaded&quot;, |ctx| Box::pin(async move {
    // Validate custom configuration
    if !CONF::has(&quot;custom.api_key&quot;) {
        return Err(Error::internal(&quot;API key is required in configuration&quot;));
    }
    
    let api_key = CONF::get_string(&quot;custom.api_key&quot;).unwrap();
    if api_key.len() &lt; 32 {
        return Err(Error::internal(&quot;API key must be at least 32 characters&quot;));
    }
    
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#unified-configuration-access" id="unified-configuration-access"><h2>Unified Configuration Access</h2></a>
<p>RustF provides a completely unified approach to configuration access - all configuration sections (framework-defined and user-defined) can be accessed using the same patterns:</p>
<a class="header" href="print.html#three-ways-to-access-configuration" id="three-ways-to-access-configuration"><h3>Three Ways to Access Configuration</h3></a>
<a class="header" href="print.html#1-global-conf-singleton-recommended-for-runtime-access" id="1-global-conf-singleton-recommended-for-runtime-access"><h4>1. Global CONF Singleton (Recommended for Runtime Access)</h4></a>
<p>The CONF singleton provides dot-notation access to ANY configuration section:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

// Framework sections
let port = CONF::get_int(&quot;server.port&quot;)?;
let cache_enabled = CONF::get_bool(&quot;views.cache_enabled&quot;)?;

// Custom app sections - same syntax!
let app_name = CONF::get_string(&quot;app.name&quot;)?;
let stripe_key = CONF::get_string(&quot;payment.stripe_key&quot;)?;
let smtp_port = CONF::get_int(&quot;smtp.port&quot;)?;
#}</code></pre></pre>
<a class="header" href="print.html#2-appconfigsection-method-type-safe-access" id="2-appconfigsection-method-type-safe-access"><h4>2. AppConfig.section() Method (Type-Safe Access)</h4></a>
<p>For custom sections, use the <code>section()</code> method to get type-safe deserialized access:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;
use serde::Deserialize;

#[derive(Deserialize)]
struct SmtpConfig {
    host: String,
    port: u16,
    user: String,
    password: String,
}

// Get the full section as a typed struct
let smtp = config.section::&lt;SmtpConfig&gt;(&quot;smtp&quot;)?;
println!(&quot;SMTP: {}:{}&quot;, smtp.host, smtp.port);
#}</code></pre></pre>
<a class="header" href="print.html#3-templates-automatic-json-serialization" id="3-templates-automatic-json-serialization"><h4>3. Templates (Automatic JSON Serialization)</h4></a>
<p>Templates automatically have access to all configuration sections through the CONF global:</p>
<pre><code class="language-html">&lt;!-- Framework sections --&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;
&lt;script&gt;
    const port = @{CONF.server.port};
    const cacheEnabled = @{CONF.views.cache_enabled};
&lt;/script&gt;

&lt;!-- Custom app sections - same access pattern --&gt;
&lt;h1&gt;@{CONF.app.name} v@{CONF.app.version}&lt;/h1&gt;
&lt;script&gt;
    const stripeKey = '@{CONF.payment.stripe_key}';
    const smtpHost = '@{CONF.smtp.host}';
&lt;/script&gt;
</code></pre>
<a class="header" href="print.html#why-unified-access-matters" id="why-unified-access-matters"><h3>Why Unified Access Matters</h3></a>
<p>The unified approach eliminates cognitive overhead:</p>
<ul>
<li><strong>No special buckets</strong>: Custom sections aren't forced into <code>custom</code> or <code>extra</code> maps</li>
<li><strong>One pattern</strong>: Whether accessing <code>server.port</code> or <code>app.name</code>, the syntax is identical</li>
<li><strong>IDE support</strong>: Framework sections have typed IDE support; app sections work with runtime access</li>
<li><strong>Template consistency</strong>: Templates access all sections uniformly</li>
<li><strong>AI-friendly</strong>: One way to do things reduces confusion for human developers and AI assistants</li>
</ul>
<a class="header" href="print.html#best-practices-12" id="best-practices-12"><h2>Best Practices</h2></a>
<a class="header" href="print.html#1-use-environment-variables-for-secrets" id="1-use-environment-variables-for-secrets"><h3>1. Use Environment Variables for Secrets</h3></a>
<pre><code class="language-toml"># config.production.toml
[session]
secret = &quot;${RUSTF_SESSION_SECRET}&quot;  # Never hardcode production secrets

[database]
url = &quot;${DATABASE_URL}&quot;              # Use environment variable

[custom]
api_key = &quot;${API_KEY}&quot;               # External service credentials
</code></pre>
<a class="header" href="print.html#2-environment-specific-files" id="2-environment-specific-files"><h3>2. Environment-Specific Files</h3></a>
<pre><code>config.toml          # Base configuration
config.dev.toml      # Development overrides
config.prod.toml     # Production settings
</code></pre>
<a class="header" href="print.html#3-custom-settings-organization" id="3-custom-settings-organization"><h3>3. Custom Settings Organization</h3></a>
<pre><code class="language-toml">[custom]
# Group related settings with prefixes
smtp_host = &quot;smtp.gmail.com&quot;
smtp_port = &quot;587&quot;
smtp_user = &quot;user@gmail.com&quot;
smtp_password = &quot;${SMTP_PASSWORD}&quot;

redis_url = &quot;redis://localhost:6379&quot;
redis_prefix = &quot;myapp:&quot;

feature_new_ui = &quot;false&quot;
feature_beta_api = &quot;true&quot;
</code></pre>
<a class="header" href="print.html#4-access-patterns" id="4-access-patterns"><h3>4. Access Patterns</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Use CONF for all configuration access (available in prelude)
use rustf::prelude::*;

let port = CONF::get_int(&quot;server.port&quot;).unwrap_or(8000);
let db_url = CONF::get_string(&quot;database.url&quot;);

// âŒ Bad: Don't try to access config through Context
// ctx.config() // This method no longer exists!

// âœ… Good: Check existence before accessing
if CONF::has(&quot;custom.smtp_host&quot;) {
    setup_email_service();
}

// âœ… Good: Use typed getters for safety
let enabled = CONF::get_bool(&quot;custom.feature_enabled&quot;).unwrap_or(false);
let timeout = CONF::get_int(&quot;server.timeout&quot;).unwrap_or(30);

// âœ… Good: Use defaults for optional settings
let cache_size = CONF::get_or(&quot;custom.cache_size&quot;, 100);
#}</code></pre></pre>
<a class="header" href="print.html#5-testing-configuration" id="5-testing-configuration"><h3>5. Testing Configuration</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use rustf::config::AppConfig;
    
    #[test]
    fn test_configuration_loading() {
        let config = AppConfig::from_file(&quot;config.test.toml&quot;).unwrap();
        
        // Initialize CONF for testing
        CONF::init(config).unwrap();
        
        // Test configuration values
        assert_eq!(CONF::get_int(&quot;server.port&quot;), Some(8080));
        assert_eq!(CONF::env(), Some(&quot;testing&quot;.to_string()));
        assert!(CONF::has(&quot;database.url&quot;));
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#migration-from-context-config" id="migration-from-context-config"><h2>Migration from Context Config</h2></a>
<p>If you're migrating from an older version of RustF that had <code>ctx.config()</code>:</p>
<a class="header" href="print.html#before-old-way" id="before-old-way"><h3>Before (Old Way)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn handler(ctx: Context) -&gt; Result&lt;Response&gt; {
    let upload_dir = ctx.config().uploads.directory.clone();
    let max_size = ctx.config().uploads.max_file_size;
    // ...
}
#}</code></pre></pre>
<a class="header" href="print.html#after-new-way" id="after-new-way"><h3>After (New Way)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;  // CONF is included in the prelude

async fn handler(ctx: Context) -&gt; Result&lt;Response&gt; {
    let upload_dir = CONF::get_string(&quot;uploads.directory&quot;).unwrap_or_else(|| &quot;uploads&quot;.to_string());
    let max_size = CONF::get_int(&quot;uploads.max_file_size&quot;).unwrap_or(10485760);
    // ...
}
#}</code></pre></pre>
<a class="header" href="print.html#configuration-examples" id="configuration-examples"><h2>Configuration Examples</h2></a>
<a class="header" href="print.html#minimal-configuration" id="minimal-configuration"><h3>Minimal Configuration</h3></a>
<pre><code class="language-toml"># config.toml - Minimal configuration using defaults
[server]
port = 3000

[database]
url = &quot;postgresql://localhost/myapp&quot;
</code></pre>
<a class="header" href="print.html#full-production-configuration" id="full-production-configuration"><h3>Full Production Configuration</h3></a>
<pre><code class="language-toml"># config.prod.toml
environment = &quot;production&quot;

[server]
host = &quot;0.0.0.0&quot;
port = 443
timeout = 60
ssl_enabled = true
ssl_cert = &quot;/etc/letsencrypt/live/example.com/fullchain.pem&quot;
ssl_key = &quot;/etc/letsencrypt/live/example.com/privkey.pem&quot;
max_connections = 5000

[views]
directory = &quot;/app/views&quot;
default_layout = &quot;layouts/default&quot;
cache_enabled = true
storage = &quot;embedded&quot;  # Use embedded templates in production

[session]
secret = &quot;${SESSION_SECRET}&quot;  # From environment
timeout = 86400  # 24 hours
cookie_name = &quot;app_session&quot;
secure = true
http_only = true

[session.storage]
type = &quot;redis&quot;
url = &quot;${REDIS_URL}&quot;
prefix = &quot;session:&quot;
pool_size = 10

[database]
url = &quot;${DATABASE_URL}&quot;
max_connections = 50
timeout = 10000

[static_files]
directory = &quot;/app/public&quot;
url_prefix = &quot;/static&quot;
cache_enabled = true
cache_max_age = 2592000  # 30 days

[cors]
enabled = true
allowed_origins = [&quot;https://example.com&quot;, &quot;https://app.example.com&quot;]
allowed_methods = [&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;]
allowed_headers = [&quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;X-Requested-With&quot;]

[logging]
level = &quot;info&quot;
file = &quot;/var/log/app/production.log&quot;

[uploads]
directory = &quot;/app/storage/uploads&quot;
max_file_size = 52428800  # 50MB
max_files = 10
allowed_extensions = [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;png&quot;, &quot;gif&quot;, &quot;pdf&quot;, &quot;doc&quot;, &quot;docx&quot;]
create_directories = true

[custom]
cdn_url = &quot;https://cdn.example.com&quot;
api_endpoint = &quot;https://api.example.com/v1&quot;
smtp_host = &quot;smtp.sendgrid.net&quot;
smtp_port = &quot;587&quot;
smtp_user = &quot;apikey&quot;
smtp_password = &quot;${SENDGRID_API_KEY}&quot;
from_email = &quot;noreply@example.com&quot;
support_email = &quot;support@example.com&quot;
google_analytics_id = &quot;UA-XXXXXXXXX-X&quot;
stripe_public_key = &quot;${STRIPE_PUBLIC_KEY}&quot;
stripe_secret_key = &quot;${STRIPE_SECRET_KEY}&quot;
redis_url = &quot;${REDIS_URL}&quot;
elasticsearch_url = &quot;${ELASTICSEARCH_URL}&quot;
feature_new_dashboard = &quot;true&quot;
feature_beta_api = &quot;false&quot;
maintenance_mode = &quot;false&quot;
rate_limit_requests = &quot;1000&quot;
rate_limit_window = &quot;3600&quot;
</code></pre>
<a class="header" href="print.html#troubleshooting-2" id="troubleshooting-2"><h2>Troubleshooting</h2></a>
<a class="header" href="print.html#configuration-not-loading" id="configuration-not-loading"><h3>Configuration Not Loading</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Check if CONF is initialized
if !CONF::is_initialized() {
    panic!(&quot;Configuration not initialized!&quot;);
}

// Check what environment is loaded
let env = CONF::env().unwrap_or_else(|| &quot;unknown&quot;.to_string());
println!(&quot;Running in {} environment&quot;, env);

// Debug configuration values
if let Some(config) = CONF::all() {
    println!(&quot;Server port: {}&quot;, config.server.port);
    println!(&quot;Database URL: {:?}&quot;, config.database.url);
}
#}</code></pre></pre>
<a class="header" href="print.html#environment-variables-not-working" id="environment-variables-not-working"><h3>Environment Variables Not Working</h3></a>
<pre><code class="language-bash"># Make sure to export variables
export RUSTF_PORT=3000
export DATABASE_URL=&quot;postgresql://localhost/mydb&quot;

# Or set them when running
RUSTF_ENV=production DATABASE_URL=&quot;...&quot; cargo run
</code></pre>
<a class="header" href="print.html#custom-values-not-accessible" id="custom-values-not-accessible"><h3>Custom Values Not Accessible</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Custom values must be in [custom] section
// config.toml:
// [custom]
// my_value = &quot;test&quot;

// Access with &quot;custom.&quot; prefix:
let value = CONF::get_string(&quot;custom.my_value&quot;);  // âœ… Correct
let value = CONF::get_string(&quot;my_value&quot;);         // âŒ Wrong
#}</code></pre></pre>
<a class="header" href="print.html#summary-2" id="summary-2"><h2>Summary</h2></a>
<p>RustF's configuration system provides:</p>
<p>âœ… <strong>Single Access Point</strong> - Global CONF for uniform configuration access<br />
âœ… <strong>Dot Notation</strong> - Clean path-based access to nested values<br />
âœ… <strong>Multiple Sources</strong> - Files, environment variables, and code<br />
âœ… <strong>Environment Support</strong> - Development and production configs<br />
âœ… <strong>Type Safety</strong> - Typed getters for different value types<br />
âœ… <strong>Validation</strong> - Automatic validation for production requirements<br />
âœ… <strong>Extensibility</strong> - Custom settings for application-specific config<br />
âœ… <strong>AI-Friendly</strong> - One way to do things reduces confusion</p>
<p>The configuration system follows the principle of &quot;convention over configuration&quot; while still providing the flexibility needed for complex applications. By using the global CONF accessor exclusively, the codebase remains consistent and easy to understand for both humans and AI assistants.</p>
<a class="header" href="print.html#rustf-csrf-protection-guide" id="rustf-csrf-protection-guide"><h1>RustF CSRF Protection Guide</h1></a>
<p>ğŸ”’ <strong>Comprehensive Cross-Site Request Forgery Protection</strong></p>
<p>This guide covers RustF's automatic CSRF protection system, designed for both security and developer productivity with zero-configuration defaults and extensive customization options.</p>
<a class="header" href="print.html#table-of-contents-1" id="table-of-contents-1"><h2>Table of Contents</h2></a>
<ul>
<li><a href="print.html#overview">Overview</a></li>
<li><a href="print.html#quick-start">Quick Start</a></li>
<li><a href="print.html#automatic-protection">Automatic Protection</a></li>
<li><a href="print.html#configuration">Configuration</a></li>
<li><a href="print.html#route-exemptions">Route Exemptions</a></li>
<li><a href="print.html#token-management">Token Management</a></li>
<li><a href="print.html#context-integration">Context Integration</a></li>
<li><a href="print.html#error-handling">Error Handling</a></li>
<li><a href="print.html#ajax-integration">AJAX Integration</a></li>
<li><a href="print.html#form-integration">Form Integration</a></li>
<li><a href="print.html#advanced-usage">Advanced Usage</a></li>
<li><a href="print.html#troubleshooting">Troubleshooting</a></li>
<li><a href="print.html#best-practices">Best Practices</a></li>
</ul>
<a class="header" href="print.html#overview-7" id="overview-7"><h2>Overview</h2></a>
<p>Cross-Site Request Forgery (CSRF) attacks trick users into performing unintended actions by exploiting their authenticated sessions. RustF provides comprehensive CSRF protection through:</p>
<a class="header" href="print.html#key-features-3" id="key-features-3"><h3>Key Features</h3></a>
<p>âœ… <strong>One-Time Use Tokens</strong> - Tokens are consumed after successful verification (prevents replay attacks)<br />
âœ… <strong>Token Expiration</strong> - Tokens automatically expire after 1 hour<br />
âœ… <strong>Multiple Concurrent Tokens</strong> - Support different token IDs for different forms<br />
âœ… <strong>Automatic HTTP Method Detection</strong> - Only unsafe methods (POST, PUT, PATCH, DELETE) require validation<br />
âœ… <strong>Session Integration</strong> - Tokens stored and validated via the session system<br />
âœ… <strong>Route Exemption Patterns</strong> - Flexible wildcard and exact matching<br />
âœ… <strong>Multiple Token Sources</strong> - Headers, form fields, and query parameters<br />
âœ… <strong>Smart Error Handling</strong> - Context-aware responses (JSON for APIs, HTML for web)<br />
âœ… <strong>Zero Configuration</strong> - Works out-of-the-box with sensible defaults<br />
âœ… <strong>Context Methods</strong> - Convenient <code>verify_csrf()</code> and <code>generate_csrf()</code> methods</p>
<a class="header" href="print.html#protection-scope" id="protection-scope"><h3>Protection Scope</h3></a>
<p><strong>Protected Methods (Require CSRF token):</strong></p>
<ul>
<li><code>POST</code> - Create operations</li>
<li><code>PUT</code> - Full resource updates</li>
<li><code>PATCH</code> - Partial resource updates</li>
<li><code>DELETE</code> - Resource deletion</li>
</ul>
<p><strong>Safe Methods (Bypass CSRF):</strong></p>
<ul>
<li><code>GET</code> - Read operations</li>
<li><code>HEAD</code> - Header-only requests</li>
<li><code>OPTIONS</code> - CORS preflight requests</li>
</ul>
<a class="header" href="print.html#quick-start-2" id="quick-start-2"><h2>Quick Start</h2></a>
<a class="header" href="print.html#basic-setup" id="basic-setup"><h3>Basic Setup</h3></a>
<p>Add CSRF protection with zero configuration:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;
use rustf::security::CsrfMiddleware;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let mut app = RustF::new();
    
    // Enable CSRF protection (default configuration)
    app.middleware(&quot;csrf&quot;, CsrfMiddleware::new());
    
    // Your routes - CSRF automatically applied
    app.post(&quot;/users&quot;, create_user_handler);         // Protected
    app.put(&quot;/users/:id&quot;, update_user_handler);      // Protected  
    app.delete(&quot;/users/:id&quot;, delete_user_handler);   // Protected
    app.get(&quot;/users&quot;, list_users_handler);           // Not protected
    
    app.listen(&quot;127.0.0.1:8080&quot;).await?;
    Ok(())
}

async fn create_user_handler(ctx: Context) -&gt; Result&lt;Response&gt; {
    // CSRF already validated by middleware
    let form_data = ctx.body_form()?;
    
    // Process request normally
    let user = create_user(&amp;form_data).await?;
    ctx.json(json!({&quot;message&quot;: &quot;User created&quot;, &quot;id&quot;: user.id}))
}
</code></pre></pre>
<a class="header" href="print.html#default-behavior-1" id="default-behavior-1"><h3>Default Behavior</h3></a>
<p>With zero configuration, the CSRF middleware:</p>
<ul>
<li>Protects POST, PUT, PATCH, DELETE requests</li>
<li>Exempts all <code>/api/*</code> routes (configurable)</li>
<li>Stores tokens in the session</li>
<li>Returns appropriate error responses</li>
</ul>
<a class="header" href="print.html#automatic-protection" id="automatic-protection"><h2>Automatic Protection</h2></a>
<a class="header" href="print.html#http-method-based-protection" id="http-method-based-protection"><h3>HTTP Method-Based Protection</h3></a>
<p>CSRF protection is applied automatically based on HTTP methods:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// These routes are automatically protected:
app.post(&quot;/users&quot;, create_user);           // âœ… CSRF Required
app.put(&quot;/users/:id&quot;, update_user);        // âœ… CSRF Required  
app.patch(&quot;/users/:id&quot;, partial_update);   // âœ… CSRF Required
app.delete(&quot;/users/:id&quot;, delete_user);     // âœ… CSRF Required

// These routes bypass CSRF protection:
app.get(&quot;/users&quot;, list_users);             // â­ï¸ CSRF Bypassed
app.head(&quot;/users/:id&quot;, check_user);        // â­ï¸ CSRF Bypassed
app.options(&quot;/users&quot;, cors_preflight);     // â­ï¸ CSRF Bypassed
#}</code></pre></pre>
<a class="header" href="print.html#session-integration" id="session-integration"><h3>Session Integration</h3></a>
<p>CSRF tokens are automatically managed through the session system:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Token lifecycle (handled automatically):
// 1. Generate token: stored in session[&quot;_csrf_token&quot;]
// 2. Validate token: compare submitted vs stored
// 3. Token persistence: lives with the session
// 4. Token regeneration: on session regeneration
#}</code></pre></pre>
<a class="header" href="print.html#configuration-1" id="configuration-1"><h2>Configuration</h2></a>
<a class="header" href="print.html#custom-configuration" id="custom-configuration"><h3>Custom Configuration</h3></a>
<p>Create a custom CSRF configuration for advanced scenarios:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::security::{CsrfMiddleware, CsrfConfig};

let csrf_config = CsrfConfig::new()
    // Route exemptions
    .exempt(&quot;/webhook/github&quot;)              // Specific webhook
    .exempt(&quot;/webhook/*&quot;)                   // All webhook routes  
    .exempt(&quot;/api/public/*&quot;)               // Public API endpoints
    .exempt(&quot;/uploads/process&quot;)             // File processing endpoint
    
    // Error handling
    .error_message(&quot;Security validation failed. Please refresh and try again.&quot;)
    .redirect_on_failure(&quot;/login&quot;)          // Redirect instead of error page
    .flash_error_key(&quot;security_error&quot;)      // Custom flash message key
    
    // HTTP method customization
    .protect_method(&quot;CUSTOM&quot;)               // Add custom method protection
    .exempt_method(&quot;DELETE&quot;);               // Remove DELETE protection

let csrf_middleware = CsrfMiddleware::with_config(csrf_config);
app.middleware(&quot;csrf&quot;, csrf_middleware);
#}</code></pre></pre>
<a class="header" href="print.html#configuration-builder-methods" id="configuration-builder-methods"><h3>Configuration Builder Methods</h3></a>
<table><thead><tr><th> Method </th><th> Description </th><th> Example </th></tr></thead><tbody>
<tr><td> <code>exempt(route)</code> </td><td> Add route exemption pattern </td><td> <code>.exempt(&quot;/api/*&quot;)</code> </td></tr>
<tr><td> <code>error_message(msg)</code> </td><td> Custom error message </td><td> <code>.error_message(&quot;Token expired&quot;)</code> </td></tr>
<tr><td> <code>redirect_on_failure(url)</code> </td><td> Redirect URL on failure </td><td> <code>.redirect_on_failure(&quot;/login&quot;)</code> </td></tr>
<tr><td> <code>flash_error_key(key)</code> </td><td> Flash message key </td><td> <code>.flash_error_key(&quot;csrf_error&quot;)</code> </td></tr>
<tr><td> <code>disabled()</code> </td><td> Disable CSRF globally </td><td> <code>.disabled()</code> </td></tr>
<tr><td> <code>protect_method(method)</code> </td><td> Add protected HTTP method </td><td> <code>.protect_method(&quot;CUSTOM&quot;)</code> </td></tr>
<tr><td> <code>exempt_method(method)</code> </td><td> Remove method protection </td><td> <code>.exempt_method(&quot;PUT&quot;)</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#route-exemptions" id="route-exemptions"><h2>Route Exemptions</h2></a>
<a class="header" href="print.html#pattern-matching" id="pattern-matching"><h3>Pattern Matching</h3></a>
<p>CSRF route exemptions support both exact matches and wildcard patterns:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let csrf_config = CsrfConfig::new()
    // Exact matches
    .exempt(&quot;/webhook&quot;)                     // Only /webhook
    .exempt(&quot;/public/upload&quot;)               // Only /public/upload
    
    // Wildcard patterns  
    .exempt(&quot;/api/*&quot;)                       // /api/users, /api/v1/posts, etc.
    .exempt(&quot;/webhook/*&quot;)                   // /webhook/github, /webhook/stripe, etc.
    .exempt(&quot;/admin/*/public&quot;);             // /admin/users/public, /admin/posts/public, etc.
#}</code></pre></pre>
<a class="header" href="print.html#pattern-examples" id="pattern-examples"><h3>Pattern Examples</h3></a>
<table><thead><tr><th> Pattern </th><th> Matches </th><th> Doesn't Match </th></tr></thead><tbody>
<tr><td> <code>/api/*</code> </td><td> <code>/api/users</code>, <code>/api/v1/data</code> </td><td> <code>/api</code>, <code>/public/api</code> </td></tr>
<tr><td> <code>/webhook/github</code> </td><td> <code>/webhook/github</code> </td><td> <code>/webhook/github/push</code> </td></tr>
<tr><td> <code>/public/upload</code> </td><td> <code>/public/upload</code> </td><td> <code>/public/uploads</code> </td></tr>
</tbody></table>
<a class="header" href="print.html#default-exemptions" id="default-exemptions"><h3>Default Exemptions</h3></a>
<p>By default, all <code>/api/*</code> routes are exempt. To change this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Remove default exemptions and add custom ones
let csrf_config = CsrfConfig::new()
    .exempt(&quot;/external/webhooks/*&quot;)     // Custom exemption
    .exempt(&quot;/integrations/*&quot;);         // Another exemption
    // Note: This removes the default /api/* exemption
#}</code></pre></pre>
<a class="header" href="print.html#common-exemption-patterns" id="common-exemption-patterns"><h3>Common Exemption Patterns</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Webhooks and integrations
.exempt(&quot;/webhook/*&quot;)
.exempt(&quot;/integration/*&quot;) 
.exempt(&quot;/callback/*&quot;)

// Public APIs  
.exempt(&quot;/api/public/*&quot;)
.exempt(&quot;/api/v1/status&quot;)
.exempt(&quot;/api/health&quot;)

// File uploads from external sources
.exempt(&quot;/upload/external/*&quot;)
.exempt(&quot;/cdn/callback&quot;)

// Payment gateways
.exempt(&quot;/payment/stripe/webhook&quot;)
.exempt(&quot;/payment/paypal/ipn&quot;)
#}</code></pre></pre>
<a class="header" href="print.html#token-management" id="token-management"><h2>Token Management</h2></a>
<a class="header" href="print.html#automatic-token-generation" id="automatic-token-generation"><h3>Automatic Token Generation</h3></a>
<p>CSRF tokens are generated and managed automatically:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Token generation happens automatically when:
// 1. First CSRF-protected request is made
// 2. ctx.generate_csrf() is called explicitly

async fn show_form(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Automatically generates and stores token in session
    ctx.generate_csrf()?;
    
    // Token is accessible in templates via @{csrf_token} and @{csrf}
    ctx.view(&quot;user/form&quot;, json!({
        &quot;user&quot;: load_user_data().await?
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#token-properties" id="token-properties"><h3>Token Properties</h3></a>
<ul>
<li><strong>Format</strong>: Base64-encoded random bytes (32 bytes = ~44 characters)</li>
<li><strong>Storage</strong>: Session key <code>_csrf_token</code> (or custom ID) with JSON structure: <code>{&quot;token&quot;: &quot;...&quot;, &quot;valid_to&quot;: timestamp}</code></li>
<li><strong>Lifetime</strong>: 1 hour from generation (configurable)</li>
<li><strong>Usage</strong>: One-time use - consumed after successful verification</li>
<li><strong>Security</strong>: Cryptographically secure random generation</li>
</ul>
<a class="header" href="print.html#token-lifecycle" id="token-lifecycle"><h3>Token Lifecycle</h3></a>
<p>Tokens follow a secure lifecycle:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 1. Generation - Token created with expiration
let token = ctx.generate_csrf(None)?;  // Default token
let custom = ctx.generate_csrf(Some(&quot;upload_csrf&quot;))?;  // Custom ID

// 2. Verification - Token consumed (one-time use)
if ctx.verify_csrf(None)? {  // Default token
    // Token is valid and now removed from session
}

// 3. Expiration - Tokens expire after 1 hour
// Expired tokens are automatically removed on verification attempt

// 4. Session destruction - All tokens cleared
ctx.session.destroy();  // All tokens removed
#}</code></pre></pre>
<a class="header" href="print.html#context-integration" id="context-integration"><h2>Context Integration</h2></a>
<a class="header" href="print.html#context-methods-1" id="context-methods-1"><h3>Context Methods</h3></a>
<p>RustF provides convenient methods on the Context for CSRF operations:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn form_controller(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Generate CSRF token (stored in session)
    let csrf_token = ctx.generate_csrf()?;
    
    // Manual verification (usually not needed due to middleware)
    if !ctx.verify_csrf()? {
        return ctx.throw403(Some(&quot;CSRF validation failed&quot;));
    }
    
    // Token is accessible in templates
    ctx.view(&quot;form&quot;, json!({
        &quot;user_data&quot;: load_user().await?
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#method-details" id="method-details"><h3>Method Details</h3></a>
<a class="header" href="print.html#ctxgenerate_csrftoken_id-optionstr" id="ctxgenerate_csrftoken_id-optionstr"><h4><code>ctx.generate_csrf(token_id: Option&lt;&amp;str&gt;)</code></h4></a>
<p>Generates a new CSRF token with optional custom ID and stores it in the session:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn api_csrf_token(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Default token
    let token = ctx.generate_csrf(None)?;
    
    // Custom token for specific form
    let upload_token = ctx.generate_csrf(Some(&quot;upload_csrf&quot;))?;
    
    ctx.json(json!({
        &quot;csrf_token&quot;: token,
        &quot;upload_token&quot;: upload_token,
        &quot;expires_in&quot;: &quot;1 hour&quot;,
        &quot;usage&quot;: &quot;one-time&quot;
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#ctxverify_csrftoken_id-optionstr" id="ctxverify_csrftoken_id-optionstr"><h4><code>ctx.verify_csrf(token_id: Option&lt;&amp;str&gt;)</code></h4></a>
<p>Manually verify and consume CSRF token (rarely needed due to middleware):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn manual_verification(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Verify default token (consumed after successful verification)
    match ctx.verify_csrf(None)? {
        true =&gt; {
            // Token was valid and is now consumed
            ctx.json(json!({&quot;message&quot;: &quot;Token valid and consumed&quot;}))
        }
        false =&gt; {
            // Token is invalid, expired, or missing
            ctx.throw403(Some(&quot;CSRF token validation failed&quot;))
        }
    }
}

// Verify custom token
async fn verify_upload(ctx: Context) -&gt; Result&lt;Response&gt; {
    if ctx.verify_csrf(Some(&quot;upload_csrf&quot;))? {
        // Upload token valid and consumed
        process_upload(&amp;ctx).await
    } else {
        ctx.throw403(Some(&quot;Invalid upload token&quot;))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#csrf-token-in-templates" id="csrf-token-in-templates"><h4>CSRF Token in Templates</h4></a>
<p>CSRF tokens support multiple forms with different token IDs:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn show_forms(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Generate multiple tokens for different forms
    ctx.generate_csrf(None)?;  // Default token
    ctx.generate_csrf(Some(&quot;upload_csrf&quot;))?;  // Upload form
    ctx.generate_csrf(Some(&quot;api_csrf&quot;))?;  // API calls
    
    // Tokens accessible in templates:
    // - @{csrf} - hidden input with default token
    // - @{csrf(&quot;upload_csrf&quot;)} - hidden input with custom token
    // - @{csrf_token} - default token value
    // - @{csrf_token.upload_csrf} - custom token value
    
    ctx.view(&quot;forms/multi&quot;, json!({
        &quot;user&quot;: load_user_data().await?
    }))
}
#}</code></pre></pre>
<p><strong>Template Usage:</strong></p>
<pre><code class="language-html">&lt;!-- Default token --&gt;
&lt;form method=&quot;POST&quot;&gt;
    @{csrf}  &lt;!-- &lt;input type=&quot;hidden&quot; name=&quot;_csrf_token&quot; value=&quot;...&quot;&gt; --&gt;
&lt;/form&gt;

&lt;!-- Custom token --&gt;
&lt;form method=&quot;POST&quot; action=&quot;/upload&quot;&gt;
    @{csrf(&quot;upload_csrf&quot;)}  &lt;!-- &lt;input type=&quot;hidden&quot; name=&quot;upload_csrf&quot; value=&quot;...&quot;&gt; --&gt;
&lt;/form&gt;

&lt;!-- Token values for JavaScript --&gt;
&lt;script&gt;
    const defaultToken = &quot;@{csrf_token}&quot;;
    const uploadToken = &quot;@{csrf_token.upload_csrf}&quot;;
    const apiToken = &quot;@{csrf_token.api_csrf}&quot;;
&lt;/script&gt;
</code></pre>
<a class="header" href="print.html#error-handling-5" id="error-handling-5"><h2>Error Handling</h2></a>
<a class="header" href="print.html#automatic-error-responses" id="automatic-error-responses"><h3>Automatic Error Responses</h3></a>
<p>CSRF failures are handled intelligently based on the request type:</p>
<a class="header" href="print.html#api-requests-json-response" id="api-requests-json-response"><h4>API Requests (JSON Response)</h4></a>
<p>For requests expecting JSON (detected by headers):</p>
<pre><code class="language-json">{
    &quot;error&quot;: &quot;csrf_token_invalid&quot;,
    &quot;message&quot;: &quot;CSRF token validation failed. Please try again.&quot;
}
</code></pre>
<p>HTTP Status: <code>403 Forbidden</code></p>
<a class="header" href="print.html#web-requests-html-response" id="web-requests-html-response"><h4>Web Requests (HTML Response)</h4></a>
<p>For regular web requests:</p>
<ul>
<li>Returns HTTP <code>403 Forbidden</code> with error page</li>
<li>OR redirects to configured URL with flash message</li>
</ul>
<a class="header" href="print.html#custom-error-handling" id="custom-error-handling"><h3>Custom Error Handling</h3></a>
<p>Configure custom error responses:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let csrf_config = CsrfConfig::new()
    // Custom error message
    .error_message(&quot;Security token expired. Please refresh the page.&quot;)
    
    // Redirect instead of error page
    .redirect_on_failure(&quot;/login&quot;)
    
    // Custom flash message key
    .flash_error_key(&quot;security_alert&quot;);

app.middleware(&quot;csrf&quot;, CsrfMiddleware::with_config(csrf_config));

// In your login template, show the flash message:
// {{#if flash.security_alert}}
//     &lt;div class=&quot;alert alert-danger&quot;&gt;{{flash.security_alert}}&lt;/div&gt;  
// {{/if}}
#}</code></pre></pre>
<a class="header" href="print.html#error-detection" id="error-detection"><h3>Error Detection</h3></a>
<p>The middleware detects request type using:</p>
<ol>
<li><code>Accept</code> header containing <code>application/json</code></li>
<li><code>Content-Type</code> header containing <code>application/json</code></li>
<li>Request path starting with <code>/api/</code> (if not exempted)</li>
</ol>
<a class="header" href="print.html#ajax-integration" id="ajax-integration"><h2>AJAX Integration</h2></a>
<a class="header" href="print.html#frontend-csrf-token-fetching" id="frontend-csrf-token-fetching"><h3>Frontend CSRF Token Fetching</h3></a>
<p>Create an endpoint to provide CSRF tokens for AJAX requests:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// CSRF token endpoint
async fn csrf_token_api(ctx: Context) -&gt; Result&lt;Response&gt; {
    let token = ctx.generate_csrf()?;
    
    ctx.json(json!({
        &quot;csrf_token&quot;: token,
        &quot;field_name&quot;: &quot;_token&quot;,
        &quot;header_name&quot;: &quot;X-CSRF-Token&quot;
    }))
}

// Register the endpoint (this bypasses CSRF as it's a GET request)
app.get(&quot;/api/csrf-token&quot;, csrf_token_api);
#}</code></pre></pre>
<a class="header" href="print.html#javascript-integration" id="javascript-integration"><h3>JavaScript Integration</h3></a>
<pre><code class="language-javascript">// Fetch CSRF token
async function getCsrfToken() {
    const response = await fetch('/api/csrf-token');
    if (!response.ok) throw new Error('Failed to fetch CSRF token');
    const data = await response.json();
    return data.csrf_token;
}

// Method 1: HTTP Header (Recommended)
const csrfToken = await getCsrfToken();

const response = await fetch('/api/users', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken  // Header method
    },
    body: JSON.stringify({
        name: 'John Doe',
        email: 'john@example.com'
    })
});

// Method 2: Form Data
const formData = new FormData();
formData.append('name', 'John Doe');
formData.append('email', 'john@example.com');
formData.append('_token', csrfToken);  // Form field method

await fetch('/api/users', {
    method: 'POST',
    body: formData
});

// Method 3: Query Parameter
await fetch(`/api/users?_token=${csrfToken}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(userData)
});
</code></pre>
<a class="header" href="print.html#global-ajax-setup" id="global-ajax-setup"><h3>Global AJAX Setup</h3></a>
<p>Set up CSRF token globally for all AJAX requests:</p>
<pre><code class="language-javascript">class CsrfManager {
    constructor() {
        this.token = null;
        this.tokenPromise = null;
    }
    
    async getToken() {
        if (!this.tokenPromise) {
            this.tokenPromise = this.fetchToken();
        }
        return this.tokenPromise;
    }
    
    async fetchToken() {
        const response = await fetch('/api/csrf-token');
        const data = await response.json();
        this.token = data.csrf_token;
        return this.token;
    }
    
    async apiCall(url, options = {}) {
        const token = await this.getToken();
        
        const headers = {
            ...options.headers,
            'X-CSRF-Token': token
        };
        
        return fetch(url, { ...options, headers });
    }
}

// Global instance
const csrf = new CsrfManager();

// Usage
await csrf.apiCall('/api/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(userData)
});
</code></pre>
<a class="header" href="print.html#form-integration" id="form-integration"><h2>Form Integration</h2></a>
<a class="header" href="print.html#html-forms" id="html-forms"><h3>HTML Forms</h3></a>
<p>Include CSRF tokens in HTML forms using the context helper:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn show_user_form(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Ensure CSRF token exists
    ctx.generate_csrf()?;
    
    ctx.view(&quot;users/form&quot;, json!({
        &quot;user&quot;: load_user_data().await?,
        &quot;action&quot;: &quot;/users/create&quot;
    }))
}
#}</code></pre></pre>
<p>Template (Total.js syntax):</p>
<pre><code class="language-html">&lt;!-- Default token --&gt;
&lt;form action=&quot;@{action}&quot; method=&quot;POST&quot;&gt;
    @{csrf}  &lt;!-- Auto-generated hidden input --&gt;
    
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label&gt;Name:&lt;/label&gt;
        &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;@{user.name}&quot; required&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input type=&quot;email&quot; name=&quot;email&quot; value=&quot;@{user.email}&quot; required&gt;
    &lt;/div&gt;
    
    &lt;button type=&quot;submit&quot;&gt;Save User&lt;/button&gt;
&lt;/form&gt;

&lt;!-- Multiple forms with different tokens --&gt;
&lt;form id=&quot;userForm&quot; method=&quot;POST&quot; action=&quot;/users&quot;&gt;
    @{csrf}  &lt;!-- Default token --&gt;
    &lt;!-- form fields --&gt;
&lt;/form&gt;

&lt;form id=&quot;uploadForm&quot; method=&quot;POST&quot; action=&quot;/upload&quot;&gt;
    @{csrf(&quot;upload_csrf&quot;)}  &lt;!-- Custom upload token --&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;
&lt;/form&gt;
</code></pre>
<a class="header" href="print.html#manual-token-inclusion" id="manual-token-inclusion"><h3>Manual Token Inclusion</h3></a>
<p>If you need to include tokens manually in data:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn manual_form(ctx: Context) -&gt; Result&lt;Response&gt; {
    let csrf_token = ctx.generate_csrf()?;
    
    ctx.view(&quot;forms/manual&quot;, json!({
        &quot;csrf_token&quot;: csrf_token,
        &quot;form_data&quot;: load_form_data().await?
    }))
}
#}</code></pre></pre>
<p>Template:</p>
<pre><code class="language-html">&lt;!-- Default token manual inclusion --&gt;
&lt;form action=&quot;/users&quot; method=&quot;POST&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_csrf_token&quot; value=&quot;@{csrf_token}&quot;&gt;
    &lt;!-- form fields... --&gt;
&lt;/form&gt;

&lt;!-- Custom token manual inclusion --&gt;
&lt;form action=&quot;/api/action&quot; method=&quot;POST&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;api_csrf&quot; value=&quot;@{csrf_token.api_csrf}&quot;&gt;
    &lt;!-- form fields... --&gt;
&lt;/form&gt;

&lt;!-- Mixed approach --&gt;
&lt;div&gt;
    &lt;form method=&quot;POST&quot; action=&quot;/form1&quot;&gt;
        @{csrf}  &lt;!-- Auto-generated --&gt;
    &lt;/form&gt;
    
    &lt;form method=&quot;POST&quot; action=&quot;/form2&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;form2_csrf&quot; value=&quot;@{csrf_token.form2_csrf}&quot;&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<a class="header" href="print.html#form-processing" id="form-processing"><h3>Form Processing</h3></a>
<p>Form processing requires no changes - CSRF is handled by middleware:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn process_user_form(ctx: Context) -&gt; Result&lt;Response&gt; {
    // CSRF already validated by middleware
    let form_data = ctx.body_form()?;
    
    // Validate form data
    let user_data = validate_user_form(&amp;form_data)?;
    
    // Save user
    let user = create_user(&amp;user_data).await?;
    
    // Success response
    ctx.flash_success(&quot;User created successfully!&quot;);
    ctx.redirect(&quot;/users&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#advanced-usage-2" id="advanced-usage-2"><h2>Advanced Usage</h2></a>
<a class="header" href="print.html#conditional-csrf-protection" id="conditional-csrf-protection"><h3>Conditional CSRF Protection</h3></a>
<p>Apply CSRF protection conditionally:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::security::CsrfConfig;

// Environment-based configuration
let csrf_config = match env::var(&quot;ENVIRONMENT&quot;).as_deref() {
    Ok(&quot;development&quot;) =&gt; {
        // Relaxed CSRF in development
        CsrfConfig::new()
            .exempt(&quot;/debug/*&quot;)
            .exempt(&quot;/test/*&quot;)
    }
    Ok(&quot;production&quot;) =&gt; {
        // Strict CSRF in production  
        CsrfConfig::new()
            .error_message(&quot;Security validation failed&quot;)
            .redirect_on_failure(&quot;/login&quot;)
    }
    _ =&gt; CsrfConfig::new()  // Default
};
#}</code></pre></pre>
<a class="header" href="print.html#custom-http-methods" id="custom-http-methods"><h3>Custom HTTP Methods</h3></a>
<p>Protect custom HTTP methods:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let csrf_config = CsrfConfig::new()
    .protect_method(&quot;CUSTOM&quot;)       // Add protection
    .protect_method(&quot;MERGE&quot;)        // Custom REST method
    .exempt_method(&quot;DELETE&quot;);       // Remove DELETE protection

app.middleware(&quot;csrf&quot;, CsrfMiddleware::with_config(csrf_config));

// Custom method handling
app.route(&quot;CUSTOM&quot;, &quot;/resources/:id&quot;, custom_method_handler);
#}</code></pre></pre>
<a class="header" href="print.html#multiple-csrf-configurations" id="multiple-csrf-configurations"><h3>Multiple CSRF Configurations</h3></a>
<p>Apply different CSRF configurations to different route groups:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Public API - no CSRF
let public_routes = RouteGroup::new(&quot;/api/public&quot;)
    .route(&quot;POST&quot;, &quot;/contact&quot;, contact_handler)
    .route(&quot;POST&quot;, &quot;/newsletter&quot;, newsletter_handler);

// Private API - CSRF required
let private_api_config = CsrfConfig::new()
    .error_message(&quot;API authentication failed&quot;);

let private_routes = RouteGroup::new(&quot;/api/private&quot;)
    .middleware(&quot;csrf&quot;, CsrfMiddleware::with_config(private_api_config))
    .route(&quot;POST&quot;, &quot;/users&quot;, create_user)
    .route(&quot;PUT&quot;, &quot;/users/:id&quot;, update_user);

app.route_group(public_routes);
app.route_group(private_routes);
#}</code></pre></pre>
<a class="header" href="print.html#bypass-middleware-for-specific-controllers" id="bypass-middleware-for-specific-controllers"><h3>Bypass Middleware for Specific Controllers</h3></a>
<p>Exempt specific controllers from global CSRF protection:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Global CSRF protection
app.middleware(&quot;csrf&quot;, CsrfMiddleware::new());

// Routes with CSRF
app.post(&quot;/users&quot;, create_user_handler);
app.put(&quot;/users/:id&quot;, update_user_handler);

// Exempt webhook routes
app.post(&quot;/webhook/stripe&quot;, stripe_webhook_handler);  // Exempt via /api/* default
app.post(&quot;/integration/github&quot;, github_webhook_handler);  // Need explicit exemption

// Add specific exemptions
let csrf_config = CsrfConfig::new()
    .exempt(&quot;/integration/*&quot;)
    .exempt(&quot;/external/callback&quot;);
    
app.middleware(&quot;csrf&quot;, CsrfMiddleware::with_config(csrf_config));
#}</code></pre></pre>
<a class="header" href="print.html#troubleshooting-3" id="troubleshooting-3"><h2>Troubleshooting</h2></a>
<a class="header" href="print.html#common-issues-1" id="common-issues-1"><h3>Common Issues</h3></a>
<a class="header" href="print.html#1-403-csrf-token-errors" id="1-403-csrf-token-errors"><h4>1. 403 CSRF Token Errors</h4></a>
<p><strong>Problem:</strong> Getting 403 errors on valid requests</p>
<p><strong>Solutions:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Check if route is properly exempted
let csrf_config = CsrfConfig::new()
    .exempt(&quot;/your/route/*&quot;);  // Add exemption

// Verify token submission method
// For default token:
// - Header: X-CSRF-Token
// - Form field: _token or _csrf_token  
// - Query param: _token

// For custom token (e.g., &quot;upload_csrf&quot;):
// - Header: X-CSRF-Token
// - Form field: upload_csrf
// - Query param: upload_csrf

// Check token expiration (tokens expire after 1 hour)
// Generate a fresh token if needed

// Remember: Tokens are one-time use
// After successful verification, generate a new token for the next request
#}</code></pre></pre>
<a class="header" href="print.html#2-ajax-requests-failing" id="2-ajax-requests-failing"><h4>2. AJAX Requests Failing</h4></a>
<p><strong>Problem:</strong> AJAX requests returning 403 CSRF errors</p>
<p><strong>Solutions:</strong></p>
<pre><code class="language-javascript">// Method 1: Include CSRF header
fetch('/api/endpoint', {
    method: 'POST',
    headers: {
        'X-CSRF-Token': await getCsrfToken()  // Most reliable
    },
    body: formData
});

// Method 2: Check API route exemptions
// Ensure /api/* routes are exempted or add specific exemptions
</code></pre>
<a class="header" href="print.html#3-webhooks-failing" id="3-webhooks-failing"><h4>3. Webhooks Failing</h4></a>
<p><strong>Problem:</strong> External webhooks returning 403 errors</p>
<p><strong>Solutions:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Add webhook exemptions
let csrf_config = CsrfConfig::new()
    .exempt(&quot;/webhook/*&quot;)           // All webhook routes
    .exempt(&quot;/integration/*&quot;)       // Integration callbacks
    .exempt(&quot;/callback/*&quot;);         // External callbacks
#}</code></pre></pre>
<a class="header" href="print.html#4-token-generation-issues" id="4-token-generation-issues"><h4>4. Token Generation Issues</h4></a>
<p><strong>Problem:</strong> CSRF tokens not being generated or stored</p>
<p><strong>Solutions:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Check session configuration
// CSRF relies on sessions - ensure sessions are enabled

// Manual token generation
let token = ctx.generate_csrf(None)?;  // Default token
let custom = ctx.generate_csrf(Some(&quot;custom_id&quot;))?;  // Custom token

// Verify session storage
// Check that session storage backend is working
// Tokens are stored as: {&quot;token&quot;: &quot;...&quot;, &quot;valid_to&quot;: timestamp}
#}</code></pre></pre>
<a class="header" href="print.html#5-token-reuse-issues" id="5-token-reuse-issues"><h4>5. Token Reuse Issues</h4></a>
<p><strong>Problem:</strong> Token validation fails on second attempt</p>
<p><strong>Solution:</strong> Tokens are <strong>one-time use</strong> - they are consumed after successful verification</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Generate new token for each form submission
async fn show_form_after_submit(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Generate fresh token for the next submission
    ctx.generate_csrf(None)?;
    ctx.view(&quot;form&quot;, data)
}

// For AJAX: Fetch new token after each successful request
#}</code></pre></pre>
<a class="header" href="print.html#debugging-1" id="debugging-1"><h3>Debugging</h3></a>
<p>Enable debug logging to troubleshoot CSRF issues:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Add logging middleware to see request flow
app.middleware(&quot;logging&quot;, LoggingMiddleware::new());

// Check CSRF middleware execution
// Look for log entries showing CSRF validation
#}</code></pre></pre>
<p>Check CSRF token presence and expiration:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn debug_csrf(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Check default token
    let token_data: Option&lt;serde_json::Value&gt; = ctx.session.get(&quot;_csrf_token&quot;);
    let token_info = if let Some(data) = token_data {
        json!({
            &quot;token&quot;: data.get(&quot;token&quot;),
            &quot;expires_at&quot;: data.get(&quot;valid_to&quot;),
            &quot;expired&quot;: {
                let now = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH).unwrap()
                    .as_secs();
                data.get(&quot;valid_to&quot;)
                    .and_then(|v| v.as_u64())
                    .map(|exp| now &gt; exp)
                    .unwrap_or(true)
            }
        })
    } else {
        json!(null)
    };
    
    ctx.json(json!({
        &quot;token_info&quot;: token_info,
        &quot;headers&quot;: ctx.request.headers,
        &quot;form_data&quot;: ctx.body_form().unwrap_or_default()
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#best-practices-13" id="best-practices-13"><h2>Best Practices</h2></a>
<a class="header" href="print.html#1-default-configuration" id="1-default-configuration"><h3>1. Default Configuration</h3></a>
<p>Start with default CSRF configuration and customize as needed:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Good: Start simple
app.middleware(&quot;csrf&quot;, CsrfMiddleware::new());

// Then customize for specific needs
let csrf_config = CsrfConfig::new()
    .exempt(&quot;/specific/webhook&quot;)
    .error_message(&quot;Custom error message&quot;);
#}</code></pre></pre>
<a class="header" href="print.html#2-route-organization" id="2-route-organization"><h3>2. Route Organization</h3></a>
<p>Organize routes to minimize exemptions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Good: Group exempt routes under common prefixes
app.post(&quot;/api/webhook/stripe&quot;, stripe_handler);        // Auto-exempt
app.post(&quot;/api/webhook/github&quot;, github_handler);        // Auto-exempt
app.post(&quot;/api/integration/slack&quot;, slack_handler);      // Auto-exempt

// Better than scattered exemptions
let csrf_config = CsrfConfig::new()
    .exempt(&quot;/webhook/stripe&quot;)      // Scattered
    .exempt(&quot;/integration/github&quot;)  // Scattered  
    .exempt(&quot;/callback/slack&quot;);     // Scattered
#}</code></pre></pre>
<a class="header" href="print.html#3-token-management" id="3-token-management"><h3>3. Token Management</h3></a>
<p>Use context methods for token management:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Good: Generate tokens before rendering
async fn show_form(ctx: Context) -&gt; Result&lt;Response&gt; {
    ctx.generate_csrf(None)?;  // Default token
    ctx.generate_csrf(Some(&quot;api_csrf&quot;))?;  // API token
    ctx.view(&quot;form&quot;, data)  // Tokens accessible in templates
}

// Good: Regenerate after consumption
async fn handle_form(ctx: Context) -&gt; Result&lt;Response&gt; {
    if !ctx.verify_csrf(None)? {
        return ctx.throw403(Some(&quot;Invalid token&quot;));
    }
    // Token consumed, generate new one for next request
    ctx.generate_csrf(None)?;
    ctx.redirect(&quot;/form&quot;)
}

// Avoid: Reusing tokens
// Tokens are one-time use - always generate fresh tokens
#}</code></pre></pre>
<a class="header" href="print.html#4-error-handling-1" id="4-error-handling-1"><h3>4. Error Handling</h3></a>
<p>Provide user-friendly error messages:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let csrf_config = CsrfConfig::new()
    .error_message(&quot;Your session has expired. Please refresh the page and try again.&quot;)
    .redirect_on_failure(&quot;/login&quot;)  // Better UX than error page
    .flash_error_key(&quot;security_message&quot;);
#}</code></pre></pre>
<a class="header" href="print.html#5-testing" id="5-testing"><h3>5. Testing</h3></a>
<p>Test CSRF protection in your application:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_csrf_protection() {
        let app = test_app_with_csrf();
        
        // Test protected route without token (should fail)
        let response = app.post(&quot;/users&quot;).send().await;
        assert_eq!(response.status(), 403);
        
        // Test with valid token (should succeed)
        let csrf_token = get_csrf_token(&amp;app).await;
        let response = app.post(&quot;/users&quot;)
            .header(&quot;X-CSRF-Token&quot;, csrf_token)
            .json(json!({&quot;name&quot;: &quot;Test User&quot;}))
            .send().await;
        assert_eq!(response.status(), 200);
    }
    
    #[tokio::test]
    async fn test_exempt_routes() {
        let app = test_app_with_csrf();
        
        // Test exempt route (should succeed without token)
        let response = app.post(&quot;/api/webhook/test&quot;).send().await;
        assert_eq!(response.status(), 200);
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#6-performance-considerations" id="6-performance-considerations"><h3>6. Performance Considerations</h3></a>
<ul>
<li>CSRF middleware has minimal performance impact</li>
<li>Session reads/writes only occur on protected requests</li>
<li>Pattern matching is optimized for common cases</li>
<li>Consider using <code>should_run()</code> for conditional execution</li>
</ul>
<a class="header" href="print.html#7-security-considerations" id="7-security-considerations"><h3>7. Security Considerations</h3></a>
<ul>
<li>Always use HTTPS in production to protect tokens in transit</li>
<li>Tokens are automatically one-time use (prevents replay attacks)</li>
<li>Tokens expire after 1 hour (limits attack window)</li>
<li>Support for multiple concurrent tokens (different security contexts)</li>
<li>Monitor for unusual CSRF failure patterns (potential attacks)</li>
<li>Regularly review and update route exemptions</li>
</ul>
<hr />
<a class="header" href="print.html#summary-3" id="summary-3"><h2>Summary</h2></a>
<p>RustF's CSRF protection provides:</p>
<p>âœ… <strong>One-Time Use Tokens</strong> - Consumed after verification (prevents replay attacks)<br />
âœ… <strong>Token Expiration</strong> - Automatic 1-hour expiration<br />
âœ… <strong>Multiple Concurrent Tokens</strong> - Different tokens for different forms<br />
âœ… <strong>Zero Configuration</strong> - Works out-of-the-box with sensible defaults<br />
âœ… <strong>Automatic Protection</strong> - HTTP method-based validation<br />
âœ… <strong>Flexible Configuration</strong> - Extensive customization options<br />
âœ… <strong>Session Integration</strong> - Seamless token storage and validation<br />
âœ… <strong>Multiple Token Sources</strong> - Headers, forms, and query parameters<br />
âœ… <strong>Smart Error Handling</strong> - Context-aware error responses<br />
âœ… <strong>Developer Friendly</strong> - Convenient context methods and helpers</p>
<a class="header" href="print.html#related-topics-1" id="related-topics-1"><h2>Related Topics</h2></a>
<ul>
<li><a href="middleware.md">Middleware</a> - Request/response processing and security middleware</li>
<li><a href="configuration.md">Configuration</a> - Security configuration options</li>
<li><a href="sessions.md">Sessions</a> - Secure session management</li>
<li><a href="error-handling.md">Error Handling</a> - Secure error responses</li>
</ul>
<hr />
<a class="header" href="print.html#additional-security-features" id="additional-security-features"><h2>Additional Security Features</h2></a>
<p>See the <a href="../guides/configuration.md#security">Security Configuration</a> section for more security options.</p>
<a class="header" href="print.html#rustf-error-system-documentation" id="rustf-error-system-documentation"><h1>RustF Error System Documentation</h1></a>
<a class="header" href="print.html#overview-8" id="overview-8"><h2>Overview</h2></a>
<p>RustF provides a comprehensive, production-ready error handling system designed for building robust web applications. The error system emphasizes safety, observability, and developer experience while providing enterprise-grade features like retry logic, error chaining, and circuit breakers.</p>
<a class="header" href="print.html#core-principles" id="core-principles"><h3>Core Principles</h3></a>
<ul>
<li><strong>Type Safety</strong>: Strongly typed errors with exhaustive pattern matching</li>
<li><strong>Production Safety</strong>: Sanitized error messages, no sensitive data leakage</li>
<li><strong>Observability</strong>: Rich context and structured logging for debugging</li>
<li><strong>Resilience</strong>: Built-in retry logic and circuit breaker patterns</li>
<li><strong>Developer Experience</strong>: Clear error messages and intuitive APIs</li>
</ul>
<a class="header" href="print.html#error-types" id="error-types"><h2>Error Types</h2></a>
<a class="header" href="print.html#main-error-enum" id="main-error-enum"><h3>Main Error Enum</h3></a>
<p>The <code>rustf::error::Error</code> enum provides comprehensive error variants for all common scenarios:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::error::Error;
#}</code></pre></pre>
<a class="header" href="print.html#core-error-variants" id="core-error-variants"><h3>Core Error Variants</h3></a>
<a class="header" href="print.html#http-and-network-errors" id="http-and-network-errors"><h4>HTTP and Network Errors</h4></a>
<ul>
<li><code>Http(hyper::Error)</code> - HTTP protocol errors</li>
<li><code>Network(String)</code> - Network connectivity issues</li>
<li><code>Timeout(String)</code> - Request timeout errors</li>
<li><code>ExternalService { service, message }</code> - External API failures</li>
</ul>
<a class="header" href="print.html#data-processing-errors" id="data-processing-errors"><h4>Data Processing Errors</h4></a>
<ul>
<li><code>Json(serde_json::Error)</code> - JSON serialization/deserialization</li>
<li><code>Validation(String)</code> - Data validation failures</li>
<li><code>InvalidInput(String)</code> - User input errors</li>
<li><code>Template(String)</code> - Template rendering errors</li>
</ul>
<a class="header" href="print.html#database-errors" id="database-errors"><h4>Database Errors</h4></a>
<ul>
<li><code>DatabaseConnection(String)</code> - Connection pool issues</li>
<li><code>DatabaseQuery(String)</code> - SQL query errors</li>
<li><code>DatabaseTransaction(String)</code> - Transaction failures</li>
<li><code>DatabaseMigration(String)</code> - Migration errors</li>
<li><code>DatabasePool(String)</code> - Connection pool exhaustion</li>
</ul>
<a class="header" href="print.html#authentication--authorization" id="authentication--authorization"><h4>Authentication &amp; Authorization</h4></a>
<ul>
<li><code>Authentication(String)</code> - Authentication failures (401)</li>
<li><code>Authorization(String)</code> - Permission denied (403)</li>
<li><code>RateLimit(String)</code> - Rate limiting (429)</li>
<li><code>Session(String)</code> - Session management errors</li>
</ul>
<a class="header" href="print.html#application-errors" id="application-errors"><h4>Application Errors</h4></a>
<ul>
<li><code>RouteNotFound(String)</code> - Route not found (404)</li>
<li><code>ModelNotFound(String)</code> - Model/resource not found (404)</li>
<li><code>Internal(String)</code> - Internal server errors (500)</li>
<li><code>Io(std::io::Error)</code> - File system I/O errors</li>
</ul>
<a class="header" href="print.html#special-errors" id="special-errors"><h4>Special Errors</h4></a>
<ul>
<li><code>WithContext { message, source }</code> - Error with context chain</li>
<li><code>Redis(redis::RedisError)</code> - Redis errors (feature-gated)</li>
<li><code>RedisPool(String)</code> - Redis connection pool errors</li>
</ul>
<a class="header" href="print.html#error-creation-and-handling" id="error-creation-and-handling"><h2>Error Creation and Handling</h2></a>
<a class="header" href="print.html#creating-errors" id="creating-errors"><h3>Creating Errors</h3></a>
<p>RustF provides convenient constructors for all error types:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Database errors
Error::database_connection(&quot;Failed to connect to PostgreSQL&quot;)
Error::database_query(&quot;Invalid SQL syntax near 'FORM'&quot;)
Error::database_transaction(&quot;Transaction rolled back&quot;)

// Authentication errors
Error::authentication(&quot;Invalid credentials&quot;)
Error::authorization(&quot;Insufficient permissions for this resource&quot;)
Error::rate_limit(&quot;API rate limit exceeded: 100 requests per minute&quot;)

// External service errors
Error::external_service(&quot;payment_gateway&quot;, &quot;Service temporarily unavailable&quot;)
Error::timeout(&quot;Request timed out after 30 seconds&quot;)

// Validation errors
Error::validation(&quot;Email address is invalid&quot;)
Error::invalid_input(&quot;Age must be a positive number&quot;)
#}</code></pre></pre>
<a class="header" href="print.html#error-propagation" id="error-propagation"><h3>Error Propagation</h3></a>
<p>Use the <code>?</code> operator for clean error propagation:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn process_user_registration(data: UserData) -&gt; Result&lt;User&gt; {
    // Validate input
    validate_email(&amp;data.email)?;
    validate_password(&amp;data.password)?;
    
    // Check for existing user
    if User::exists_by_email(&amp;data.email).await? {
        return Err(Error::validation(&quot;Email already registered&quot;));
    }
    
    // Create user in database
    let user = User::create(data).await?;
    
    // Send welcome email
    email_service::send_welcome(&amp;user).await
        .map_err(|e| Error::external_service(&quot;email&quot;, e.to_string()))?;
    
    Ok(user)
}
#}</code></pre></pre>
<a class="header" href="print.html#error-properties" id="error-properties"><h3>Error Properties</h3></a>
<p>Each error has useful properties:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let error = Error::authentication(&quot;Invalid token&quot;);

// Get machine-readable error code
assert_eq!(error.error_code(), &quot;E_AUTH&quot;);

// Get appropriate HTTP status code
assert_eq!(error.status_code(), 401);

// Check if error is retryable
assert!(!error.is_retryable());
#}</code></pre></pre>
<a class="header" href="print.html#error-context-and-chaining" id="error-context-and-chaining"><h2>Error Context and Chaining</h2></a>
<a class="header" href="print.html#adding-context-to-errors" id="adding-context-to-errors"><h3>Adding Context to Errors</h3></a>
<p>Use the <code>ErrorContext</code> trait to add contextual information:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::error::ErrorContext;

async fn fetch_user_profile(id: u64) -&gt; Result&lt;Profile&gt; {
    let user = fetch_user_from_db(id).await
        .context(&quot;Failed to fetch user from database&quot;)?;
    
    let profile = build_profile(user).await
        .context(format!(&quot;Failed to build profile for user {}&quot;, id))?;
    
    Ok(profile)
}

// With lazy evaluation
result.with_context(|| format!(&quot;Operation failed at {}&quot;, timestamp))
#}</code></pre></pre>
<a class="header" href="print.html#error-chains" id="error-chains"><h3>Error Chains</h3></a>
<p>Build and inspect error chains for better debugging:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::error::ErrorChain;

// When an error occurs with context
let error = database_operation()
    .context(&quot;Failed to update user&quot;)
    .context(&quot;Cannot complete profile update&quot;)
    .unwrap_err();

// Inspect the error chain
let chain = ErrorChain::new(&amp;error);

// Get all messages in the chain
for message in chain.chain() {
    println!(&quot;- {}&quot;, message);
}

// Get the root cause
let root = chain.root_cause();
println!(&quot;Root cause: {}&quot;, root);

// Format for logging
log::error!(&quot;{}&quot;, chain.format_for_log());
#}</code></pre></pre>
<a class="header" href="print.html#option-to-error-conversion" id="option-to-error-conversion"><h3>Option to Error Conversion</h3></a>
<p>Convert <code>Option</code> to <code>Error</code> with context:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::error::OptionExt;

let value = some_option
    .context(&quot;Expected value to be present&quot;)?;

// With lazy evaluation
let config = config_value
    .with_context(|| format!(&quot;Missing config key: {}&quot;, key))?;
#}</code></pre></pre>
<a class="header" href="print.html#retry-logic" id="retry-logic"><h2>Retry Logic</h2></a>
<a class="header" href="print.html#retry-policies" id="retry-policies"><h3>Retry Policies</h3></a>
<p>RustF provides configurable retry policies for handling transient failures:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::error::{RetryPolicy, with_retry};

// Exponential backoff (recommended for network operations)
let policy = RetryPolicy::exponential(3);  // 3 attempts with exponential backoff

// Fixed delay
let policy = RetryPolicy::fixed(5, Duration::from_secs(1));  // 5 attempts, 1 second apart

// Linear backoff
let policy = RetryPolicy::linear(4, Duration::from_millis(500));  // Linear increase

// Custom configuration
let policy = RetryPolicy {
    max_attempts: 3,
    initial_delay: Duration::from_millis(100),
    max_delay: Duration::from_secs(30),
    backoff_multiplier: 2.0,
    jitter: true,  // Add randomization to prevent thundering herd
};
#}</code></pre></pre>
<a class="header" href="print.html#using-retry-logic" id="using-retry-logic"><h3>Using Retry Logic</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Simple retry with policy
let result = with_retry(policy, || async {
    fetch_from_external_api().await
}).await?;

// Using RetryBuilder for fluent configuration
use rustf::error::RetryBuilder;

let data = RetryBuilder::new()
    .max_attempts(3)
    .initial_delay(Duration::from_millis(100))
    .backoff_multiplier(2.0)
    .jitter(true)
    .execute(|| async {
        unstable_network_call().await
    })
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#retryable-errors" id="retryable-errors"><h3>Retryable Errors</h3></a>
<p>Only certain errors are automatically retried:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// These errors are retryable by default:
Error::Network(_)            // Network issues
Error::DatabaseConnection(_) // Connection failures
Error::Timeout(_)           // Timeouts
Error::ExternalService(..)  // External service failures
Error::DatabasePool(_)      // Pool exhaustion

// These are NOT retryable:
Error::Validation(_)        // Input validation
Error::Authentication(_)    // Auth failures
Error::Authorization(_)     // Permission denied
#}</code></pre></pre>
<a class="header" href="print.html#circuit-breaker-pattern" id="circuit-breaker-pattern"><h3>Circuit Breaker Pattern</h3></a>
<p>Prevent cascading failures with circuit breakers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::error::retry::CircuitBreaker;

// Create a circuit breaker
let breaker = CircuitBreaker::new(
    5,                          // Open after 5 failures
    2,                          // Close after 2 successes
    Duration::from_secs(30),    // Timeout before half-open
    3,                          // Max calls in half-open state
);

// Use the circuit breaker
let result = breaker.execute(|| async {
    call_unreliable_service().await
}).await;

// Circuit states:
// - Closed: Normal operation
// - Open: Rejecting calls (after threshold failures)
// - Half-Open: Testing with limited calls
#}</code></pre></pre>
<a class="header" href="print.html#error-pages-and-responses" id="error-pages-and-responses"><h2>Error Pages and Responses</h2></a>
<a class="header" href="print.html#html-error-pages" id="html-error-pages"><h3>HTML Error Pages</h3></a>
<p>RustF provides beautiful, customizable error pages:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::error::ErrorPages;

let error_pages = ErrorPages::new(view_engine, config);

// Render error page
let response = error_pages.render_error_page(
    404,                    // Status code
    Some(&amp;error),          // Error object
    Some(&quot;req-123&quot;),       // Request ID
)?;

// Custom error templates in views/errors/
// - views/errors/404.html
// - views/errors/500.html
// - views/errors/generic.html
#}</code></pre></pre>
<a class="header" href="print.html#json-error-responses" id="json-error-responses"><h3>JSON Error Responses</h3></a>
<p>For API endpoints, return structured JSON errors:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Automatic based on Accept header
let response = error_pages.create_error_response(
    status_code,
    Some(&amp;error),
    Some(request_id),
    request.header(&quot;Accept&quot;),
)?;

// Force JSON response
let json_response = error_pages.create_json_error_response(
    400,
    Some(&amp;error),
    Some(&quot;api-request-123&quot;),
)?;

// Response format:
{
    &quot;error&quot;: true,
    &quot;status&quot;: 400,
    &quot;code&quot;: &quot;E_VALIDATION&quot;,
    &quot;message&quot;: &quot;User-friendly error message&quot;,
    &quot;request_id&quot;: &quot;api-request-123&quot;,
    &quot;timestamp&quot;: &quot;2024-01-20T10:30:00Z&quot;,
    &quot;details&quot;: {  // Only in development mode
        &quot;error_message&quot;: &quot;Detailed error&quot;,
        &quot;error_type&quot;: &quot;Validation Error&quot;
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#development-vs-production" id="development-vs-production"><h3>Development vs Production</h3></a>
<p>Error responses adapt based on environment:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Development mode (debug builds or RUSTF_ENV=development)
- Full error messages with context
- Stack traces included
- Detailed error information
- Source file locations

// Production mode
- Sanitized, user-friendly messages
- No stack traces or sensitive data
- Generic error messages for internal errors
- Request IDs for support correlation
#}</code></pre></pre>
<a class="header" href="print.html#error-logging" id="error-logging"><h2>Error Logging</h2></a>
<a class="header" href="print.html#structured-logging" id="structured-logging"><h3>Structured Logging</h3></a>
<p>RustF provides comprehensive error logging:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::error::{ErrorLogger, LogLevel, LogConfig};

// Configure logging
let config = LogConfig {
    level: LogLevel::Info,
    output: LogOutput::Both(&quot;/var/log/rustf.log&quot;),
    include_stack_trace: false,  // Only in development
    include_request_context: true,
    max_file_size: Some(10 * 1024 * 1024),  // 10MB
    max_files: Some(5),  // Keep 5 rotated files
};

// Initialize logger
let logger = ErrorLogger::new(config, app_config);

// Log errors with context
logger.log_error(
    LogLevel::Error,
    &amp;error,
    Some(&amp;request),
    Some(&quot;req-123&quot;),
    Some(additional_data),
);
#}</code></pre></pre>
<a class="header" href="print.html#log-levels" id="log-levels"><h3>Log Levels</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
LogLevel::Debug     // Detailed debugging information
LogLevel::Info      // Informational messages
LogLevel::Warn      // Warning conditions
LogLevel::Error     // Error conditions
LogLevel::Critical  // Critical failures requiring immediate attention
#}</code></pre></pre>
<a class="header" href="print.html#request-context-in-logs" id="request-context-in-logs"><h3>Request Context in Logs</h3></a>
<p>Automatically captured request information:</p>
<pre><code class="language-json">{
    &quot;timestamp&quot;: &quot;2024-01-20T10:30:00Z&quot;,
    &quot;level&quot;: &quot;ERROR&quot;,
    &quot;message&quot;: &quot;Database connection failed&quot;,
    &quot;error_type&quot;: &quot;DatabaseConnection&quot;,
    &quot;request_id&quot;: &quot;req-123&quot;,
    &quot;request_context&quot;: {
        &quot;method&quot;: &quot;POST&quot;,
        &quot;uri&quot;: &quot;/api/users&quot;,
        &quot;client_ip&quot;: &quot;192.168.1.100&quot;,
        &quot;user_agent&quot;: &quot;Mozilla/5.0...&quot;
    },
    &quot;stack_trace&quot;: &quot;...&quot;  // Only in development
}
</code></pre>
<a class="header" href="print.html#sensitive-data-protection" id="sensitive-data-protection"><h3>Sensitive Data Protection</h3></a>
<p>Automatic sanitization of sensitive information:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// These are automatically redacted in logs:
- Passwords in URLs and headers
- API keys and tokens
- Authorization headers
- Cookie headers
- Credit card numbers
- Social security numbers
#}</code></pre></pre>
<a class="header" href="print.html#health-checks" id="health-checks"><h2>Health Checks</h2></a>
<p>Built-in health check endpoint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::error::HealthCheck;

let health_check = HealthCheck::new(config);
let result = health_check.check_health().await;

// Health check response:
{
    &quot;status&quot;: &quot;healthy&quot;,
    &quot;timestamp&quot;: &quot;2024-01-20T10:30:00Z&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;checks&quot;: {
        &quot;database&quot;: {
            &quot;status&quot;: &quot;healthy&quot;,
            &quot;message&quot;: &quot;Connection successful&quot;
        },
        &quot;memory&quot;: {
            &quot;status&quot;: &quot;healthy&quot;,
            &quot;message&quot;: &quot;Memory usage within limits&quot;
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#best-practices-14" id="best-practices-14"><h2>Best Practices</h2></a>
<a class="header" href="print.html#1-never-use-unwrap-in-production" id="1-never-use-unwrap-in-production"><h3>1. Never Use <code>unwrap()</code> in Production</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ Bad - Can panic
let value = some_option.unwrap();

// âœ… Good - Proper error handling
let value = some_option
    .ok_or_else(|| Error::invalid_input(&quot;Value is required&quot;))?;
#}</code></pre></pre>
<a class="header" href="print.html#2-add-context-to-errors" id="2-add-context-to-errors"><h3>2. Add Context to Errors</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ Bad - No context
database_query().await?;

// âœ… Good - With context
database_query().await
    .context(&quot;Failed to fetch user permissions&quot;)?;
#}</code></pre></pre>
<a class="header" href="print.html#3-use-specific-error-types" id="3-use-specific-error-types"><h3>3. Use Specific Error Types</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ Bad - Generic error
Error::internal(&quot;Something went wrong&quot;)

// âœ… Good - Specific error
Error::database_query(&quot;Failed to execute SELECT query: connection timeout&quot;)
#}</code></pre></pre>
<a class="header" href="print.html#4-handle-errors-at-the-right-level" id="4-handle-errors-at-the-right-level"><h3>4. Handle Errors at the Right Level</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ Bad - Swallowing errors
let _ = send_email().await;

// âœ… Good - Proper handling
if let Err(e) = send_email().await {
    log::warn!(&quot;Failed to send email: {}&quot;, e);
    // Continue - email is not critical
}
#}</code></pre></pre>
<a class="header" href="print.html#5-test-error-conditions" id="5-test-error-conditions"><h3>5. Test Error Conditions</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn test_validation_error() {
    let result = validate_email(&quot;invalid&quot;);
    assert!(result.is_err());
    
    let error = result.unwrap_err();
    assert_eq!(error.status_code(), 400);
    assert_eq!(error.error_code(), &quot;E_VALIDATION&quot;);
}
#}</code></pre></pre>
<a class="header" href="print.html#examples-2" id="examples-2"><h2>Examples</h2></a>
<a class="header" href="print.html#complete-request-handler-with-error-handling" id="complete-request-handler-with-error-handling"><h3>Complete Request Handler with Error Handling</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn create_order(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Parse and validate input
    let order_data: OrderData = ctx.json()
        .await
        .context(&quot;Failed to parse order data&quot;)?;
    
    order_data.validate()
        .map_err(|e| Error::validation(e))?;
    
    // Check authentication
    let user = ctx.get_user()
        .ok_or_else(|| Error::authentication(&quot;Login required&quot;))?;
    
    // Check authorization
    if !user.can_create_orders() {
        return Err(Error::authorization(&quot;Insufficient permissions&quot;));
    }
    
    // Retry external payment service
    let payment_result = RetryBuilder::new()
        .max_attempts(3)
        .exponential_backoff()
        .execute(|| async {
            payment_service::process(&amp;order_data).await
                .map_err(|e| Error::external_service(&quot;payment&quot;, e.to_string()))
        })
        .await
        .context(&quot;Payment processing failed&quot;)?;
    
    // Create order in database
    let order = Order::create(order_data, payment_result)
        .await
        .context(&quot;Failed to create order&quot;)?;
    
    // Return success response
    ctx.json(json!({
        &quot;success&quot;: true,
        &quot;order_id&quot;: order.id,
        &quot;status&quot;: order.status,
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#middleware-error-handling" id="middleware-error-handling"><h3>Middleware Error Handling</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub async fn error_handling_middleware(
    ctx: &amp;mut Context,
    next: Next&lt;'_&gt;,
) -&gt; Result&lt;()&gt; {
    let request_id = uuid::Uuid::new_v4().to_string();
    ctx.set_header(&quot;X-Request-ID&quot;, &amp;request_id);
    
    match next.run(ctx).await {
        Ok(()) =&gt; Ok(()),
        Err(error) =&gt; {
            // Log the error
            log_error(&amp;error, Some(&amp;ctx.request), Some(&amp;request_id));
            
            // Create error response based on Accept header
            let accept = ctx.header(&quot;Accept&quot;);
            if accept.map_or(false, |h| h.contains(&quot;application/json&quot;)) {
                ctx.json(json!({
                    &quot;error&quot;: true,
                    &quot;code&quot;: error.error_code(),
                    &quot;message&quot;: error.to_string(),
                    &quot;request_id&quot;: request_id,
                }))
            } else {
                let error_pages = ctx.error_pages();
                let response = error_pages.render_error_page(
                    error.status_code(),
                    Some(&amp;error),
                    Some(&amp;request_id),
                )?;
                ctx.set_response(response);
                Ok(())
            }
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#database-operation-with-retry" id="database-operation-with-retry"><h3>Database Operation with Retry</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn get_user_with_retry(id: u64) -&gt; Result&lt;User&gt; {
    RetryBuilder::new()
        .max_attempts(3)
        .initial_delay(Duration::from_millis(100))
        .execute(|| async {
            User::find(id)
                .await
                .map_err(|e| Error::database_query(format!(&quot;Failed to fetch user {}: {}&quot;, id, e)))?
                .ok_or_else(|| Error::model_not_found(format!(&quot;User {} not found&quot;, id)))
        })
        .await
        .context(format!(&quot;Failed to retrieve user {}&quot;, id))
}
#}</code></pre></pre>
<a class="header" href="print.html#configuration-2" id="configuration-2"><h2>Configuration</h2></a>
<a class="header" href="print.html#environment-variables-1" id="environment-variables-1"><h3>Environment Variables</h3></a>
<pre><code class="language-bash"># Logging configuration
RUSTF_LOG_LEVEL=info                    # debug, info, warn, error, critical
RUSTF_LOG_OUTPUT=both:/var/log/rustf.log  # console, file:&lt;path&gt;, both:&lt;path&gt;, none
RUSTF_LOG_STACK_TRACE=false             # Include stack traces
RUSTF_LOG_REQUEST_CONTEXT=true          # Include request context

# Error page configuration
RUSTF_ENV=production                    # development or production
RUSTF_ERROR_VERBOSE=false              # Verbose error messages in production
</code></pre>
<a class="header" href="print.html#configuration-file" id="configuration-file"><h3>Configuration File</h3></a>
<pre><code class="language-toml">[error]
# Error page templates directory
template_dir = &quot;views/errors&quot;

# Default error messages
default_404 = &quot;The page you're looking for could not be found&quot;
default_500 = &quot;An internal error occurred. Please try again later&quot;

[logging]
level = &quot;info&quot;
output = &quot;file:/var/log/rustf/app.log&quot;
max_file_size = 10485760  # 10MB
max_files = 5
include_stack_trace = false
include_request_context = true

[retry]
default_max_attempts = 3
default_initial_delay_ms = 100
default_max_delay_ms = 30000
default_backoff_multiplier = 2.0
</code></pre>
<a class="header" href="print.html#performance-considerations" id="performance-considerations"><h2>Performance Considerations</h2></a>
<a class="header" href="print.html#error-creation-cost" id="error-creation-cost"><h3>Error Creation Cost</h3></a>
<ul>
<li>Use static strings for fixed messages: <code>Error::validation(&quot;Invalid email&quot;)</code></li>
<li>Defer formatting until needed: <code>Error::internal(format!(...))</code> only when necessary</li>
<li>Consider caching error messages for hot paths</li>
</ul>
<a class="header" href="print.html#retry-overhead" id="retry-overhead"><h3>Retry Overhead</h3></a>
<ul>
<li>Use circuit breakers to prevent cascading failures</li>
<li>Configure reasonable timeouts and max attempts</li>
<li>Add jitter to prevent thundering herd</li>
</ul>
<a class="header" href="print.html#logging-performance" id="logging-performance"><h3>Logging Performance</h3></a>
<ul>
<li>Use appropriate log levels (don't log everything as ERROR)</li>
<li>Configure log rotation to prevent disk space issues</li>
<li>Consider async logging for high-throughput applications</li>
</ul>
<a class="header" href="print.html#testing" id="testing"><h2>Testing</h2></a>
<a class="header" href="print.html#testing-error-conditions" id="testing-error-conditions"><h3>Testing Error Conditions</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use rustf::error::{Error, ErrorContext};
    
    #[test]
    fn test_error_chain() {
        let error = database_operation()
            .context(&quot;Failed in service&quot;)
            .context(&quot;Failed in controller&quot;)
            .unwrap_err();
        
        let chain = ErrorChain::new(&amp;error);
        assert_eq!(chain.chain().len(), 3);
    }
    
    #[tokio::test]
    async fn test_retry_logic() {
        let mut attempts = 0;
        
        let result = with_retry(RetryPolicy::fixed(3, Duration::from_millis(10)), || async {
            attempts += 1;
            if attempts &lt; 3 {
                Err(Error::network(&quot;Temporary failure&quot;))
            } else {
                Ok(&quot;Success&quot;)
            }
        }).await;
        
        assert!(result.is_ok());
        assert_eq!(attempts, 3);
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#migration-guide-1" id="migration-guide-1"><h2>Migration Guide</h2></a>
<a class="header" href="print.html#from-simple-errors-to-rustf-errors" id="from-simple-errors-to-rustf-errors"><h3>From Simple Errors to RustF Errors</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Before
fn process() -&gt; Result&lt;Data, Box&lt;dyn std::error::Error&gt;&gt; {
    let data = fetch_data()?;
    Ok(data)
}

// After
fn process() -&gt; rustf::error::Result&lt;Data&gt; {
    let data = fetch_data()
        .map_err(|e| Error::internal(e.to_string()))
        .context(&quot;Failed to fetch data&quot;)?;
    Ok(data)
}
#}</code></pre></pre>
<a class="header" href="print.html#adding-retry-logic-to-existing-code" id="adding-retry-logic-to-existing-code"><h3>Adding Retry Logic to Existing Code</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Before
let result = unreliable_operation().await?;

// After
let result = RetryBuilder::new()
    .max_attempts(3)
    .execute(|| unreliable_operation())
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#conclusion-1" id="conclusion-1"><h2>Conclusion</h2></a>
<p>RustF's error system provides a comprehensive, production-ready solution for error handling in web applications. By following the patterns and best practices outlined in this guide, you can build robust, maintainable applications with excellent error handling and observability.</p>
<p>Key takeaways:</p>
<ul>
<li>Use specific error types for clarity</li>
<li>Add context to errors for better debugging</li>
<li>Implement retry logic for transient failures</li>
<li>Configure appropriate logging and monitoring</li>
<li>Never expose sensitive information in error messages</li>
<li>Test error conditions thoroughly</li>
</ul>
<p>For more information, see the <a href="https://docs.rs/rustf">API documentation</a> or the <a href="https://github.com/rustf/examples">examples</a> repository.</p>
<a class="header" href="print.html#rustf-definitions-system-documentation" id="rustf-definitions-system-documentation"><h1>RustF Definitions System Documentation</h1></a>
<a class="header" href="print.html#overview-9" id="overview-9"><h2>Overview</h2></a>
<p>The RustF Definitions System provides a powerful, convention-based framework for extending RustF with custom functionality. Inspired by modern web frameworks like Rails and Laravel, it enables developers to customize framework behavior through simple, discoverable patterns without modifying core code.</p>
<a class="header" href="print.html#core-philosophy" id="core-philosophy"><h2>Core Philosophy</h2></a>
<p>The definitions system follows these principles:</p>
<ol>
<li><strong>Convention Over Configuration</strong> - Place files in expected locations, and they're automatically discovered</li>
<li><strong>Type Safety</strong> - All extensions are type-checked at compile time</li>
<li><strong>Zero Boilerplate</strong> - No registration code needed with auto-discovery</li>
<li><strong>Composable</strong> - Mix and match different definition types as needed</li>
<li><strong>Framework Integration</strong> - Definitions integrate seamlessly with RustF's core systems</li>
</ol>
<a class="header" href="print.html#what-are-definitions" id="what-are-definitions"><h2>What Are Definitions?</h2></a>
<p>Definitions are modular extensions that customize framework behavior:</p>
<ul>
<li><strong>Helpers</strong> - Custom template functions for views</li>
<li><strong>Validators</strong> - Data validation logic for forms and APIs</li>
<li><strong>Session Storage</strong> - Custom session backend implementations</li>
</ul>
<a class="header" href="print.html#quick-start-3" id="quick-start-3"><h2>Quick Start</h2></a>
<a class="header" href="print.html#1-create-a-definitions-module" id="1-create-a-definitions-module"><h3>1. Create a Definitions Module</h3></a>
<p>Create a file in <code>src/definitions/</code> directory:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/definitions/app.rs
use rustf::definitions::{Definitions, Helper, Validator};
use rustf::error::Result;
use serde_json::Value;

/// Install function called by auto-discovery
/// This function MUST be named 'install' and have this exact signature
pub fn install(defs: &amp;mut Definitions) {
    // Register a custom helper
    defs.register_helper(&quot;format_money&quot;, FormatMoneyHelper);
    
    // Register a custom validator
    defs.register_validator(&quot;email&quot;, EmailValidator);
}

// Helper implementation
struct FormatMoneyHelper;

impl Helper for FormatMoneyHelper {
    fn call(&amp;self, args: &amp;[Value], _context: Option&lt;&amp;Value&gt;) -&gt; Result&lt;Value&gt; {
        if let Some(Value::Number(n)) = args.first() {
            if let Some(amount) = n.as_f64() {
                return Ok(Value::String(format!(&quot;${:.2}&quot;, amount)));
            }
        }
        Ok(Value::Null)
    }
    
    fn name(&amp;self) -&gt; &amp;str { &quot;format_money&quot; }
    fn description(&amp;self) -&gt; &amp;str { &quot;Formats numbers as currency&quot; }
}

// Validator implementation
struct EmailValidator;

impl Validator for EmailValidator {
    fn validate(&amp;self, value: &amp;Value, _options: Option&lt;&amp;Value&gt;) -&gt; Result&lt;()&gt; {
        if let Some(email) = value.as_str() {
            if !email.contains('@') || !email.contains('.') {
                return Err(rustf::error::Error::validation(&quot;Invalid email format&quot;));
            }
        }
        Ok(())
    }
    
    fn name(&amp;self) -&gt; &amp;str { &quot;email&quot; }
    fn description(&amp;self) -&gt; &amp;str { &quot;Validates email addresses&quot; }
}
#}</code></pre></pre>
<a class="header" href="print.html#2-register-definitions-in-your-app" id="2-register-definitions-in-your-app"><h3>2. Register Definitions in Your App</h3></a>
<p>Use auto-discovery in <code>main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;

#[rustf::auto_discover]
#[tokio::main]
async fn main() -&gt; rustf::Result&lt;()&gt; {
    let app = RustF::new()
        .definitions_from(auto_definitions!())  // Auto-discovers all definitions
        .controllers(auto_controllers!());
    
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#3-use-your-definitions" id="3-use-your-definitions"><h3>3. Use Your Definitions</h3></a>
<p>In views (for helpers):</p>
<pre><code class="language-html">&lt;!-- Price: {{ price | format_money }} --&gt;
&lt;!-- Outputs: Price: $99.99 --&gt;
</code></pre>
<p>In controllers (for validators):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn create_user(ctx: Context) -&gt; Result&lt;Response&gt; {
    let email = ctx.param(&quot;email&quot;)?;
    
    // Get validators from global definitions
    let definitions = rustf::definitions::get().await;
    let defs = definitions.read().await;
    let validator = defs.validators.get(&quot;email&quot;)?;
    validator.validate(&amp;json!(email), None)?;
    
    // Proceed with user creation...
    ctx.json(json!({&quot;status&quot;: &quot;user created&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#component-types" id="component-types"><h2>Component Types</h2></a>
<a class="header" href="print.html#template-helpers" id="template-helpers"><h3>Template Helpers</h3></a>
<p>Helpers are functions that transform data in views. They're perfect for formatting, calculations, and generating HTML snippets.</p>
<a class="header" href="print.html#creating-a-helper" id="creating-a-helper"><h4>Creating a Helper</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::definitions::Helper;
use rustf::error::Result;
use serde_json::Value;

struct DateFormatHelper;

impl Helper for DateFormatHelper {
    fn call(&amp;self, args: &amp;[Value], _context: Option&lt;&amp;Value&gt;) -&gt; Result&lt;Value&gt; {
        // args[0] = date string/timestamp
        // args[1] = format string (optional)
        
        if let Some(date_value) = args.first() {
            let format = args.get(1)
                .and_then(|v| v.as_str())
                .unwrap_or(&quot;%Y-%m-%d&quot;);
            
            // Format the date...
            let formatted = format_date(date_value, format)?;
            return Ok(Value::String(formatted));
        }
        
        Ok(Value::Null)
    }
    
    fn name(&amp;self) -&gt; &amp;str { &quot;date_format&quot; }
    
    fn description(&amp;self) -&gt; &amp;str { 
        &quot;Formats dates according to strftime patterns&quot; 
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#using-helpers-in-views" id="using-helpers-in-views"><h4>Using Helpers in Views</h4></a>
<pre><code class="language-html">&lt;!-- TotalJS syntax --&gt;
@{date_format(user.created_at, &quot;%B %d, %Y&quot;)}

&lt;!-- Tera syntax --&gt;
{{ user.created_at | date_format(&quot;%B %d, %Y&quot;) }}

&lt;!-- With default format --&gt;
{{ timestamp | date_format }}
</code></pre>
<a class="header" href="print.html#built-in-helper-registry" id="built-in-helper-registry"><h4>Built-in Helper Registry</h4></a>
<p>RustF provides a <code>HelperRegistry</code> with several built-in helpers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct HelperRegistry {
    helpers: HashMap&lt;String, Box&lt;dyn Helper&gt;&gt;,
}

impl HelperRegistry {
    pub fn new() -&gt; Self {
        let mut registry = Self { helpers: HashMap::new() };
        
        // Register built-in helpers
        registry.register(&quot;format_currency&quot;, FormatCurrencyHelper);
        registry.register(&quot;truncate&quot;, TruncateHelper);
        registry.register(&quot;pluralize&quot;, PluralizeHelper);
        registry.register(&quot;time_ago&quot;, TimeAgoHelper);
        registry.register(&quot;format_date&quot;, FormatDateHelper);
        registry.register(&quot;url_encode&quot;, UrlEncodeHelper);
        registry.register(&quot;url_decode&quot;, UrlDecodeHelper);
        registry.register(&quot;json&quot;, JsonHelper);
        registry.register(&quot;default&quot;, DefaultHelper);
        
        registry
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#validators" id="validators"><h3>Validators</h3></a>
<p>Validators ensure data integrity before processing. They're essential for form validation, API input validation, and business rule enforcement.</p>
<a class="header" href="print.html#creating-a-validator" id="creating-a-validator"><h4>Creating a Validator</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::definitions::Validator;
use rustf::error::{Result, Error};
use serde_json::Value;

struct PasswordStrengthValidator;

impl Validator for PasswordStrengthValidator {
    fn validate(&amp;self, value: &amp;Value, options: Option&lt;&amp;Value&gt;) -&gt; Result&lt;()&gt; {
        let min_length = options
            .and_then(|o| o.get(&quot;min_length&quot;))
            .and_then(|v| v.as_u64())
            .unwrap_or(8) as usize;
        
        if let Some(password) = value.as_str() {
            if password.len() &lt; min_length {
                return Err(Error::validation(
                    format!(&quot;Password must be at least {} characters&quot;, min_length)
                ));
            }
            
            let has_upper = password.chars().any(|c| c.is_uppercase());
            let has_lower = password.chars().any(|c| c.is_lowercase());
            let has_digit = password.chars().any(|c| c.is_numeric());
            let has_special = password.chars().any(|c| !c.is_alphanumeric());
            
            if !(has_upper &amp;&amp; has_lower &amp;&amp; has_digit &amp;&amp; has_special) {
                return Err(Error::validation(
                    &quot;Password must contain uppercase, lowercase, digit, and special character&quot;
                ));
            }
        }
        
        Ok(())
    }
    
    fn name(&amp;self) -&gt; &amp;str { &quot;password_strength&quot; }
    
    fn description(&amp;self) -&gt; &amp;str { 
        &quot;Validates password meets security requirements&quot; 
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#using-validators" id="using-validators"><h4>Using Validators</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn update_password(ctx: Context) -&gt; Result&lt;Response&gt; {
    let new_password = ctx.param(&quot;new_password&quot;)?;
    
    // Get validator from global definitions
    let definitions = rustf::definitions::get().await;
    let defs = definitions.read().await;
    let validator = defs.validators.get(&quot;password_strength&quot;)?;
    
    // Validate with options
    let options = json!({
        &quot;min_length&quot;: 12,
        &quot;require_special&quot;: true
    });
    
    validator.validate(&amp;json!(new_password), Some(&amp;options))?;
    
    // Password is valid, proceed with update
    update_user_password(&amp;new_password).await?;
    
    ctx.json(json!({&quot;status&quot;: &quot;password updated&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#custom-session-storage" id="custom-session-storage"><h3>Custom Session Storage</h3></a>
<p>The definitions system enables custom session storage backends through a factory pattern. This is the modern, recommended approach for implementing database or custom storage backends.</p>
<a class="header" href="print.html#creating-custom-session-storage" id="creating-custom-session-storage"><h4>Creating Custom Session Storage</h4></a>
<p>Create <code>src/definitions/session_storage.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::definitions::Definitions;
use rustf::session::{SessionStorage, SessionData, StorageStats};
use rustf::config::SessionConfig;
use rustf::error::Result;
use async_trait::async_trait;
use sqlx::PgPool;
use std::sync::Arc;
use std::time::Duration;

/// Install function called by auto-discovery
/// This registers our custom session storage factory with the definitions system
pub fn install(defs: &amp;mut Definitions) {
    log::info!(&quot;Installing custom session storage from definitions&quot;);
    defs.set_session_storage_factory(create_session_storage);
}

/// Factory function that creates our custom session storage
/// This is called by the framework when initializing sessions
fn create_session_storage(config: &amp;SessionConfig) -&gt; Result&lt;Arc&lt;dyn SessionStorage&gt;&gt; {
    log::info!(&quot;Creating custom PostgreSQL session storage&quot;);
    
    // You can access configuration here
    let database_url = std::env::var(&quot;DATABASE_URL&quot;)
        .unwrap_or_else(|_| &quot;postgresql://localhost/myapp&quot;.to_string());
    
    // Create and return your custom storage
    let storage = PostgresSessionStorage::new(&amp;database_url)?;
    Ok(Arc::new(storage))
}

/// PostgreSQL session storage implementation
pub struct PostgresSessionStorage {
    pool: PgPool,
}

impl PostgresSessionStorage {
    pub fn new(database_url: &amp;str) -&gt; Result&lt;Self&gt; {
        // Note: For simplicity, using block_on here
        // In production, consider initializing the pool elsewhere
        let pool = futures::executor::block_on(
            PgPool::connect(database_url)
        ).map_err(|e| rustf::error::Error::internal(
            format!(&quot;Failed to connect to database: {}&quot;, e)
        ))?;
        
        // Create table if needed
        futures::executor::block_on(async {
            sqlx::query(
                &quot;CREATE TABLE IF NOT EXISTS sessions (
                    id VARCHAR(64) PRIMARY KEY,
                    data JSONB NOT NULL,
                    expires_at TIMESTAMP NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )&quot;
            ).execute(&amp;pool).await
        }).map_err(|e| rustf::error::Error::internal(
            format!(&quot;Failed to create sessions table: {}&quot;, e)
        ))?;
        
        Ok(Self { pool })
    }
}

#[async_trait]
impl SessionStorage for PostgresSessionStorage {
    async fn get(&amp;self, session_id: &amp;str) -&gt; Result&lt;Option&lt;SessionData&gt;&gt; {
        let row = sqlx::query!(
            &quot;SELECT data FROM sessions 
             WHERE id = $1 AND expires_at &gt; NOW()&quot;,
            session_id
        )
        .fetch_optional(&amp;self.pool)
        .await?;
        
        match row {
            Some(row) =&gt; {
                let mut data: SessionData = serde_json::from_value(row.data)?;
                data.touch(); // Update last accessed
                
                // Update timestamp in database
                sqlx::query!(
                    &quot;UPDATE sessions SET updated_at = NOW() WHERE id = $1&quot;,
                    session_id
                )
                .execute(&amp;self.pool)
                .await?;
                
                Ok(Some(data))
            }
            None =&gt; Ok(None)
        }
    }
    
    async fn set(
        &amp;self, 
        session_id: &amp;str, 
        data: &amp;SessionData, 
        ttl: Duration
    ) -&gt; Result&lt;()&gt; {
        let expires_at = chrono::Utc::now() + 
            chrono::Duration::seconds(ttl.as_secs() as i64);
        let json_data = serde_json::to_value(data)?;
        
        sqlx::query!(
            &quot;INSERT INTO sessions (id, data, expires_at, updated_at)
             VALUES ($1, $2, $3, NOW())
             ON CONFLICT (id) DO UPDATE
             SET data = $2, expires_at = $3, updated_at = NOW()&quot;,
            session_id,
            json_data,
            expires_at
        )
        .execute(&amp;self.pool)
        .await?;
        
        Ok(())
    }
    
    async fn delete(&amp;self, session_id: &amp;str) -&gt; Result&lt;()&gt; {
        sqlx::query!(
            &quot;DELETE FROM sessions WHERE id = $1&quot;,
            session_id
        )
        .execute(&amp;self.pool)
        .await?;
        Ok(())
    }
    
    async fn exists(&amp;self, session_id: &amp;str) -&gt; Result&lt;bool&gt; {
        let exists = sqlx::query!(
            &quot;SELECT 1 as exists FROM sessions 
             WHERE id = $1 AND expires_at &gt; NOW()&quot;,
            session_id
        )
        .fetch_optional(&amp;self.pool)
        .await?
        .is_some();
        
        Ok(exists)
    }
    
    async fn cleanup_expired(&amp;self) -&gt; Result&lt;usize&gt; {
        let result = sqlx::query!(
            &quot;DELETE FROM sessions WHERE expires_at &lt;= NOW()&quot;
        )
        .execute(&amp;self.pool)
        .await?;
        
        Ok(result.rows_affected() as usize)
    }
    
    fn backend_name(&amp;self) -&gt; &amp;'static str {
        &quot;postgresql&quot;
    }
    
    async fn stats(&amp;self) -&gt; Result&lt;StorageStats&gt; {
        let total: i64 = sqlx::query_scalar!(
            &quot;SELECT COUNT(*) FROM sessions&quot;
        )
        .fetch_one(&amp;self.pool)
        .await?;
        
        let active: i64 = sqlx::query_scalar!(
            &quot;SELECT COUNT(*) FROM sessions WHERE expires_at &gt; NOW()&quot;
        )
        .fetch_one(&amp;self.pool)
        .await?;
        
        Ok(StorageStats {
            total_sessions: total as usize,
            active_sessions: active as usize,
            expired_sessions: (total - active) as usize,
            backend_metrics: HashMap::new(),
        })
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#integration-with-auto-discovery" id="integration-with-auto-discovery"><h4>Integration with Auto-Discovery</h4></a>
<p>The session storage factory is automatically discovered and used when you include it in your definitions:</p>
<pre><pre class="playpen"><code class="language-rust">// main.rs
#[rustf::auto_discover]
#[tokio::main]
async fn main() -&gt; rustf::Result&lt;()&gt; {
    let app = RustF::new()
        .definitions_from(auto_definitions!())  // Discovers session_storage.rs
        .controllers(auto_controllers!());
    
    // Your custom session storage is now active!
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#auto-discovery-system" id="auto-discovery-system"><h2>Auto-Discovery System</h2></a>
<a class="header" href="print.html#how-auto-discovery-works" id="how-auto-discovery-works"><h3>How Auto-Discovery Works</h3></a>
<p>The <code>auto_definitions!()</code> macro scans your <code>src/definitions/</code> directory and automatically:</p>
<ol>
<li>Finds all <code>.rs</code> files with an <code>install</code> function</li>
<li>Generates the necessary module declarations</li>
<li>Calls each <code>install</code> function to register definitions</li>
<li>Makes them available throughout your application</li>
</ol>
<p><strong>IMPORTANT</strong>: Every file in <code>src/definitions/</code> must export a public <code>install</code> function with this exact signature:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn install(defs: &amp;mut Definitions) {
    // Register your definitions here
}
#}</code></pre></pre>
<p>This function is where you register all your helpers, validators, or storage factories. The auto-discovery system will call this function during application initialization.</p>
<a class="header" href="print.html#file-convention" id="file-convention"><h3>File Convention</h3></a>
<p>Place definition files in <code>src/definitions/</code>:</p>
<pre><code>src/
  definitions/
    app.rs           # General helpers and validators
    helpers.rs       # Template helpers only
    validators.rs    # Validators only
    session_storage.rs  # Custom session storage factory
</code></pre>
<p>Each file should export an <code>install</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn install(defs: &amp;mut Definitions) {
    // Register your definitions here
}
#}</code></pre></pre>
<a class="header" href="print.html#manual-registration-1" id="manual-registration-1"><h3>Manual Registration</h3></a>
<p>If you prefer explicit control, register definitions manually:</p>
<pre><pre class="playpen"><code class="language-rust">// main.rs
use my_app::definitions;

#[tokio::main]
async fn main() -&gt; rustf::Result&lt;()&gt; {
    let app = RustF::new()
        .definitions_from(definitions::app::install)
        .definitions_from(definitions::auth::install)
        .controllers(auto_controllers!());
    
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#advanced-topics" id="advanced-topics"><h2>Advanced Topics</h2></a>
<a class="header" href="print.html#accessing-definitions-in-code" id="accessing-definitions-in-code"><h3>Accessing Definitions in Code</h3></a>
<a class="header" href="print.html#in-controllers-3" id="in-controllers-3"><h4>In Controllers</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn my_controller(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Get definitions from global registry
    let definitions = rustf::definitions::get().await;
    let defs = definitions.read().await;
    
    // Access helpers
    let helper = defs.helpers.get(&quot;format_money&quot;)?;
    let formatted = helper.call(&amp;[json!(99.99)], None)?;
    
    // Access validators  
    let validator = defs.validators.get(&quot;email&quot;)?;
    validator.validate(&amp;json!(&quot;user@example.com&quot;), None)?;
    
    ctx.json(json!({&quot;formatted&quot;: formatted}))
}
#}</code></pre></pre>
<a class="header" href="print.html#in-middleware-1" id="in-middleware-1"><h4>In Middleware</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::middleware::{InboundMiddleware, InboundAction};
use rustf::context::Context;
use rustf::error::Result;

pub struct ValidationMiddleware;

impl InboundMiddleware for ValidationMiddleware {
    fn process_request(&amp;self, ctx: &amp;mut Context) -&gt; Result&lt;InboundAction&gt; {
        // Get email from request
        let email = ctx.param(&quot;email&quot;)?;
        
        // Get validator from global definitions
        // Note: Using block_on since middleware is synchronous
        let definitions = futures::executor::block_on(
            rustf::definitions::get()
        );
        let defs = futures::executor::block_on(definitions.read());
        let validator = defs.validators.get(&quot;email&quot;)?;
        validator.validate(&amp;json!(email), None)?;
        
        Ok(InboundAction::Continue)
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#testing-definitions" id="testing-definitions"><h3>Testing Definitions</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    use rustf::definitions::Definitions;
    
    #[test]
    fn test_format_money_helper() {
        let mut defs = Definitions::new();
        super::install(&amp;mut defs);
        
        let helper = defs.helpers.get(&quot;format_money&quot;).unwrap();
        let result = helper.call(&amp;[json!(42.50)], None).unwrap();
        
        assert_eq!(result, json!(&quot;$42.50&quot;));
    }
    
    #[test]
    fn test_email_validator() {
        let mut defs = Definitions::new();
        super::install(&amp;mut defs);
        
        let validator = defs.validators.get(&quot;email&quot;).unwrap();
        
        // Valid email
        assert!(validator.validate(&amp;json!(&quot;user@example.com&quot;), None).is_ok());
        
        // Invalid email
        assert!(validator.validate(&amp;json!(&quot;invalid&quot;), None).is_err());
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#async-helpers-and-validators" id="async-helpers-and-validators"><h3>Async Helpers and Validators</h3></a>
<p>For async operations, wrap them appropriately:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct AsyncDataHelper;

impl Helper for AsyncDataHelper {
    fn call(&amp;self, args: &amp;[Value], _context: Option&lt;&amp;Value&gt;) -&gt; Result&lt;Value&gt; {
        // For async operations, you might need to use block_on
        // or restructure to handle async differently
        let data = futures::executor::block_on(async {
            fetch_async_data().await
        })?;
        
        Ok(json!(data))
    }
    
    fn name(&amp;self) -&gt; &amp;str { &quot;async_data&quot; }
    fn description(&amp;self) -&gt; &amp;str { &quot;Fetches async data&quot; }
}
#}</code></pre></pre>
<a class="header" href="print.html#best-practices-15" id="best-practices-15"><h2>Best Practices</h2></a>
<a class="header" href="print.html#1-keep-definitions-focused" id="1-keep-definitions-focused"><h3>1. Keep Definitions Focused</h3></a>
<p>Each definition should have a single, clear purpose:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Good: Specific, reusable
struct FormatCurrencyHelper;
struct ValidateEmailValidator;

// Less ideal: Too generic
struct GeneralHelper;
struct DoEverythingValidator;
#}</code></pre></pre>
<a class="header" href="print.html#2-use-descriptive-names" id="2-use-descriptive-names"><h3>2. Use Descriptive Names</h3></a>
<p>Names should clearly indicate function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Good
&quot;format_date&quot;
&quot;validate_phone&quot;
&quot;sanitize_html&quot;

// Less clear
&quot;process&quot;
&quot;check&quot;
&quot;helper1&quot;
#}</code></pre></pre>
<a class="header" href="print.html#3-handle-errors-gracefully" id="3-handle-errors-gracefully"><h3>3. Handle Errors Gracefully</h3></a>
<p>Always provide helpful error messages:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Validator for PhoneValidator {
    fn validate(&amp;self, value: &amp;Value, _options: Option&lt;&amp;Value&gt;) -&gt; Result&lt;()&gt; {
        if let Some(phone) = value.as_str() {
            if !is_valid_phone(phone) {
                return Err(Error::validation(
                    format!(&quot;'{}' is not a valid phone number. Expected format: +1-555-555-5555&quot;, phone)
                ));
            }
        } else {
            return Err(Error::validation(
                &quot;Phone number must be a string&quot;
            ));
        }
        Ok(())
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#4-document-your-definitions" id="4-document-your-definitions"><h3>4. Document Your Definitions</h3></a>
<p>Always implement the <code>description()</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Helper for MyHelper {
    fn name(&amp;self) -&gt; &amp;str { &quot;my_helper&quot; }
    
    fn description(&amp;self) -&gt; &amp;str {
        &quot;Formats user data for display. \
         Usage: {{ user | my_helper }} or {{ my_helper(user, 'option') }}&quot;
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#5-make-definitions-testable" id="5-make-definitions-testable"><h3>5. Make Definitions Testable</h3></a>
<p>Design definitions to be easily testable:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Separate business logic from the definition
fn format_phone_number(phone: &amp;str) -&gt; String {
    // Formatting logic here
}

struct FormatPhoneHelper;

impl Helper for FormatPhoneHelper {
    fn call(&amp;self, args: &amp;[Value], _context: Option&lt;&amp;Value&gt;) -&gt; Result&lt;Value&gt; {
        if let Some(Value::String(phone)) = args.first() {
            Ok(Value::String(format_phone_number(phone)))
        } else {
            Ok(Value::Null)
        }
    }
    // ...
}

#[test]
fn test_phone_formatting() {
    assert_eq!(format_phone_number(&quot;5555555555&quot;), &quot;+1 (555) 555-5555&quot;);
}
#}</code></pre></pre>
<a class="header" href="print.html#integration-with-rustf-systems" id="integration-with-rustf-systems"><h2>Integration with RustF Systems</h2></a>
<a class="header" href="print.html#view-system-integration" id="view-system-integration"><h3>View System Integration</h3></a>
<p>Helpers are automatically available in both TotalJS and Tera templates:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Registered in definitions
defs.register_helper(&quot;user_avatar&quot;, UserAvatarHelper);

// Available in TotalJS views
// @{user_avatar(user.email, 200)}

// Available in Tera templates
// {{ user.email | user_avatar(200) }}
#}</code></pre></pre>
<a class="header" href="print.html#validation-system-integration" id="validation-system-integration"><h3>Validation System Integration</h3></a>
<p>Validators work with RustF's error handling:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn api_endpoint(ctx: Context) -&gt; Result&lt;Response&gt; {
    let data = ctx.json_body()?;
    
    // Get validators from global definitions
    let definitions = rustf::definitions::get().await;
    let defs = definitions.read().await;
    
    // Validate multiple fields
    defs.validators.get(&quot;email&quot;)?.validate(&amp;data[&quot;email&quot;], None)?;
    defs.validators.get(&quot;password&quot;)?.validate(&amp;data[&quot;password&quot;], None)?;
    defs.validators.get(&quot;age&quot;)?.validate(&amp;data[&quot;age&quot;], Some(&amp;json!({&quot;min&quot;: 18})))?;
    
    // All validations passed
    process_data(data).await?;
    
    ctx.json(json!({&quot;status&quot;: &quot;success&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#session-system-integration" id="session-system-integration"><h3>Session System Integration</h3></a>
<p>Custom session storage integrates seamlessly with RustF's session middleware:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Your custom storage is automatically used when defined
// src/definitions/session_storage.rs exists and has an install() function

// In controllers, sessions work normally
async fn login(ctx: Context) -&gt; Result&lt;Response&gt; {
    ctx.session_set(&quot;user_id&quot;, user.id)?;
    ctx.session_set(&quot;username&quot;, user.username)?;
    
    // Your custom storage handles persistence
    ctx.json(json!({&quot;status&quot;: &quot;logged in&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#troubleshooting-4" id="troubleshooting-4"><h2>Troubleshooting</h2></a>
<a class="header" href="print.html#definitions-not-found" id="definitions-not-found"><h3>Definitions Not Found</h3></a>
<p>If your definitions aren't being discovered:</p>
<ol>
<li>Ensure files are in <code>src/definitions/</code></li>
<li>Check that files have an <code>install</code> function</li>
<li>Verify you're using <code>auto_definitions!()</code> or manual registration</li>
<li>Make sure the function signature matches: <code>pub fn install(defs: &amp;mut Definitions)</code></li>
</ol>
<a class="header" href="print.html#helper-not-available-in-views" id="helper-not-available-in-views"><h3>Helper Not Available in Views</h3></a>
<ol>
<li>Confirm the helper is registered in <code>install()</code></li>
<li>Check the helper name matches exactly (case-sensitive)</li>
<li>Verify the view engine is configured correctly</li>
<li>Check helper's <code>name()</code> method returns the expected string</li>
</ol>
<a class="header" href="print.html#validator-errors-not-showing" id="validator-errors-not-showing"><h3>Validator Errors Not Showing</h3></a>
<ol>
<li>Ensure you're returning proper <code>Error::validation()</code> errors</li>
<li>Check that error messages are descriptive</li>
<li>Verify the validator is registered with the correct name</li>
<li>Test the validator independently to ensure it works</li>
</ol>
<a class="header" href="print.html#session-storage-not-being-used" id="session-storage-not-being-used"><h3>Session Storage Not Being Used</h3></a>
<ol>
<li>Verify <code>src/definitions/session_storage.rs</code> exists</li>
<li>Check the file has an <code>install(defs: &amp;mut Definitions)</code> function</li>
<li>Ensure <code>install()</code> calls <code>defs.set_session_storage_factory(your_factory_fn)</code></li>
<li>Verify your factory function signature matches: <code>fn(&amp;SessionConfig) -&gt; Result&lt;Arc&lt;dyn SessionStorage&gt;&gt;</code></li>
<li>Confirm auto-discovery is enabled with <code>auto_definitions!()</code> in main.rs</li>
<li>Check that session middleware is enabled in configuration</li>
<li>Look for log messages: &quot;Using custom session storage from definitions&quot;</li>
</ol>
<p><strong>Important</strong>: The <code>SessionConfig</code> parameter is from <code>rustf::config::SessionConfig</code>, not <code>rustf::session::manager::SessionConfig</code></p>
<a class="header" href="print.html#examples-repository" id="examples-repository"><h2>Examples Repository</h2></a>
<p>For complete working examples of all definition types, see the RustF examples repository:</p>
<ul>
<li><strong>Basic Definitions</strong>: Simple helpers and validators</li>
<li><strong>Advanced Helpers</strong>: Complex formatting and HTML generation</li>
<li><strong>Custom Validators</strong>: Business rule validation</li>
<li><strong>Database Session Storage</strong>: PostgreSQL, MySQL implementations</li>
<li><strong>Redis Session Storage</strong>: High-performance session storage</li>
<li><strong>Multi-tenant Definitions</strong>: Per-tenant customization</li>
</ul>
<a class="header" href="print.html#summary-4" id="summary-4"><h2>Summary</h2></a>
<p>The RustF Definitions System provides a powerful, type-safe way to extend the framework with custom functionality. By following conventions and using auto-discovery, you can build modular, reusable extensions that integrate seamlessly with RustF's core systems.</p>
<p>Key takeaways:</p>
<ol>
<li><strong>Use conventions</strong> - Place files in <code>src/definitions/</code> for auto-discovery</li>
<li><strong>Implement traits</strong> - <code>Helper</code>, <code>Validator</code>, and <code>SessionStorage</code> provide the contracts</li>
<li><strong>Leverage auto-discovery</strong> - Let the framework handle registration</li>
<li><strong>Keep it simple</strong> - Each definition should do one thing well</li>
<li><strong>Test thoroughly</strong> - Definitions are easy to unit test</li>
</ol>
<p>With definitions, you can build powerful, customized applications while keeping your code organized, maintainable, and reusable across projects.</p>
<a class="header" href="print.html#advanced-topics-1" id="advanced-topics-1"><h1>Advanced Topics</h1></a>
<p>This section covers advanced features and optimization techniques for experienced RustF developers.</p>
<a class="header" href="print.html#topics" id="topics"><h2>Topics</h2></a>
<a class="header" href="print.html#a-hrefperformancemdperformance-optimizationa" id="a-hrefperformancemdperformance-optimizationa"><h3><a href="performance.md">Performance Optimization</a></h3></a>
<p>Learn how to optimize your RustF application for production:</p>
<ul>
<li>View caching</li>
<li>Database query optimization</li>
<li>Session storage strategies</li>
<li>Static file serving</li>
<li>Response compression</li>
<li>Profiling and benchmarking</li>
</ul>
<a class="header" href="print.html#a-hrefworkersmdworkersa" id="a-hrefworkersmdworkersa"><h3><a href="workers.md">Workers</a></h3></a>
<p>Background job processing with RustF workers:</p>
<ul>
<li>Creating workers</li>
<li>Task scheduling</li>
<li>Error handling</li>
<li>Monitoring and logging</li>
</ul>
<a class="header" href="print.html#a-hrefeventsmdeventsa" id="a-hrefeventsmdeventsa"><h3><a href="events.md">Events</a></h3></a>
<p>Event-driven architecture with RustF:</p>
<ul>
<li>Event system overview</li>
<li>Creating event handlers</li>
<li>Event priorities</li>
<li>Built-in events</li>
</ul>
<a class="header" href="print.html#a-hrefmodulesmdmodulesa" id="a-hrefmodulesmdmodulesa"><h3><a href="modules.md">Modules</a></h3></a>
<p>Shared business logic modules:</p>
<ul>
<li>Creating modules</li>
<li>Module registration</li>
<li>Dependency injection</li>
<li>Best practices</li>
</ul>
<a class="header" href="print.html#a-hrefclimdcli-toola" id="a-hrefclimdcli-toola"><h3><a href="cli.md">CLI Tool</a></h3></a>
<p>Comprehensive guide to the RustF CLI:</p>
<ul>
<li>Project scaffolding</li>
<li>Schema management</li>
<li>Database tools</li>
<li>Code generation</li>
</ul>
<a class="header" href="print.html#related-topics-2" id="related-topics-2"><h2>Related Topics</h2></a>
<ul>
<li><a href="../guides/controllers.md">Core Guides</a> - Essential framework concepts</li>
<li><a href="../api-reference/context.md">API Reference</a> - Complete API documentation</li>
<li><a href="../examples/README.md">Examples</a> - Practical tutorials</li>
</ul>
<a class="header" href="print.html#performance-optimization" id="performance-optimization"><h1>Performance Optimization</h1></a>
<p>This guide covers performance optimization techniques for RustF applications.</p>
<a class="header" href="print.html#overview-10" id="overview-10"><h2>Overview</h2></a>
<p>RustF is designed for performance, but there are several strategies to optimize your application further.</p>
<a class="header" href="print.html#view-caching" id="view-caching"><h2>View Caching</h2></a>
<a class="header" href="print.html#enable-view-caching" id="enable-view-caching"><h3>Enable View Caching</h3></a>
<p>In production, enable view caching:</p>
<pre><code class="language-toml">[views]
cache_enabled = true
</code></pre>
<p>This caches compiled templates to avoid recompilation on every request.</p>
<a class="header" href="print.html#database-optimization" id="database-optimization"><h2>Database Optimization</h2></a>
<a class="header" href="print.html#connection-pooling" id="connection-pooling"><h3>Connection Pooling</h3></a>
<p>Configure appropriate pool size:</p>
<pre><code class="language-toml">[database]
pool_size = 20
max_connections = 50
</code></pre>
<a class="header" href="print.html#query-optimization" id="query-optimization"><h3>Query Optimization</h3></a>
<ul>
<li>Use indexes on frequently queried columns</li>
<li>Avoid N+1 queries</li>
<li>Use pagination for large datasets</li>
<li>Cache frequently accessed data</li>
</ul>
<a class="header" href="print.html#example-optimized-query" id="example-optimized-query"><h3>Example: Optimized Query</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Bad: N+1 queries
for post in posts {
    let author = get_author(post.author_id)?; // Query per post
}

// Good: Single query with join
let posts_with_authors = Posts::query()
    .join(&quot;users&quot;, &quot;posts.author_id&quot;, &quot;users.id&quot;)
    .select(&quot;posts.*, users.name as author_name&quot;)
    .find()?;
#}</code></pre></pre>
<a class="header" href="print.html#session-storage" id="session-storage"><h2>Session Storage</h2></a>
<a class="header" href="print.html#use-redis-for-sessions" id="use-redis-for-sessions"><h3>Use Redis for Sessions</h3></a>
<p>For better performance and scalability:</p>
<pre><code class="language-toml">[session]
storage = &quot;redis&quot;
redis_url = &quot;redis://localhost:6379&quot;
</code></pre>
<p>Benefits:</p>
<ul>
<li>Faster than database storage</li>
<li>Shared across multiple instances</li>
<li>Automatic expiration</li>
</ul>
<a class="header" href="print.html#static-file-serving" id="static-file-serving"><h2>Static File Serving</h2></a>
<a class="header" href="print.html#serve-via-nginxcdn" id="serve-via-nginxcdn"><h3>Serve via Nginx/CDN</h3></a>
<p>Don't serve static files through the application:</p>
<pre><code class="language-nginx"># Nginx configuration
location /static/ {
    alias /path/to/public/;
    expires 30d;
    add_header Cache-Control &quot;public, immutable&quot;;
}
</code></pre>
<a class="header" href="print.html#response-compression" id="response-compression"><h2>Response Compression</h2></a>
<a class="header" href="print.html#enable-gzip" id="enable-gzip"><h3>Enable Gzip</h3></a>
<p>Configure nginx for compression:</p>
<pre><code class="language-nginx">gzip on;
gzip_types text/plain text/css application/json application/javascript;
gzip_min_length 1000;
</code></pre>
<a class="header" href="print.html#caching-strategies" id="caching-strategies"><h2>Caching Strategies</h2></a>
<a class="header" href="print.html#application-level-caching" id="application-level-caching"><h3>Application-Level Caching</h3></a>
<p>Use in-memory caching for frequently accessed data:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::sync::Arc;
use std::sync::RwLock;
use std::collections::HashMap;

static CACHE: LazyLock&lt;Arc&lt;RwLock&lt;HashMap&lt;String, Value&gt;&gt;&gt;&gt; = 
    LazyLock::new(|| Arc::new(RwLock::new(HashMap::new())));

fn get_cached_data(key: &amp;str) -&gt; Option&lt;Value&gt; {
    CACHE.read().unwrap().get(key).cloned()
}

fn set_cached_data(key: String, value: Value) {
    CACHE.write().unwrap().insert(key, value);
}
#}</code></pre></pre>
<a class="header" href="print.html#http-caching" id="http-caching"><h3>HTTP Caching</h3></a>
<p>Set appropriate cache headers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.add_header(&quot;Cache-Control&quot;, &quot;public, max-age=3600&quot;);
#}</code></pre></pre>
<a class="header" href="print.html#request-pooling" id="request-pooling"><h2>Request Pooling</h2></a>
<p>RustF includes request pooling for high-performance scenarios:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::pool::global_request_pool;

// Get pooled request
let pooled_req = global_request_pool().get().await?;

// Use pooled request
// ... process request ...

// Return to pool (automatic)
#}</code></pre></pre>
<a class="header" href="print.html#async-operations" id="async-operations"><h2>Async Operations</h2></a>
<a class="header" href="print.html#use-async-for-io" id="use-async-for-io"><h3>Use Async for I/O</h3></a>
<p>Always use async for database and network operations:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Good: Async database query
let users = db.query_async(&quot;SELECT * FROM users&quot;).await?;

// Bad: Blocking operation
let users = db.query(&quot;SELECT * FROM users&quot;)?; // Blocks thread
#}</code></pre></pre>
<a class="header" href="print.html#memory-management" id="memory-management"><h2>Memory Management</h2></a>
<a class="header" href="print.html#avoid-unnecessary-cloning" id="avoid-unnecessary-cloning"><h3>Avoid Unnecessary Cloning</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Bad: Unnecessary clone
let data = expensive_data.clone();
process(data);

// Good: Use reference
process(&amp;expensive_data);
#}</code></pre></pre>
<a class="header" href="print.html#use-string-capacity-hints" id="use-string-capacity-hints"><h3>Use String Capacity Hints</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Pre-allocate string capacity
let mut output = String::with_capacity(estimated_size);
#}</code></pre></pre>
<a class="header" href="print.html#profiling" id="profiling"><h2>Profiling</h2></a>
<a class="header" href="print.html#use-cargo-instruments" id="use-cargo-instruments"><h3>Use Cargo Instruments</h3></a>
<pre><code class="language-bash">cargo install cargo-instruments
cargo instruments --template time
</code></pre>
<a class="header" href="print.html#benchmark-critical-paths" id="benchmark-critical-paths"><h3>Benchmark Critical Paths</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod benches {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn bench_query(c: &amp;mut Criterion) {
        c.bench_function(&quot;query_users&quot;, |b| {
            b.iter(|| {
                black_box(Users::find_all().unwrap());
            });
        });
    }

    criterion_group!(benches, bench_query);
    criterion_main!(benches);
}
#}</code></pre></pre>
<a class="header" href="print.html#monitoring" id="monitoring"><h2>Monitoring</h2></a>
<a class="header" href="print.html#track-performance-metrics" id="track-performance-metrics"><h3>Track Performance Metrics</h3></a>
<ul>
<li>Request latency</li>
<li>Database query time</li>
<li>Memory usage</li>
<li>CPU usage</li>
<li>Error rates</li>
</ul>
<a class="header" href="print.html#use-apm-tools" id="use-apm-tools"><h3>Use APM Tools</h3></a>
<p>Consider integrating:</p>
<ul>
<li>Prometheus for metrics</li>
<li>Grafana for visualization</li>
<li>Sentry for error tracking</li>
</ul>
<a class="header" href="print.html#best-practices-16" id="best-practices-16"><h2>Best Practices</h2></a>
<ol>
<li><strong>Enable view caching</strong> in production</li>
<li><strong>Use connection pooling</strong> for databases</li>
<li><strong>Serve static files</strong> via nginx/CDN</li>
<li><strong>Enable compression</strong> (gzip)</li>
<li><strong>Use Redis</strong> for sessions in multi-instance deployments</li>
<li><strong>Optimize database queries</strong> (indexes, avoid N+1)</li>
<li><strong>Cache frequently accessed data</strong></li>
<li><strong>Profile and benchmark</strong> critical paths</li>
<li><strong>Monitor performance</strong> in production</li>
<li><strong>Use async</strong> for all I/O operations</li>
</ol>
<a class="header" href="print.html#example-optimized-handler" id="example-optimized-handler"><h2>Example: Optimized Handler</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn optimized_handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Use cached data if available
    if let Some(cached) = get_cached_data(&quot;recent_posts&quot;) {
        return ctx.json(cached);
    }
    
    // Optimized query with join
    let posts = Posts::query()
        .join(&quot;users&quot;, &quot;posts.author_id&quot;, &quot;users.id&quot;)
        .where_eq(&quot;published&quot;, true)
        .order_by(&quot;created_at&quot;, OrderDirection::Desc)
        .limit(10)
        .find()?;
    
    // Cache result
    set_cached_data(&quot;recent_posts&quot;.to_string(), json!(posts));
    
    ctx.json(json!(posts))
}
#}</code></pre></pre>
<a class="header" href="print.html#rustf-worker-system" id="rustf-worker-system"><h1>RustF Worker System</h1></a>
<a class="header" href="print.html#table-of-contents-2" id="table-of-contents-2"><h2>Table of Contents</h2></a>
<ul>
<li><a href="print.html#introduction">Introduction</a></li>
<li><a href="print.html#quick-start">Quick Start</a></li>
<li><a href="print.html#core-concepts">Core Concepts</a></li>
<li><a href="print.html#worker-registration">Worker Registration</a></li>
<li><a href="print.html#executing-workers">Executing Workers</a></li>
<li><a href="print.html#worker-context">Worker Context</a></li>
<li><a href="print.html#advanced-features">Advanced Features</a></li>
<li><a href="print.html#real-world-examples">Real-World Examples</a></li>
<li><a href="print.html#best-practices">Best Practices</a></li>
<li><a href="print.html#api-reference">API Reference</a></li>
<li><a href="print.html#troubleshooting">Troubleshooting</a></li>
</ul>
<hr />
<a class="header" href="print.html#introduction" id="introduction"><h2>Introduction</h2></a>
<p>The RustF Worker system provides a lightweight, Total.js-inspired approach to background task execution. Unlike traditional worker queues or job processors, RustF workers are <strong>on-demand tasks</strong> that execute asynchronously and automatically stop when complete.</p>
<a class="header" href="print.html#why-workers" id="why-workers"><h3>Why Workers?</h3></a>
<p>Workers are ideal for:</p>
<ul>
<li><strong>Background Processing</strong>: Long-running tasks that shouldn't block HTTP responses</li>
<li><strong>Async Operations</strong>: Email sending, file uploads, report generation</li>
<li><strong>Scheduled Tasks</strong>: Cleanup, maintenance, data synchronization</li>
<li><strong>Decoupled Logic</strong>: Separating business logic from HTTP request handling</li>
<li><strong>Concurrent Execution</strong>: Running multiple independent tasks simultaneously</li>
</ul>
<a class="header" href="print.html#key-features-4" id="key-features-4"><h3>Key Features</h3></a>
<ul>
<li><strong>ğŸŒ Global API</strong>: Access workers from anywhere using <code>WORKER::</code></li>
<li><strong>âš¡ On-Demand</strong>: Workers execute when called, no persistent processes</li>
<li><strong>â±ï¸ Timeout Support</strong>: Automatic cancellation after specified duration</li>
<li><strong>ğŸ“¨ Message Streaming</strong>: Real-time communication between worker and caller</li>
<li><strong>ğŸ“Š Statistics</strong>: Automatic tracking of runs, errors, and execution times</li>
<li><strong>ğŸ”„ Concurrent</strong>: Multiple workers can run simultaneously</li>
<li><strong>ğŸ¯ Type-Safe</strong>: Full Rust type safety with async/await</li>
</ul>
<a class="header" href="print.html#design-philosophy" id="design-philosophy"><h3>Design Philosophy</h3></a>
<p>RustF workers follow Total.js conventions:</p>
<ul>
<li><strong>Registration-based</strong>: Define workers once, execute many times</li>
<li><strong>Context-rich</strong>: Workers receive a <code>WorkerContext</code> with configuration and utilities</li>
<li><strong>Fire-and-forget or await</strong>: Choose between async execution or waiting for results</li>
<li><strong>Stateless</strong>: Each execution is independent with isolated state</li>
</ul>
<hr />
<a class="header" href="print.html#quick-start-4" id="quick-start-4"><h2>Quick Start</h2></a>
<a class="header" href="print.html#1-create-worker-directory" id="1-create-worker-directory"><h3>1. Create Worker Directory</h3></a>
<p>Create the required <code>src/workers/</code> directory:</p>
<pre><code class="language-bash">mkdir -p src/workers
</code></pre>
<a class="header" href="print.html#2-create-your-first-worker" id="2-create-your-first-worker"><h3>2. Create Your First Worker</h3></a>
<p>Create a worker file in <code>src/workers/</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/workers/email.rs
use rustf::prelude::*;
use rustf::workers::WORKER;
use std::time::Duration;

pub async fn install() -&gt; Result&lt;()&gt; {
    WORKER::register(&quot;send-email&quot;, |ctx| async move {
        ctx.info(&quot;Sending email...&quot;);

        // Simulate email sending
        tokio::time::sleep(Duration::from_secs(2)).await;

        ctx.info(&quot;Email sent successfully!&quot;);
        Ok(())
    }).await?;

    Ok(())
}
#}</code></pre></pre>
<a class="header" href="print.html#3-enable-auto-discovery" id="3-enable-auto-discovery"><h3>3. Enable Auto-Discovery</h3></a>
<p>Use <code>#[rustf::auto_discover]</code> in your main function:</p>
<pre><pre class="playpen"><code class="language-rust">// src/main.rs
use rustf::prelude::*;

#[rustf::auto_discover]  // â† Automatically discovers workers in src/workers/
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    env_logger::init();

    let app = RustF::new()
        .auto_load()  // â† Loads all discovered workers
        .run(&quot;127.0.0.1:3000&quot;)
        .await?;

    Ok(())
}
</code></pre></pre>
<a class="header" href="print.html#4-execute-the-worker" id="4-execute-the-worker"><h3>4. Execute the Worker</h3></a>
<p>Call the worker from any controller:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::workers::WORKER;

async fn send_welcome_email(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Execute worker and wait for completion
    WORKER::run(&quot;send-email&quot;, None).await?;

    ctx.json(json!({
        &quot;status&quot;: &quot;Email sent&quot;
    }))
}
#}</code></pre></pre>
<p><strong>That's it!</strong> The framework automatically discovers and registers all workers in <code>src/workers/</code>.</p>
<hr />
<a class="header" href="print.html#core-concepts" id="core-concepts"><h2>Core Concepts</h2></a>
<a class="header" href="print.html#worker-lifecycle" id="worker-lifecycle"><h3>Worker Lifecycle</h3></a>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Registrationâ”‚  â† Define worker once during startup
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Idle      â”‚  â† Worker definition exists, waiting to be called
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼ WORKER::call()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Running    â”‚  â† Worker executing asynchronously
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Completed   â”‚  â† Worker finishes, stats recorded
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p><strong>Important</strong>: RustF workers are <strong>not persistent processes</strong>. Each execution:</p>
<ol>
<li>Starts fresh with new context</li>
<li>Runs to completion</li>
<li>Automatically stops and cleans up</li>
<li>Records statistics</li>
</ol>
<a class="header" href="print.html#workercontext" id="workercontext"><h3>WorkerContext</h3></a>
<p>Every worker receives a <code>WorkerContext</code> providing:</p>
<ul>
<li><strong>Identity</strong>: Worker name and run ID</li>
<li><strong>Configuration</strong>: Access to app config</li>
<li><strong>Payload</strong>: Input data passed during execution</li>
<li><strong>Logging</strong>: Structured logging with worker identification</li>
<li><strong>State</strong>: Per-execution state management</li>
<li><strong>Messaging</strong>: Emit messages to caller</li>
<li><strong>Environment</strong>: Development vs. production detection</li>
<li><strong>Utilities</strong>: Sleep, timing, etc.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;example&quot;, |ctx| async move {
    ctx.info(&amp;format!(&quot;Worker: {}, Run: {}&quot;,
        ctx.worker_name(),
        ctx.run_id()
    ));

    if ctx.is_development() {
        ctx.debug(&quot;Running in development mode&quot;);
    }

    // Access payload
    if let Some(data) = ctx.payload() {
        ctx.info(&amp;format!(&quot;Received: {}&quot;, data));
    }

    Ok(())
}).await?;
#}</code></pre></pre>
<a class="header" href="print.html#workerhandle" id="workerhandle"><h3>WorkerHandle</h3></a>
<p>When calling a worker with <code>WORKER::call()</code>, you receive a <code>WorkerHandle</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut handle = WORKER::call(&quot;worker-name&quot;, None, None).await?;

// Get worker info
let run_id = handle.id();
let name = handle.worker_name();

// Receive messages from worker
while let Some(message) = handle.recv().await {
    println!(&quot;Worker sent: {}&quot;, message);
}

// Wait for completion
handle.await_result().await?;

// Or cancel if needed
handle.cancel().await?;
#}</code></pre></pre>
<a class="header" href="print.html#worker-statistics" id="worker-statistics"><h3>Worker Statistics</h3></a>
<p>The system automatically tracks statistics for each worker:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Clone, Serialize)]
pub struct WorkerStats {
    pub runs: u64,              // Total executions
    pub errors: u64,            // Failed executions
    pub last_run_ms: Option&lt;u64&gt;, // Duration of last run
    pub total_runtime_ms: u64,  // Cumulative runtime
}

// Access statistics
let stats = WORKER::stats(&quot;send-email&quot;).await;
if let Some(stats) = stats {
    println!(&quot;Runs: {}, Errors: {}, Avg: {}ms&quot;,
        stats.runs,
        stats.errors,
        stats.total_runtime_ms / stats.runs
    );
}
#}</code></pre></pre>
<hr />
<a class="header" href="print.html#worker-registration" id="worker-registration"><h2>Worker Registration</h2></a>
<a class="header" href="print.html#directory-structure-required" id="directory-structure-required"><h3>Directory Structure (Required)</h3></a>
<p><strong>All workers MUST be placed in the <code>src/workers/</code> directory.</strong> The framework uses compile-time auto-discovery to find and register workers.</p>
<pre><code>your-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ workers/           # âš ï¸ Required directory
â”‚   â”‚   â”œâ”€â”€ email.rs       # Worker file
â”‚   â”‚   â”œâ”€â”€ cleanup.rs     # Worker file
â”‚   â”‚   â””â”€â”€ reports.rs     # Worker file
â”‚   â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ models/
â”‚   â””â”€â”€ main.rs
â””â”€â”€ Cargo.toml
</code></pre>
<a class="header" href="print.html#worker-file-structure" id="worker-file-structure"><h3>Worker File Structure</h3></a>
<p>Each worker file in <code>src/workers/</code> must have an <code>install()</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/workers/email.rs
use rustf::prelude::*;
use rustf::workers::WORKER;
use std::time::Duration;

/// Install email worker - this function is called automatically by the framework
pub async fn install() -&gt; Result&lt;()&gt; {
    WORKER::register(&quot;send-email&quot;, |ctx| async move {
        let payload = ctx.payload()
            .ok_or_else(|| Error::validation(&quot;Email worker requires payload&quot;))?;

        let to = payload[&quot;to&quot;].as_str()
            .ok_or_else(|| Error::validation(&quot;Missing 'to' field&quot;))?;

        ctx.info(&amp;format!(&quot;Sending email to: {}&quot;, to));

        // Email sending logic...
        tokio::time::sleep(Duration::from_secs(1)).await;

        ctx.info(&quot;Email sent successfully&quot;);
        Ok(())
    }).await?;

    Ok(())
}
#}</code></pre></pre>
<a class="header" href="print.html#auto-discovery-methods" id="auto-discovery-methods"><h3>Auto-Discovery Methods</h3></a>
<p>RustF provides three ways to enable worker auto-discovery:</p>
<a class="header" href="print.html#method-1-rustfauto_discover-recommended" id="method-1-rustfauto_discover-recommended"><h4>Method 1: <code>#[rustf::auto_discover]</code> (Recommended)</h4></a>
<p>The simplest approach - automatically discovers all workers:</p>
<pre><pre class="playpen"><code class="language-rust">// src/main.rs
use rustf::prelude::*;

#[rustf::auto_discover]  // â† Discovers src/workers/ automatically
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::with_args()?.auto_load();
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#method-2-auto_load-explicit" id="method-2-auto_load-explicit"><h4>Method 2: <code>.auto_load()</code> (Explicit)</h4></a>
<p>Manually enable auto-loading with full control:</p>
<pre><pre class="playpen"><code class="language-rust">// src/main.rs
use rustf::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::new()
        .with_workers()
        .auto_load();  // â† Loads workers from src/workers/

    app.run(&quot;127.0.0.1:3000&quot;).await
}
</code></pre></pre>
<a class="header" href="print.html#method-3-auto_workers-macro-advanced" id="method-3-auto_workers-macro-advanced"><h4>Method 3: <code>auto_workers!()</code> Macro (Advanced)</h4></a>
<p>Direct macro usage for custom setups:</p>
<pre><pre class="playpen"><code class="language-rust">// src/main.rs
use rustf::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::new()
        .with_workers()
        .workers_from(auto_workers!())  // â† Scans src/workers/ at compile time
        .run(&quot;127.0.0.1:3000&quot;)
        .await?;

    Ok(())
}
</code></pre></pre>
<a class="header" href="print.html#multiple-workers-per-file" id="multiple-workers-per-file"><h3>Multiple Workers Per File</h3></a>
<p>You can register multiple workers in a single file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/workers/notifications.rs
use rustf::prelude::*;
use rustf::workers::WORKER;

pub async fn install() -&gt; Result&lt;()&gt; {
    // Email notification worker
    WORKER::register(&quot;notify-email&quot;, |ctx| async move {
        ctx.info(&quot;Sending email notification&quot;);
        // Implementation...
        Ok(())
    }).await?;

    // SMS notification worker
    WORKER::register(&quot;notify-sms&quot;, |ctx| async move {
        ctx.info(&quot;Sending SMS notification&quot;);
        // Implementation...
        Ok(())
    }).await?;

    // Push notification worker
    WORKER::register(&quot;notify-push&quot;, |ctx| async move {
        ctx.info(&quot;Sending push notification&quot;);
        // Implementation...
        Ok(())
    }).await?;

    Ok(())
}
#}</code></pre></pre>
<a class="header" href="print.html#nested-directory-organization" id="nested-directory-organization"><h3>Nested Directory Organization</h3></a>
<p>Workers can be organized in subdirectories:</p>
<pre><code>src/workers/
â”œâ”€â”€ notifications/
â”‚   â”œâ”€â”€ email.rs
â”‚   â”œâ”€â”€ sms.rs
â”‚   â””â”€â”€ push.rs
â”œâ”€â”€ reports/
â”‚   â”œâ”€â”€ daily.rs
â”‚   â””â”€â”€ monthly.rs
â””â”€â”€ maintenance/
    â”œâ”€â”€ cleanup.rs
    â””â”€â”€ backup.rs
</code></pre>
<p>The framework automatically discovers workers in subdirectories up to 3 levels deep.</p>
<a class="header" href="print.html#skipping-files" id="skipping-files"><h3>Skipping Files</h3></a>
<p>Files are automatically skipped if they:</p>
<ul>
<li>Are named <code>mod.rs</code></li>
<li>End with <code>.inc.rs</code></li>
<li>Start with underscore (<code>_helper.rs</code>)</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/workers/mod.rs - âœ… Skipped automatically
// src/workers/helpers.inc.rs - âœ… Skipped automatically
// src/workers/_internal.rs - âœ… Skipped automatically
// src/workers/email.rs - âŒ Discovered and loaded
#}</code></pre></pre>
<a class="header" href="print.html#worker-registration-best-practices" id="worker-registration-best-practices"><h3>Worker Registration Best Practices</h3></a>
<ol>
<li><strong>Use <code>src/workers/</code> directory</strong>: This is mandatory - workers outside this directory won't be discovered</li>
<li><strong>One <code>install()</code> per file</strong>: Each worker file must export a public async <code>install()</code> function</li>
<li><strong>Descriptive file names</strong>: Use clear names like <code>email.rs</code>, <code>cleanup.rs</code>, <code>reports.rs</code></li>
<li><strong>Descriptive worker names</strong>: Use kebab-case for worker names (<code>send-email</code>, <code>generate-report</code>)</li>
<li><strong>One responsibility per worker</strong>: Each worker should do one thing well</li>
<li><strong>Validate payloads early</strong>: Always validate input data at the start of the worker</li>
<li><strong>Handle errors properly</strong>: Use <code>Result&lt;()&gt;</code> and return meaningful errors</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Clear name, validated input, error handling
WORKER::register(&quot;send-welcome-email&quot;, |ctx| async move {
    let payload = ctx.payload()
        .ok_or_else(|| Error::validation(&quot;Payload required&quot;))?;

    let email = payload[&quot;email&quot;].as_str()
        .ok_or_else(|| Error::validation(&quot;Email address required&quot;))?;

    // Validate email format
    if !email.contains('@') {
        return Err(Error::validation(&quot;Invalid email format&quot;));
    }

    send_email(email).await?;
    Ok(())
}).await?;

// âŒ Bad: Generic name, no validation, panics
WORKER::register(&quot;worker1&quot;, |ctx| async move {
    let email = ctx.payload().unwrap()[&quot;email&quot;].as_str().unwrap();
    send_email(email).await.unwrap();
    Ok(())
}).await?;
#}</code></pre></pre>
<hr />
<a class="header" href="print.html#executing-workers" id="executing-workers"><h2>Executing Workers</h2></a>
<a class="header" href="print.html#method-1-call-and-await-most-common" id="method-1-call-and-await-most-common"><h3>Method 1: Call and Await (Most Common)</h3></a>
<p>Execute a worker and wait for completion:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Simple execution
WORKER::run(&quot;send-email&quot;, None).await?;

// With payload
let payload = json!({
    &quot;to&quot;: &quot;user@example.com&quot;,
    &quot;subject&quot;: &quot;Welcome!&quot;
});
WORKER::run(&quot;send-email&quot;, Some(payload)).await?;
#}</code></pre></pre>
<a class="header" href="print.html#method-2-call-with-handle-advanced-control" id="method-2-call-with-handle-advanced-control"><h3>Method 2: Call with Handle (Advanced Control)</h3></a>
<p>Get a handle for message streaming and control:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut handle = WORKER::call(&quot;worker-name&quot;, None, Some(payload)).await?;

// Receive messages while worker runs
while let Some(message) = handle.recv().await {
    println!(&quot;Progress: {}&quot;, message);
}

// Wait for final result
handle.await_result().await?;
#}</code></pre></pre>
<a class="header" href="print.html#method-3-fire-and-forget" id="method-3-fire-and-forget"><h3>Method 3: Fire and Forget</h3></a>
<p>Start a worker without waiting:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
tokio::spawn(async move {
    let _ = WORKER::run(&quot;cleanup&quot;, None).await;
});
#}</code></pre></pre>
<a class="header" href="print.html#timeout-support" id="timeout-support"><h3>Timeout Support</h3></a>
<p>Set a maximum execution time:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::time::Duration;

// Worker will be cancelled if it exceeds 5 seconds
let handle = WORKER::call(
    &quot;slow-worker&quot;,
    Some(Duration::from_secs(5)),  // Timeout
    Some(payload)
).await?;

match handle.await_result().await {
    Ok(_) =&gt; println!(&quot;Completed successfully&quot;),
    Err(e) =&gt; println!(&quot;Timeout or error: {}&quot;, e),
}
#}</code></pre></pre>
<a class="header" href="print.html#passing-payloads" id="passing-payloads"><h3>Passing Payloads</h3></a>
<p>Workers accept JSON payloads for input data:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Calling code
let payload = json!({
    &quot;user_id&quot;: 123,
    &quot;action&quot;: &quot;process_upload&quot;,
    &quot;file_path&quot;: &quot;/tmp/upload.pdf&quot;
});
WORKER::run(&quot;process-file&quot;, Some(payload)).await?;

// Worker code
WORKER::register(&quot;process-file&quot;, |ctx| async move {
    let payload = ctx.payload().ok_or_else(||
        Error::validation(&quot;Payload required&quot;)
    )?;

    let user_id = payload[&quot;user_id&quot;].as_i64().unwrap();
    let file_path = payload[&quot;file_path&quot;].as_str().unwrap();

    ctx.info(&amp;format!(&quot;Processing file for user {}&quot;, user_id));
    // Process file...

    Ok(())
}).await?;
#}</code></pre></pre>
<a class="header" href="print.html#concurrent-execution" id="concurrent-execution"><h3>Concurrent Execution</h3></a>
<p>Run multiple workers simultaneously:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use futures::future::join_all;

async fn process_batch(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let items = vec![
        json!({&quot;id&quot;: 1}),
        json!({&quot;id&quot;: 2}),
        json!({&quot;id&quot;: 3}),
    ];

    // Launch all workers concurrently
    let futures: Vec&lt;_&gt; = items.into_iter()
        .map(|item| WORKER::call(&quot;process-item&quot;, None, Some(item)))
        .collect();

    let handles = join_all(futures).await;

    // Wait for all to complete
    for handle in handles {
        handle?.await_result().await?;
    }

    ctx.json(json!({&quot;status&quot;: &quot;All items processed&quot;}))
}
#}</code></pre></pre>
<hr />
<a class="header" href="print.html#worker-context" id="worker-context"><h2>Worker Context</h2></a>
<p>The <code>WorkerContext</code> provides rich functionality for worker execution.</p>
<a class="header" href="print.html#identity-and-metadata" id="identity-and-metadata"><h3>Identity and Metadata</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;example&quot;, |ctx| async move {
    // Unique identifier for this execution
    let run_id = ctx.run_id(); // &quot;550e8400-e29b-41d4-a716-446655440000&quot;

    // Worker definition name
    let name = ctx.worker_name(); // &quot;example&quot;

    ctx.info(&amp;format!(&quot;Execution {} of {}&quot;, run_id, name));
    Ok(())
}).await?;
#}</code></pre></pre>
<a class="header" href="print.html#logging" id="logging"><h3>Logging</h3></a>
<p>Workers have structured logging with automatic identification:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;logger-demo&quot;, |ctx| async move {
    ctx.info(&quot;Informational message&quot;);
    ctx.warn(&quot;Warning message&quot;);
    ctx.error(&quot;Error message&quot;);
    ctx.debug(&quot;Debug message (only in development)&quot;);

    // Generic logging with custom level
    ctx.log(log::Level::Info, &quot;Custom log&quot;);

    Ok(())
}).await?;

// Output:
// [Worker:logger-demo run:550e8400...] Informational message
// [Worker:logger-demo run:550e8400...] Warning message
#}</code></pre></pre>
<a class="header" href="print.html#environment-detection-1" id="environment-detection-1"><h3>Environment Detection</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;env-aware&quot;, |ctx| async move {
    if ctx.is_development() {
        ctx.info(&quot;Running in development - verbose logging enabled&quot;);
        // Use test APIs, skip external services, etc.
    }

    if ctx.is_production() {
        ctx.info(&quot;Running in production - using live services&quot;);
        // Use production APIs, send real emails, etc.
    }

    Ok(())
}).await?;
#}</code></pre></pre>
<p>Environment is determined from <code>RUSTF_ENV</code> or <code>NODE_ENV</code> environment variables.</p>
<a class="header" href="print.html#configuration-access-1" id="configuration-access-1"><h3>Configuration Access</h3></a>
<p>Access application configuration from workers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;config-example&quot;, |ctx| async move {
    let config = ctx.config();

    // Use configuration values
    let base_url = config.get::&lt;String&gt;(&quot;api.base_url&quot;)
        .unwrap_or_else(|| &quot;http://localhost&quot;.to_string());

    ctx.info(&amp;format!(&quot;Using API: {}&quot;, base_url));
    Ok(())
}).await?;
#}</code></pre></pre>
<a class="header" href="print.html#state-management" id="state-management"><h3>State Management</h3></a>
<p>Each worker execution has isolated state:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;stateful&quot;, |ctx| async move {
    // Set state values
    ctx.set_state(&quot;progress&quot;, json!(0)).await?;
    ctx.set_state(&quot;items_processed&quot;, json!([])).await?;

    for i in 1..=5 {
        // Update state
        ctx.set_state(&quot;progress&quot;, json!(i * 20)).await?;

        // Read state
        if let Some(progress) = ctx.get_state(&quot;progress&quot;).await {
            ctx.info(&amp;format!(&quot;Progress: {}%&quot;, progress));
        }

        tokio::time::sleep(Duration::from_millis(500)).await;
    }

    // Clear all state
    ctx.clear_state().await?;
    Ok(())
}).await?;
#}</code></pre></pre>
<p><strong>Note</strong>: State is per-execution. Different runs of the same worker have independent state.</p>
<a class="header" href="print.html#message-emission" id="message-emission"><h3>Message Emission</h3></a>
<p>Send real-time messages to the caller:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Worker code
WORKER::register(&quot;progress-reporter&quot;, |ctx| async move {
    for i in 1..=10 {
        // Emit progress updates
        ctx.emit(json!({
            &quot;progress&quot;: i * 10,
            &quot;message&quot;: format!(&quot;Processing item {}/10&quot;, i)
        }))?;

        tokio::time::sleep(Duration::from_millis(200)).await;
    }

    ctx.emit(json!({&quot;status&quot;: &quot;complete&quot;}))?;
    Ok(())
}).await?;

// Calling code
let mut handle = WORKER::call(&quot;progress-reporter&quot;, None, None).await?;

// Receive progress updates
while let Some(message) = handle.recv().await {
    let progress = message[&quot;progress&quot;].as_i64().unwrap_or(0);
    println!(&quot;Progress: {}%&quot;, progress);
}

handle.await_result().await?;
#}</code></pre></pre>
<a class="header" href="print.html#utilities" id="utilities"><h3>Utilities</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;utilities&quot;, |ctx| async move {
    // Sleep/delay
    ctx.sleep(Duration::from_secs(1)).await;

    // Access payload
    if let Some(payload) = ctx.payload() {
        ctx.info(&amp;format!(&quot;Received: {}&quot;, payload));
    }

    Ok(())
}).await?;
#}</code></pre></pre>
<hr />
<a class="header" href="print.html#advanced-features-2" id="advanced-features-2"><h2>Advanced Features</h2></a>
<a class="header" href="print.html#cancellation" id="cancellation"><h3>Cancellation</h3></a>
<p>Cancel running workers using the handle:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn cancelable_operation(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Start long-running worker
    let handle = WORKER::call(&quot;slow-worker&quot;, None, None).await?;
    let run_id = handle.id().to_string();

    // Start cancellation timer
    tokio::spawn(async move {
        tokio::time::sleep(Duration::from_secs(3)).await;

        // Cancel after 3 seconds
        if let Err(e) = WORKER::cancel(&amp;run_id).await {
            eprintln!(&quot;Failed to cancel: {}&quot;, e);
        }
    });

    // Try to await result
    match handle.await_result().await {
        Ok(_) =&gt; ctx.json(json!({&quot;status&quot;: &quot;completed&quot;})),
        Err(_) =&gt; ctx.json(json!({&quot;status&quot;: &quot;cancelled&quot;})),
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#listing-workers" id="listing-workers"><h3>Listing Workers</h3></a>
<p>Query registered and running workers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn worker_dashboard(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // List all registered worker definitions
    let definitions = WORKER::definitions().await?;

    // List all currently running worker run IDs
    let running = WORKER::running().await?;

    // List runs for a specific worker
    let email_runs = WORKER::running_for(&quot;send-email&quot;).await?;

    ctx.json(json!({
        &quot;definitions&quot;: definitions,
        &quot;running_count&quot;: running.len(),
        &quot;email_worker_runs&quot;: email_runs.len()
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#statistics-and-monitoring" id="statistics-and-monitoring"><h3>Statistics and Monitoring</h3></a>
<p>Track worker performance:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn worker_stats(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let definitions = WORKER::definitions().await?;
    let mut stats_map = serde_json::Map::new();

    for name in definitions {
        if let Some(stats) = WORKER::stats(&amp;name).await {
            let avg_ms = if stats.runs &gt; 0 {
                stats.total_runtime_ms / stats.runs
            } else {
                0
            };

            stats_map.insert(name, json!({
                &quot;total_runs&quot;: stats.runs,
                &quot;errors&quot;: stats.errors,
                &quot;success_rate&quot;: if stats.runs &gt; 0 {
                    (stats.runs - stats.errors) as f64 / stats.runs as f64 * 100.0
                } else {
                    0.0
                },
                &quot;average_duration_ms&quot;: avg_ms,
                &quot;last_run_ms&quot;: stats.last_run_ms
            }));
        }
    }

    ctx.json(json!(stats_map))
}
#}</code></pre></pre>
<a class="header" href="print.html#graceful-shutdown" id="graceful-shutdown"><h3>Graceful Shutdown</h3></a>
<p>Workers automatically shutdown when the application stops:</p>
<pre><pre class="playpen"><code class="language-rust">#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::new()
        .with_workers()
        .workers_from(|_manager| async move {
            WORKER::register(&quot;long-task&quot;, |ctx| async move {
                ctx.info(&quot;Long task started&quot;);
                tokio::time::sleep(Duration::from_secs(60)).await;
                ctx.info(&quot;Long task completed&quot;);
                Ok(())
            }).await?;
            Ok(())
        })
        .run(&quot;127.0.0.1:3000&quot;)
        .await?;

    // When app shuts down (Ctrl+C, etc.):
    // 1. All running workers are cancelled
    // 2. No new workers can be started
    // 3. Resources are cleaned up

    Ok(())
}
</code></pre></pre>
<a class="header" href="print.html#error-handling-patterns" id="error-handling-patterns"><h3>Error Handling Patterns</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;robust-worker&quot;, |ctx| async move {
    // Validate input early
    let payload = ctx.payload()
        .ok_or_else(|| Error::validation(&quot;Payload required&quot;))?;

    let user_id = payload[&quot;user_id&quot;].as_i64()
        .ok_or_else(|| Error::validation(&quot;user_id is required&quot;))?;

    // Use Result propagation
    let user = fetch_user(user_id).await?;

    // Handle specific errors
    match process_user(&amp;user).await {
        Ok(_) =&gt; {
            ctx.info(&quot;User processed successfully&quot;);
            Ok(())
        }
        Err(e) if e.is_validation() =&gt; {
            ctx.warn(&amp;format!(&quot;Validation failed: {}&quot;, e));
            Err(e)
        }
        Err(e) =&gt; {
            ctx.error(&amp;format!(&quot;Processing failed: {}&quot;, e));
            Err(e)
        }
    }
}).await?;
#}</code></pre></pre>
<hr />
<a class="header" href="print.html#real-world-examples" id="real-world-examples"><h2>Real-World Examples</h2></a>
<a class="header" href="print.html#example-1-email-sending-worker" id="example-1-email-sending-worker"><h3>Example 1: Email Sending Worker</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;
use rustf::workers::WORKER;

pub async fn install() -&gt; Result&lt;()&gt; {
    WORKER::register(&quot;send-email&quot;, |ctx| async move {
        let payload = ctx.payload()
            .ok_or_else(|| Error::validation(&quot;Email payload required&quot;))?;

        let to = payload[&quot;to&quot;].as_str()
            .ok_or_else(|| Error::validation(&quot;'to' address required&quot;))?;
        let subject = payload[&quot;subject&quot;].as_str()
            .unwrap_or(&quot;No Subject&quot;);
        let body = payload[&quot;body&quot;].as_str()
            .unwrap_or(&quot;&quot;);

        ctx.info(&amp;format!(&quot;Sending email to: {}&quot;, to));

        // Simulate email sending
        if ctx.is_development() {
            ctx.info(&amp;format!(&quot;ğŸ“§ DEV MODE - Email to {} with subject: {}&quot;, to, subject));
            tokio::time::sleep(Duration::from_millis(100)).await;
        } else {
            // Production: use real SMTP service
            // send_smtp_email(to, subject, body).await?;
            tokio::time::sleep(Duration::from_secs(2)).await;
        }

        ctx.emit(json!({
            &quot;status&quot;: &quot;sent&quot;,
            &quot;to&quot;: to,
            &quot;timestamp&quot;: chrono::Utc::now().to_rfc3339()
        }))?;

        ctx.info(&quot;âœ… Email sent successfully&quot;);
        Ok(())
    }).await?;

    Ok(())
}

// Usage from controller
async fn register_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let body = ctx.full_body();
    let email = body[&quot;email&quot;].as_str().unwrap();

    // Create user...

    // Send welcome email in background
    WORKER::run(&quot;send-email&quot;, Some(json!({
        &quot;to&quot;: email,
        &quot;subject&quot;: &quot;Welcome to Our App!&quot;,
        &quot;body&quot;: &quot;Thanks for registering...&quot;
    }))).await?;

    ctx.json(json!({&quot;status&quot;: &quot;User registered&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#example-2-file-processing-worker" id="example-2-file-processing-worker"><h3>Example 2: File Processing Worker</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;process-upload&quot;, |ctx| async move {
    let payload = ctx.payload()
        .ok_or_else(|| Error::validation(&quot;Payload required&quot;))?;

    let file_path = payload[&quot;file_path&quot;].as_str()
        .ok_or_else(|| Error::validation(&quot;file_path required&quot;))?;

    ctx.info(&amp;format!(&quot;Processing file: {}&quot;, file_path));

    // Step 1: Validate file
    ctx.emit(json!({&quot;step&quot;: &quot;validate&quot;, &quot;progress&quot;: 25}))?;
    validate_file(file_path).await?;
    tokio::time::sleep(Duration::from_secs(1)).await;

    // Step 2: Process file
    ctx.emit(json!({&quot;step&quot;: &quot;process&quot;, &quot;progress&quot;: 50}))?;
    let result = process_file(file_path).await?;
    tokio::time::sleep(Duration::from_secs(2)).await;

    // Step 3: Generate thumbnail
    ctx.emit(json!({&quot;step&quot;: &quot;thumbnail&quot;, &quot;progress&quot;: 75}))?;
    generate_thumbnail(file_path).await?;
    tokio::time::sleep(Duration::from_secs(1)).await;

    // Step 4: Save to database
    ctx.emit(json!({&quot;step&quot;: &quot;save&quot;, &quot;progress&quot;: 100}))?;
    save_to_database(&amp;result).await?;

    ctx.info(&quot;âœ… File processing complete&quot;);
    Ok(())
}).await?;

// Usage with progress tracking
async fn upload_file(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let file_path = &quot;/tmp/uploads/file.pdf&quot;;

    let mut handle = WORKER::call(
        &quot;process-upload&quot;,
        Some(Duration::from_secs(30)),
        Some(json!({&quot;file_path&quot;: file_path}))
    ).await?;

    // Stream progress to client
    while let Some(progress) = handle.recv().await {
        log::info!(&quot;Progress: {:?}&quot;, progress);
        // Could send SSE to client here
    }

    handle.await_result().await?;
    ctx.json(json!({&quot;status&quot;: &quot;Processing complete&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#example-3-cleanup-worker" id="example-3-cleanup-worker"><h3>Example 3: Cleanup Worker</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;cleanup-temp-files&quot;, |ctx| async move {
    ctx.info(&quot;ğŸ§¹ Starting cleanup task&quot;);

    let temp_dir = &quot;/tmp/app_uploads&quot;;
    let cutoff = chrono::Utc::now() - chrono::Duration::hours(24);

    let mut removed_count = 0;

    // Scan directory
    let entries = tokio::fs::read_dir(temp_dir).await?;
    // Process each file...

    ctx.emit(json!({
        &quot;files_removed&quot;: removed_count,
        &quot;directory&quot;: temp_dir
    }))?;

    ctx.info(&amp;format!(&quot;âœ… Cleanup complete: {} files removed&quot;, removed_count));
    Ok(())
}).await?;

// Schedule via cron or event system
app.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    // Run cleanup every hour
    tokio::spawn(async {
        loop {
            tokio::time::sleep(Duration::from_secs(3600)).await;
            let _ = WORKER::run(&quot;cleanup-temp-files&quot;, None).await;
        }
    });
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#example-4-report-generation-worker" id="example-4-report-generation-worker"><h3>Example 4: Report Generation Worker</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;generate-report&quot;, |ctx| async move {
    let payload = ctx.payload()
        .ok_or_else(|| Error::validation(&quot;Report parameters required&quot;))?;

    let report_type = payload[&quot;type&quot;].as_str().unwrap_or(&quot;monthly&quot;);
    let user_id = payload[&quot;user_id&quot;].as_i64().unwrap();

    ctx.info(&amp;format!(&quot;Generating {} report for user {}&quot;, report_type, user_id));

    // Fetch data
    ctx.emit(json!({&quot;stage&quot;: &quot;fetching_data&quot;, &quot;progress&quot;: 10}))?;
    let data = fetch_report_data(user_id, report_type).await?;

    // Process data
    ctx.emit(json!({&quot;stage&quot;: &quot;processing&quot;, &quot;progress&quot;: 40}))?;
    let processed = process_report_data(&amp;data).await?;

    // Generate PDF
    ctx.emit(json!({&quot;stage&quot;: &quot;generating_pdf&quot;, &quot;progress&quot;: 70}))?;
    let pdf_path = generate_pdf_report(&amp;processed).await?;

    // Upload to storage
    ctx.emit(json!({&quot;stage&quot;: &quot;uploading&quot;, &quot;progress&quot;: 90}))?;
    let url = upload_to_storage(&amp;pdf_path).await?;

    ctx.emit(json!({
        &quot;stage&quot;: &quot;complete&quot;,
        &quot;progress&quot;: 100,
        &quot;url&quot;: url
    }))?;

    ctx.info(&amp;format!(&quot;âœ… Report generated: {}&quot;, url));
    Ok(())
}).await?;
#}</code></pre></pre>
<a class="header" href="print.html#example-5-batch-processing-worker" id="example-5-batch-processing-worker"><h3>Example 5: Batch Processing Worker</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;batch-processor&quot;, |ctx| async move {
    let payload = ctx.payload()
        .ok_or_else(|| Error::validation(&quot;Batch items required&quot;))?;

    let items = payload[&quot;items&quot;].as_array()
        .ok_or_else(|| Error::validation(&quot;items must be an array&quot;))?;

    let total = items.len();
    ctx.info(&amp;format!(&quot;Processing {} items&quot;, total));

    for (index, item) in items.iter().enumerate() {
        let progress = ((index + 1) as f64 / total as f64 * 100.0) as u64;

        ctx.emit(json!({
            &quot;current&quot;: index + 1,
            &quot;total&quot;: total,
            &quot;progress&quot;: progress,
            &quot;item&quot;: item
        }))?;

        // Process item
        process_item(item).await?;

        // Small delay to avoid overwhelming external APIs
        tokio::time::sleep(Duration::from_millis(100)).await;
    }

    ctx.info(&amp;format!(&quot;âœ… Processed {} items&quot;, total));
    Ok(())
}).await?;
#}</code></pre></pre>
<hr />
<a class="header" href="print.html#best-practices-17" id="best-practices-17"><h2>Best Practices</h2></a>
<a class="header" href="print.html#when-to-use-workers" id="when-to-use-workers"><h3>When to Use Workers</h3></a>
<p><strong>âœ… Good Use Cases:</strong></p>
<ul>
<li><strong>Long-running tasks</strong>: Anything taking &gt;100ms that blocks the response</li>
<li><strong>External API calls</strong>: Third-party services, webhooks, notifications</li>
<li><strong>File operations</strong>: Uploads, conversions, compression</li>
<li><strong>Email/SMS sending</strong>: Any messaging operations</li>
<li><strong>Report generation</strong>: PDFs, exports, analytics</li>
<li><strong>Data synchronization</strong>: Batch updates, imports</li>
<li><strong>Cleanup tasks</strong>: Maintenance, garbage collection</li>
</ul>
<p><strong>âŒ Not Suitable For:</strong></p>
<ul>
<li><strong>Quick database queries</strong>: Just use models directly</li>
<li><strong>Simple calculations</strong>: Pure functions don't need workers</li>
<li><strong>Request validation</strong>: Should happen synchronously</li>
<li><strong>Response formatting</strong>: Part of controller logic</li>
<li><strong>Configuration loading</strong>: Do at startup, not in workers</li>
</ul>
<a class="header" href="print.html#error-handling-6" id="error-handling-6"><h3>Error Handling</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Specific error types, proper propagation
WORKER::register(&quot;good-errors&quot;, |ctx| async move {
    let payload = ctx.payload()
        .ok_or_else(|| Error::validation(&quot;Payload required&quot;))?;

    match external_api_call().await {
        Ok(result) =&gt; {
            ctx.info(&quot;API call succeeded&quot;);
            Ok(())
        }
        Err(e) if e.is_timeout() =&gt; {
            ctx.warn(&quot;API timeout, will retry later&quot;);
            Err(Error::timeout(&quot;External API timeout&quot;))
        }
        Err(e) =&gt; {
            ctx.error(&amp;format!(&quot;Unexpected error: {}&quot;, e));
            Err(e)
        }
    }
}).await?;

// âŒ Bad: Swallowing errors, panics
WORKER::register(&quot;bad-errors&quot;, |ctx| async move {
    let data = ctx.payload().unwrap(); // Panic!
    external_api_call().await.ok(); // Error ignored!
    Ok(())
}).await?;
#}</code></pre></pre>
<a class="header" href="print.html#resource-management" id="resource-management"><h3>Resource Management</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Cleanup resources, bounded operations
WORKER::register(&quot;resource-safe&quot;, |ctx| async move {
    let temp_file = create_temp_file().await?;

    let result = process_file(&amp;temp_file).await;

    // Always cleanup
    tokio::fs::remove_file(&amp;temp_file).await?;

    result
}).await?;

// âŒ Bad: Resource leaks, unbounded operations
WORKER::register(&quot;resource-leak&quot;, |ctx| async move {
    let file = create_temp_file().await?;
    process_file(&amp;file).await?;
    // File never cleaned up!

    // Unbounded loop - could run forever
    loop {
        process_next().await?;
    }
}).await?;
#}</code></pre></pre>
<a class="header" href="print.html#payload-validation" id="payload-validation"><h3>Payload Validation</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Validate early, clear errors
WORKER::register(&quot;validated&quot;, |ctx| async move {
    let payload = ctx.payload()
        .ok_or_else(|| Error::validation(&quot;Payload required&quot;))?;

    // Validate all required fields upfront
    let email = payload[&quot;email&quot;].as_str()
        .ok_or_else(|| Error::validation(&quot;email is required&quot;))?;

    if !email.contains('@') {
        return Err(Error::validation(&quot;Invalid email format&quot;));
    }

    let age = payload[&quot;age&quot;].as_i64()
        .ok_or_else(|| Error::validation(&quot;age must be a number&quot;))?;

    if age &lt; 0 || age &gt; 150 {
        return Err(Error::validation(&quot;Invalid age range&quot;));
    }

    // Proceed with validated data
    process_user(email, age).await
}).await?;
#}</code></pre></pre>
<a class="header" href="print.html#logging-and-observability" id="logging-and-observability"><h3>Logging and Observability</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;observable&quot;, |ctx| async move {
    let start = std::time::Instant::now();

    ctx.info(&quot;Worker started&quot;);

    // Log major steps
    ctx.info(&quot;Step 1: Fetching data&quot;);
    let data = fetch_data().await?;

    ctx.info(&amp;format!(&quot;Step 2: Processing {} records&quot;, data.len()));
    let result = process_data(&amp;data).await?;

    ctx.info(&quot;Step 3: Saving results&quot;);
    save_results(&amp;result).await?;

    let duration = start.elapsed();
    ctx.info(&amp;format!(&quot;âœ… Completed in {:.2}s&quot;, duration.as_secs_f64()));

    // Emit metrics
    ctx.emit(json!({
        &quot;duration_ms&quot;: duration.as_millis(),
        &quot;records_processed&quot;: data.len()
    }))?;

    Ok(())
}).await?;
#}</code></pre></pre>
<a class="header" href="print.html#testing-workers" id="testing-workers"><h3>Testing Workers</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_email_worker() {
        // Setup
        let app = RustF::new().with_workers();

        // Register test worker
        WORKER::register(&quot;test-email&quot;, |ctx| async move {
            let payload = ctx.payload().unwrap();
            assert!(payload[&quot;to&quot;].as_str().is_some());
            Ok(())
        }).await.unwrap();

        // Execute
        let result = WORKER::run(&quot;test-email&quot;, Some(json!({
            &quot;to&quot;: &quot;test@example.com&quot;
        }))).await;

        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_worker_timeout() {
        WORKER::register(&quot;slow&quot;, |ctx| async move {
            tokio::time::sleep(Duration::from_secs(10)).await;
            Ok(())
        }).await.unwrap();

        let handle = WORKER::call(
            &quot;slow&quot;,
            Some(Duration::from_secs(1)),
            None
        ).await.unwrap();

        let result = handle.await_result().await;
        assert!(result.is_err()); // Should timeout
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#performance-considerations-1" id="performance-considerations-1"><h3>Performance Considerations</h3></a>
<ol>
<li><strong>Use timeouts</strong>: Always set reasonable timeouts for external operations</li>
<li><strong>Batch operations</strong>: Process multiple items in one worker run when possible</li>
<li><strong>Avoid blocking</strong>: Use async I/O, don't block the thread</li>
<li><strong>Limit concurrency</strong>: Don't spawn thousands of workers simultaneously</li>
<li><strong>Monitor statistics</strong>: Track execution times and error rates</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Bounded concurrency
async fn process_many_items(items: Vec&lt;Value&gt;) -&gt; Result&lt;()&gt; {
    use futures::stream::{self, StreamExt};

    stream::iter(items)
        .map(|item| async move {
            WORKER::run(&quot;process-item&quot;, Some(item)).await
        })
        .buffer_unordered(10) // Max 10 concurrent workers
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .await;

    Ok(())
}

// âŒ Bad: Unbounded concurrency
async fn process_many_items_bad(items: Vec&lt;Value&gt;) -&gt; Result&lt;()&gt; {
    for item in items {
        tokio::spawn(async move {
            WORKER::run(&quot;process-item&quot;, Some(item)).await
        });
    }
    Ok(())
}
#}</code></pre></pre>
<hr />
<a class="header" href="print.html#api-reference-2" id="api-reference-2"><h2>API Reference</h2></a>
<a class="header" href="print.html#worker-global-api" id="worker-global-api"><h3>WORKER Global API</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct WORKER;

impl WORKER {
    /// Register a worker definition
    pub async fn register&lt;F, Fut&gt;(
        name: impl Into&lt;String&gt;,
        handler: F
    ) -&gt; Result&lt;()&gt;
    where
        F: Fn(WorkerContext) -&gt; Fut + Send + Sync + 'static,
        Fut: Future&lt;Output = Result&lt;()&gt;&gt; + Send + 'static;

    /// Call a worker and get a handle
    pub async fn call(
        worker_name: &amp;str,
        timeout: Option&lt;Duration&gt;,
        payload: Option&lt;Value&gt;
    ) -&gt; Result&lt;WorkerHandle&gt;;

    /// Run a worker and await completion
    pub async fn run(
        worker_name: &amp;str,
        payload: Option&lt;Value&gt;
    ) -&gt; Result&lt;()&gt;;

    /// Cancel a running worker
    pub async fn cancel(run_id: &amp;str) -&gt; Result&lt;()&gt;;

    /// List registered worker names
    pub async fn definitions() -&gt; Result&lt;Vec&lt;String&gt;&gt;;

    /// List currently running worker IDs
    pub async fn running() -&gt; Result&lt;Vec&lt;String&gt;&gt;;

    /// List running instances of a specific worker
    pub async fn running_for(worker_name: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;&gt;;

    /// Get statistics for a worker
    pub async fn stats(worker_name: &amp;str) -&gt; Option&lt;WorkerStats&gt;;

    /// Shutdown all running workers
    pub async fn shutdown() -&gt; Result&lt;()&gt;;
}
#}</code></pre></pre>
<a class="header" href="print.html#workercontext-1" id="workercontext-1"><h3>WorkerContext</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct WorkerContext {
    // Identity
    pub fn worker_name(&amp;self) -&gt; &amp;str;
    pub fn run_id(&amp;self) -&gt; &amp;str;

    // Configuration
    pub fn config(&amp;self) -&gt; &amp;Arc&lt;AppConfig&gt;;

    // Payload
    pub fn payload(&amp;self) -&gt; Option&lt;&amp;Value&gt;;

    // Environment
    pub fn is_development(&amp;self) -&gt; bool;
    pub fn is_production(&amp;self) -&gt; bool;

    // Logging
    pub fn log(&amp;self, level: log::Level, message: &amp;str);
    pub fn info(&amp;self, message: &amp;str);
    pub fn warn(&amp;self, message: &amp;str);
    pub fn error(&amp;self, message: &amp;str);
    pub fn debug(&amp;self, message: &amp;str);

    // State
    pub async fn set_state(
        &amp;self,
        key: impl Into&lt;String&gt;,
        value: Value
    ) -&gt; Result&lt;()&gt;;
    pub async fn get_state(&amp;self, key: &amp;str) -&gt; Option&lt;Value&gt;;
    pub async fn clear_state(&amp;self) -&gt; Result&lt;()&gt;;

    // Messaging
    pub fn emit(&amp;self, message: Value) -&gt; Result&lt;()&gt;;

    // Utilities
    pub async fn sleep(&amp;self, duration: Duration);
}
#}</code></pre></pre>
<a class="header" href="print.html#workerhandle-1" id="workerhandle-1"><h3>WorkerHandle</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct WorkerHandle {
    /// Get the unique run ID
    pub fn id(&amp;self) -&gt; &amp;str;

    /// Get the worker name
    pub fn worker_name(&amp;self) -&gt; &amp;str;

    /// Cancel this worker execution
    pub async fn cancel(&amp;self) -&gt; Result&lt;()&gt;;

    /// Receive next message from worker
    pub async fn recv(&amp;mut self) -&gt; Option&lt;Value&gt;;

    /// Wait for worker to complete
    pub async fn await_result(self) -&gt; Result&lt;()&gt;;
}
#}</code></pre></pre>
<a class="header" href="print.html#workerstats" id="workerstats"><h3>WorkerStats</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkerStats {
    /// Total number of executions
    pub runs: u64,

    /// Number of failed executions
    pub errors: u64,

    /// Duration of last execution in milliseconds
    pub last_run_ms: Option&lt;u64&gt;,

    /// Total cumulative runtime in milliseconds
    pub total_runtime_ms: u64,
}
#}</code></pre></pre>
<hr />
<a class="header" href="print.html#troubleshooting-5" id="troubleshooting-5"><h2>Troubleshooting</h2></a>
<a class="header" href="print.html#worker-not-found" id="worker-not-found"><h3>Worker Not Found</h3></a>
<p><strong>Error</strong>: <code>Worker 'my-worker' not registered</code></p>
<p><strong>Solutions</strong>:</p>
<ol>
<li><strong>Ensure worker file is in <code>src/workers/</code> directory</strong>:</li>
</ol>
<pre><code>src/
â””â”€â”€ workers/
    â””â”€â”€ my_worker.rs  â† Must be here!
</code></pre>
<ol start="2">
<li><strong>Check that the file has an <code>install()</code> function</strong>:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/workers/my_worker.rs
pub async fn install() -&gt; Result&lt;()&gt; {
    WORKER::register(&quot;my-worker&quot;, |ctx| async move {
        // Worker implementation
        Ok(())
    }).await?;
    Ok(())
}
#}</code></pre></pre>
<ol start="3">
<li><strong>Verify auto-discovery is enabled</strong>:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">// src/main.rs
#[rustf::auto_discover]  // â† Required!
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::new().auto_load();
    app.start().await
}
</code></pre></pre>
<ol start="4">
<li><strong>Check that file isn't being skipped</strong> (shouldn't be <code>mod.rs</code>, <code>_*.rs</code>, or <code>*.inc.rs</code>)</li>
</ol>
<a class="header" href="print.html#worker-manager-not-initialized" id="worker-manager-not-initialized"><h3>Worker Manager Not Initialized</h3></a>
<p><strong>Error</strong>: <code>Worker manager not initialised</code></p>
<p><strong>Solution</strong>: Use <code>.auto_load()</code> or explicitly enable workers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Recommended: Use auto_load
let app = RustF::new()
    .auto_load()  // Automatically enables workers
    .run(&quot;127.0.0.1:3000&quot;)
    .await?;

// Or explicitly:
let app = RustF::new()
    .with_workers()
    .workers_from(auto_workers!())
    .run(&quot;127.0.0.1:3000&quot;)
    .await?;
#}</code></pre></pre>
<a class="header" href="print.html#worker-timeout" id="worker-timeout"><h3>Worker Timeout</h3></a>
<p><strong>Error</strong>: <code>Worker 'slow-task' timed out after 5s</code></p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Increase timeout:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::call(&quot;slow-task&quot;, Some(Duration::from_secs(30)), payload).await?;
#}</code></pre></pre>
<ol start="2">
<li>Optimize worker to run faster:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Break work into smaller chunks
// Use async I/O instead of blocking
// Process in parallel where possible
#}</code></pre></pre>
<ol start="3">
<li>Remove timeout (not recommended for production):</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::call(&quot;slow-task&quot;, None, payload).await?;
#}</code></pre></pre>
<a class="header" href="print.html#messages-not-received" id="messages-not-received"><h3>Messages Not Received</h3></a>
<p><strong>Problem</strong>: <code>handle.recv()</code> returns <code>None</code> immediately.</p>
<p><strong>Solution</strong>: Worker must emit messages:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Worker must explicitly emit
WORKER::register(&quot;messenger&quot;, |ctx| async move {
    ctx.emit(json!({&quot;progress&quot;: 50}))?; // Emit message
    Ok(())
}).await?;

// Caller receives messages
let mut handle = WORKER::call(&quot;messenger&quot;, None, None).await?;
while let Some(msg) = handle.recv().await {
    println!(&quot;{}&quot;, msg);
}
#}</code></pre></pre>
<a class="header" href="print.html#payload-access-issues" id="payload-access-issues"><h3>Payload Access Issues</h3></a>
<p><strong>Problem</strong>: <code>ctx.payload()</code> returns <code>None</code>.</p>
<p><strong>Solution</strong>: Pass payload when calling:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Pass payload
WORKER::run(&quot;my-worker&quot;, Some(json!({&quot;key&quot;: &quot;value&quot;}))).await?;

// Access in worker
WORKER::register(&quot;my-worker&quot;, |ctx| async move {
    if let Some(payload) = ctx.payload() {
        // Use payload
    }
    Ok(())
}).await?;
#}</code></pre></pre>
<a class="header" href="print.html#worker-hangs-forever" id="worker-hangs-forever"><h3>Worker Hangs Forever</h3></a>
<p><strong>Problem</strong>: Worker never completes.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Add timeout:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::call(&quot;worker&quot;, Some(Duration::from_secs(30)), payload).await?;
#}</code></pre></pre>
<ol start="2">
<li>Debug with logging:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;debug&quot;, |ctx| async move {
    ctx.info(&quot;Step 1&quot;);
    step1().await?;
    ctx.info(&quot;Step 2&quot;);
    step2().await?;
    ctx.info(&quot;Complete&quot;);
    Ok(())
}).await?;
#}</code></pre></pre>
<ol start="3">
<li>Check for infinite loops or deadlocks in worker code.</li>
</ol>
<a class="header" href="print.html#high-memory-usage" id="high-memory-usage"><h3>High Memory Usage</h3></a>
<p><strong>Problem</strong>: Memory grows when running many workers.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Limit concurrent workers:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use futures::stream::{self, StreamExt};

stream::iter(items)
    .map(|item| WORKER::run(&quot;process&quot;, Some(item)))
    .buffer_unordered(10) // Max 10 concurrent
    .collect::&lt;Vec&lt;_&gt;&gt;()
    .await;
#}</code></pre></pre>
<ol start="2">
<li>Clean up resources in workers:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
WORKER::register(&quot;cleanup&quot;, |ctx| async move {
    let resource = allocate().await?;
    let result = process(&amp;resource).await;
    drop(resource); // Explicit cleanup
    result
}).await?;
#}</code></pre></pre>
<ol start="3">
<li>Use streaming for large data:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Process in chunks instead of loading everything
for chunk in data.chunks(1000) {
    process_chunk(chunk).await?;
}
#}</code></pre></pre>
<a class="header" href="print.html#statistics-not-updating" id="statistics-not-updating"><h3>Statistics Not Updating</h3></a>
<p><strong>Problem</strong>: <code>WORKER::stats()</code> returns outdated values.</p>
<p><strong>Solution</strong>: Statistics update after worker completion. Ensure:</p>
<ol>
<li>Worker completes successfully or fails (not cancelled mid-execution)</li>
<li>Await worker completion before checking stats</li>
<li>Stats are per-definition, not per-run</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Execute worker
WORKER::run(&quot;task&quot;, None).await?;

// Now stats are updated
let stats = WORKER::stats(&quot;task&quot;).await;
#}</code></pre></pre>
<hr />
<a class="header" href="print.html#summary-5" id="summary-5"><h2>Summary</h2></a>
<p>The RustF Worker system provides:</p>
<ul>
<li><strong>Simple Registration</strong>: <code>WORKER::register()</code> with async handlers</li>
<li><strong>Flexible Execution</strong>: Call and await, fire-and-forget, or stream messages</li>
<li><strong>Rich Context</strong>: Logging, state, configuration, and messaging</li>
<li><strong>Monitoring</strong>: Built-in statistics and running worker tracking</li>
<li><strong>Robust</strong>: Timeout support, cancellation, and graceful shutdown</li>
</ul>
<p><strong>Quick Reference</strong>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Enable
app.with_workers()

// Register
WORKER::register(&quot;name&quot;, |ctx| async move { Ok(()) }).await?

// Execute
WORKER::run(&quot;name&quot;, Some(payload)).await?

// Monitor
WORKER::stats(&quot;name&quot;).await
WORKER::running().await?
#}</code></pre></pre>
<p>For more examples, see the <a href="https://github.com/your-repo/rustf/tree/main/rustf-example">rustf-example</a> project.</p>
<hr />
<p><strong>Documentation Version</strong>: 1.0
<strong>Last Updated</strong>: 2025-01-22
<strong>RustF Version</strong>: 0.1.0</p>
<a class="header" href="print.html#rustf-event-system-guide" id="rustf-event-system-guide"><h1>RustF Event System Guide</h1></a>
<p>ğŸ¯ <strong>Total.js-Inspired Event-Driven Architecture</strong></p>
<p>This guide covers RustF's comprehensive event system, designed to provide Total.js-style <code>ON('ready', function())</code> patterns for application lifecycle management and extensible startup code execution.</p>
<a class="header" href="print.html#table-of-contents-3" id="table-of-contents-3"><h2>Table of Contents</h2></a>
<ul>
<li><a href="print.html#overview">Overview</a></li>
<li><a href="print.html#quick-start">Quick Start</a></li>
<li><a href="print.html#application-lifecycle-events">Application Lifecycle Events</a></li>
<li><a href="print.html#event-registration">Event Registration</a></li>
<li><a href="print.html#parallel-execution">Parallel Execution</a></li>
<li><a href="print.html#performance-configuration">Performance Configuration</a></li>
<li><a href="print.html#built-in-event-handlers">Built-in Event Handlers</a></li>
<li><a href="print.html#custom-event-handlers">Custom Event Handlers</a></li>
<li><a href="print.html#event-context">Event Context</a></li>
<li><a href="print.html#priority-system">Priority System</a></li>
<li><a href="print.html#auto-discovery">Auto-Discovery</a></li>
<li><a href="print.html#common-patterns">Common Patterns</a></li>
<li><a href="print.html#performance-considerations">Performance Considerations</a></li>
<li><a href="print.html#best-practices">Best Practices</a></li>
<li><a href="print.html#troubleshooting">Troubleshooting</a></li>
</ul>
<a class="header" href="print.html#overview-11" id="overview-11"><h2>Overview</h2></a>
<p>RustF's event system enables developers to hook into application lifecycle events using a familiar, Total.js-inspired pattern. This system provides:</p>
<a class="header" href="print.html#key-features-5" id="key-features-5"><h3>Key Features</h3></a>
<p>âœ… <strong>Total.js-Style Syntax</strong> - Familiar <code>ON('ready', handler)</code> pattern<br />
âœ… <strong>Lifecycle Events</strong> - Built-in events for all major application stages<br />
âœ… <strong>Priority-Based Execution</strong> - Control handler execution order<br />
âœ… <strong>Parallel Execution</strong> - Concurrent handler execution within priority groups for optimal performance<br />
âœ… <strong>Built-in Handlers</strong> - Ready-to-use handlers for common tasks<br />
âœ… <strong>Event Context</strong> - Rich context with app config, environment, and utilities<br />
âœ… <strong>Auto-Discovery</strong> - Automatic event handler registration<br />
âœ… <strong>Type Safety</strong> - Full compile-time type checking<br />
âœ… <strong>Async Native</strong> - Built for async/await from the ground up<br />
âœ… <strong>Performance Optimized</strong> - Fast-path execution, configurable timeouts, and error isolation</p>
<a class="header" href="print.html#event-driven-benefits" id="event-driven-benefits"><h3>Event-Driven Benefits</h3></a>
<ul>
<li><strong>Decoupled Code</strong>: Event handlers don't need to know about each other</li>
<li><strong>Extensible</strong>: Easy to add new functionality without modifying core code</li>
<li><strong>Testable</strong>: Individual event handlers can be tested in isolation</li>
<li><strong>Organized</strong>: Clean separation between initialization logic</li>
<li><strong>Flexible</strong>: Conditional execution based on environment or configuration</li>
</ul>
<a class="header" href="print.html#quick-start-5" id="quick-start-5"><h2>Quick Start</h2></a>
<a class="header" href="print.html#basic-event-registration" id="basic-event-registration"><h3>Basic Event Registration</h3></a>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;

#[tokio::main]
async fn main() -&gt; rustf::Result&lt;()&gt; {
    let app = RustF::new()
        // Register event handlers using familiar Total.js syntax
        .on(&quot;ready&quot;, |ctx| Box::pin(async move {
            println!(&quot;ğŸš€ Application ready in {} mode!&quot;, ctx.env());
            Ok(())
        }))
        
        .on(&quot;startup&quot;, |ctx| Box::pin(async move {
            println!(&quot;âš¡ Startup tasks executing...&quot;);
            // Database seeding, directory creation, etc.
            Ok(())
        }))
        
        .controllers(auto_controllers!());
    
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#using-built-in-handlers" id="using-built-in-handlers"><h3>Using Built-in Handlers</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

let app = RustF::new()
    // Built-in handlers for common tasks
    .on(&quot;startup&quot;, builtin::directory_setup(&amp;[&quot;uploads&quot;, &quot;temp&quot;, &quot;logs&quot;]))
    .on(&quot;startup&quot;, builtin::cleanup_manager(&quot;temp/&quot;, Duration::from_secs(3600)))
    .on(&quot;config.loaded&quot;, builtin::configuration_validator)
    .on(&quot;ready&quot;, builtin::health_check)
    
    .controllers(auto_controllers!());
#}</code></pre></pre>
<a class="header" href="print.html#application-lifecycle-events" id="application-lifecycle-events"><h2>Application Lifecycle Events</h2></a>
<p>RustF emits events automatically during application startup, providing hooks for every stage of initialization:</p>
<a class="header" href="print.html#core-lifecycle-events" id="core-lifecycle-events"><h3>Core Lifecycle Events</h3></a>
<table><thead><tr><th> Event </th><th> When Emitted </th><th> Use Case </th></tr></thead><tbody>
<tr><td> <code>config.loaded</code> </td><td> Configuration loaded and validated </td><td> Config validation, environment checks </td></tr>
<tr><td> <code>database.ready</code> </td><td> Database connection established </td><td> Database seeding, migration checks </td></tr>
<tr><td> <code>modules.ready</code> </td><td> Shared modules initialized </td><td> Module-dependent initialization </td></tr>
<tr><td> <code>middleware.ready</code> </td><td> Middleware chain configured </td><td> Middleware-dependent setup </td></tr>
<tr><td> <code>routes.ready</code> </td><td> Routes registered </td><td> Route-dependent initialization </td></tr>
<tr><td> <code>startup</code> </td><td> Before server starts listening </td><td> Final startup tasks </td></tr>
<tr><td> <code>ready</code> </td><td> Framework fully initialized </td><td> Application ready notifications </td></tr>
</tbody></table>
<a class="header" href="print.html#event-execution-order" id="event-execution-order"><h3>Event Execution Order</h3></a>
<pre><code>1. config.loaded    â† Configuration loaded
2. database.ready   â† Database connected  
3. modules.ready    â† Shared modules initialized
4. middleware.ready â† Middleware configured
5. routes.ready     â† Routes registered
6. startup          â† Pre-server startup tasks
7. ready            â† Application fully ready
   â†“
   Server starts listening
</code></pre>
<a class="header" href="print.html#custom-events" id="custom-events"><h3>Custom Events</h3></a>
<p>You can also emit custom events from within handlers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    println!(&quot;Application ready!&quot;);
    
    // Emit a custom event
    ctx.emit(&quot;custom.initialization&quot;, Some(json!({
        &quot;timestamp&quot;: chrono::Utc::now().to_rfc3339(),
        &quot;environment&quot;: ctx.env()
    }))).await?;
    
    Ok(())
}))

.on(&quot;custom.initialization&quot;, |ctx| Box::pin(async move {
    if let Some(data) = &amp;ctx.data {
        println!(&quot;Custom event data: {}&quot;, data);
    }
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#event-registration" id="event-registration"><h2>Event Registration</h2></a>
<a class="header" href="print.html#registration-methods" id="registration-methods"><h3>Registration Methods</h3></a>
<a class="header" href="print.html#onevent-handler---basic-registration" id="onevent-handler---basic-registration"><h4><code>.on(event, handler)</code> - Basic Registration</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
app.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    println!(&quot;Application ready!&quot;);
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#on_priorityevent-priority-handler---priority-based" id="on_priorityevent-priority-handler---priority-based"><h4><code>.on_priority(event, priority, handler)</code> - Priority-Based</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
app.on_priority(&quot;startup&quot;, -100, |ctx| Box::pin(async move {
    println!(&quot;High priority task (runs first)&quot;);
    Ok(())
}))

.on_priority(&quot;startup&quot;, 100, |ctx| Box::pin(async move {
    println!(&quot;Low priority task (runs last)&quot;);
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#events_fromregister_fn---bulk-registration" id="events_fromregister_fn---bulk-registration"><h4><code>.events_from(register_fn)</code> - Bulk Registration</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
app.events_from(|emitter| {
    emitter.on(&quot;ready&quot;, startup_logger);
    emitter.on(&quot;database.ready&quot;, database_seeder);
    emitter.once(&quot;ready&quot;, one_time_setup);
})
#}</code></pre></pre>
<a class="header" href="print.html#onceevent-handler---one-time-handlers" id="onceevent-handler---one-time-handlers"><h4><code>.once(event, handler)</code> - One-Time Handlers</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// This handler will only execute once, even if the event is emitted multiple times
emitter.once(&quot;ready&quot;, |ctx| Box::pin(async move {
    println!(&quot;This runs only once!&quot;);
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#parallel-execution" id="parallel-execution"><h2>Parallel Execution</h2></a>
<p>RustF's event system features high-performance parallel execution of handlers within the same priority group, while maintaining strict priority ordering between groups.</p>
<a class="header" href="print.html#how-parallel-execution-works" id="how-parallel-execution-works"><h3>How Parallel Execution Works</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Multiple handlers at the same priority execute in parallel
app.on(&quot;ready&quot;, |_ctx| Box::pin(async move {
    println!(&quot;Handler 1 starting...&quot;);
    tokio::time::sleep(Duration::from_millis(100)).await; // Simulated work
    println!(&quot;Handler 1 done&quot;);
    Ok(())
}))

.on(&quot;ready&quot;, |_ctx| Box::pin(async move {
    println!(&quot;Handler 2 starting...&quot;);
    tokio::time::sleep(Duration::from_millis(100)).await; // Simulated work  
    println!(&quot;Handler 2 done&quot;);
    Ok(())
}))

.on(&quot;ready&quot;, |_ctx| Box::pin(async move {
    println!(&quot;Handler 3 starting...&quot;);
    tokio::time::sleep(Duration::from_millis(100)).await; // Simulated work
    println!(&quot;Handler 3 done&quot;);
    Ok(())
}));

// All 3 handlers execute concurrently!
// Total execution time: ~100ms (instead of ~300ms sequential)
#}</code></pre></pre>
<a class="header" href="print.html#priority-groups-and-parallel-execution" id="priority-groups-and-parallel-execution"><h3>Priority Groups and Parallel Execution</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
app
    // Priority -100: Infrastructure handlers (execute first, in parallel)
    .on_priority(&quot;startup&quot;, -100, database_init_handler)    // Runs in parallel
    .on_priority(&quot;startup&quot;, -100, cache_init_handler)       // with this one
    .on_priority(&quot;startup&quot;, -100, logging_init_handler)     // and this one
    
    // Wait for all priority -100 handlers to complete...
    
    // Priority 0: Application handlers (execute second, in parallel)  
    .on(&quot;startup&quot;, user_service_init)     // Runs in parallel
    .on(&quot;startup&quot;, email_service_init)    // with this one
    .on(&quot;startup&quot;, file_service_init)     // and this one
    
    // Wait for all priority 0 handlers to complete...
    
    // Priority 100: Cleanup handlers (execute last, in parallel)
    .on_priority(&quot;startup&quot;, 100, temp_cleanup)         // Runs in parallel
    .on_priority(&quot;startup&quot;, 100, session_cleanup)      // with this one
#}</code></pre></pre>
<a class="header" href="print.html#performance-benefits" id="performance-benefits"><h3>Performance Benefits</h3></a>
<p><strong>Example Performance Improvement:</strong></p>
<ul>
<li>4 handlers, each taking 100ms</li>
<li><strong>Sequential execution</strong>: 400ms total</li>
<li><strong>Parallel execution</strong>: 100ms total (<strong>4x faster!</strong>)</li>
</ul>
<a class="header" href="print.html#performance-configuration" id="performance-configuration"><h2>Performance Configuration</h2></a>
<p>Configure event system performance settings for optimal behavior:</p>
<a class="header" href="print.html#basic-configuration" id="basic-configuration"><h3>Basic Configuration</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::events::EventEmitterConfig;
use std::time::Duration;

let app = RustF::new()
    .event_config(EventEmitterConfig::parallel() // Enable parallel execution
        .with_timeout(Duration::from_secs(30))    // Handler timeout protection
        .with_debug_logging(false)                // Disable debug logging for performance
        .with_max_concurrent(8))                  // Limit concurrent handlers
#}</code></pre></pre>
<a class="header" href="print.html#configuration-presets" id="configuration-presets"><h3>Configuration Presets</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// High-performance configuration (production)
let config = EventEmitterConfig::parallel()
    .with_timeout(Duration::from_secs(60))
    .with_debug_logging(false);

// Debug-friendly configuration (development)
let config = EventEmitterConfig::sequential()
    .with_timeout(Duration::from_secs(10))
    .with_debug_logging(true);

let app = RustF::new().event_config(config);
#}</code></pre></pre>
<a class="header" href="print.html#configuration-options" id="configuration-options"><h3>Configuration Options</h3></a>
<table><thead><tr><th> Option </th><th> Description </th><th> Default </th><th> Recommendation </th></tr></thead><tbody>
<tr><td> <code>parallel_execution</code> </td><td> Enable parallel handler execution </td><td> <code>true</code> </td><td> <code>true</code> for production, <code>false</code> for debugging </td></tr>
<tr><td> <code>handler_timeout</code> </td><td> Maximum handler execution time </td><td> 30 seconds </td><td> 30-60s for production, 10s for development </td></tr>
<tr><td> <code>debug_logging</code> </td><td> Enable detailed execution logging </td><td> <code>cfg!(debug_assertions)</code> </td><td> <code>false</code> for production (performance) </td></tr>
<tr><td> <code>max_concurrent_handlers</code> </td><td> Limit concurrent handlers per priority </td><td> <code>0</code> (unlimited) </td><td> 4-12 based on workload </td></tr>
</tbody></table>
<a class="header" href="print.html#built-in-event-handlers" id="built-in-event-handlers"><h2>Built-in Event Handlers</h2></a>
<p>RustF provides ready-to-use event handlers for common startup tasks:</p>
<a class="header" href="print.html#database-seeder" id="database-seeder"><h3>Database Seeder</h3></a>
<p>Automatically runs SQL seed files from a directory:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;database.ready&quot;, builtin::database_seeder(&quot;seeds/&quot;))
#}</code></pre></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Executes SQL files in alphabetical order</li>
<li>Only runs in development by default</li>
<li>Handles multiple database types</li>
<li>Continues on individual file failures</li>
</ul>
<a class="header" href="print.html#directory-setup" id="directory-setup"><h3>Directory Setup</h3></a>
<p>Ensures required directories exist with proper permissions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;startup&quot;, builtin::directory_setup(&amp;[
    &quot;uploads&quot;, &quot;temp&quot;, &quot;logs&quot;, &quot;cache&quot;, &quot;sessions&quot;
]))
#}</code></pre></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Creates missing directories</li>
<li>Sets appropriate permissions (755 on Unix)</li>
<li>Logs creation status</li>
<li>Safe for repeated execution</li>
</ul>
<a class="header" href="print.html#cleanup-manager" id="cleanup-manager"><h3>Cleanup Manager</h3></a>
<p>Removes old temporary files and performs cleanup:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;startup&quot;, builtin::cleanup_manager(&quot;temp/&quot;, Duration::from_secs(86400)))
#}</code></pre></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Removes files older than specified duration</li>
<li>Handles both files and directories</li>
<li>Logs cleanup statistics</li>
<li>Safe error handling</li>
</ul>
<a class="header" href="print.html#configuration-validator" id="configuration-validator"><h3>Configuration Validator</h3></a>
<p>Validates critical configuration settings:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;config.loaded&quot;, builtin::configuration_validator)
#}</code></pre></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Validates production-specific settings</li>
<li>Checks for default/insecure values</li>
<li>Environment-specific validation rules</li>
<li>Fails fast on critical issues</li>
</ul>
<a class="header" href="print.html#health-check" id="health-check"><h3>Health Check</h3></a>
<p>Performs basic application health checks:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;ready&quot;, builtin::health_check)
#}</code></pre></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Database connectivity check</li>
<li>System resource validation</li>
<li>Environment-specific checks</li>
<li>Detailed health reporting</li>
</ul>
<a class="header" href="print.html#environment-check" id="environment-check"><h3>Environment Check</h3></a>
<p>Validates the application is running in the expected environment:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;startup&quot;, builtin::environment_check(&quot;production&quot;))
#}</code></pre></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Environment validation</li>
<li>Fails in production if mismatch detected</li>
<li>Configurable expected environment</li>
<li>Detailed error reporting</li>
</ul>
<a class="header" href="print.html#custom-event-handlers" id="custom-event-handlers"><h2>Custom Event Handlers</h2></a>
<a class="header" href="print.html#creating-custom-handlers" id="creating-custom-handlers"><h3>Creating Custom Handlers</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Simple handler function
async fn database_migration_check(ctx: EventContext) -&gt; rustf::Result&lt;()&gt; {
    if ctx.is_production() {
        println!(&quot;Checking database migrations in production...&quot;);
        // Check migration status
        run_migration_check().await?;
    }
    Ok(())
}

// Register the handler
app.on(&quot;database.ready&quot;, |ctx| Box::pin(database_migration_check(ctx)))
#}</code></pre></pre>
<a class="header" href="print.html#handler-functions-vs-closures" id="handler-functions-vs-closures"><h3>Handler Functions vs Closures</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Function-based handler (reusable)
async fn reusable_handler(ctx: EventContext) -&gt; rustf::Result&lt;()&gt; {
    println!(&quot;Handler executed for: {}&quot;, ctx.event);
    Ok(())
}

app.on(&quot;ready&quot;, |ctx| Box::pin(reusable_handler(ctx)))

// Closure-based handler (inline)
app.on(&quot;startup&quot;, |ctx| Box::pin(async move {
    println!(&quot;Inline handler for {}&quot;, ctx.event);
    // Access closure variables
    let config = &amp;ctx.config;
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#conditional-handlers" id="conditional-handlers"><h3>Conditional Handlers</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
app.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    match ctx.env() {
        &quot;development&quot; =&gt; {
            println!(&quot;Development setup&quot;);
            setup_dev_data().await?;
        }
        &quot;production&quot; =&gt; {
            println!(&quot;Production validation&quot;);
            validate_production_config(&amp;ctx.config)?;
        }
        _ =&gt; {
            println!(&quot;Default environment setup&quot;);
        }
    }
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#event-context" id="event-context"><h2>Event Context</h2></a>
<p>The <code>EventContext</code> provides rich information and utilities for event handlers:</p>
<a class="header" href="print.html#context-properties" id="context-properties"><h3>Context Properties</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn handler_example(ctx: EventContext) -&gt; rustf::Result&lt;()&gt; {
    // Event information
    println!(&quot;Event: {}&quot;, ctx.event);
    println!(&quot;Environment: {}&quot;, ctx.env());
    
    // Environment checks
    if ctx.is_development() {
        println!(&quot;Running in development mode&quot;);
    }
    
    if ctx.is_production() {
        println!(&quot;Running in production mode&quot;);
    }
    
    // Configuration access
    let server_port = ctx.config.server.port;
    let database_url = &amp;ctx.config.database.url;
    
    // Event data (if provided)
    if let Some(data) = &amp;ctx.data {
        println!(&quot;Event data: {}&quot;, data);
    }
    
    // Emit other events
    ctx.emit(&quot;custom.event&quot;, Some(json!({&quot;from&quot;: ctx.event}))).await?;
    
    Ok(())
}
#}</code></pre></pre>
<a class="header" href="print.html#available-context-methods" id="available-context-methods"><h3>Available Context Methods</h3></a>
<table><thead><tr><th> Method </th><th> Description </th><th> Example </th></tr></thead><tbody>
<tr><td> <code>ctx.event</code> </td><td> Current event name </td><td> <code>&quot;ready&quot;</code> </td></tr>
<tr><td> <code>ctx.env()</code> </td><td> Current environment </td><td> <code>&quot;development&quot;</code> </td></tr>
<tr><td> <code>ctx.is_development()</code> </td><td> Development check </td><td> <code>true</code> </td></tr>
<tr><td> <code>ctx.is_production()</code> </td><td> Production check </td><td> <code>false</code> </td></tr>
<tr><td> <code>ctx.config</code> </td><td> Application config </td><td> <code>ctx.config.server.port</code> </td></tr>
<tr><td> <code>ctx.data</code> </td><td> Event data </td><td> <code>json!({&quot;key&quot;: &quot;value&quot;})</code> </td></tr>
<tr><td> <code>ctx.emit(event, data)</code> </td><td> Emit another event </td><td> Custom event emission </td></tr>
</tbody></table>
<a class="header" href="print.html#priority-system-1" id="priority-system-1"><h2>Priority System</h2></a>
<p>Control the execution order of event handlers using priorities:</p>
<a class="header" href="print.html#priority-values" id="priority-values"><h3>Priority Values</h3></a>
<ul>
<li><strong>-200 to -100</strong>: Infrastructure (database, core systems)</li>
<li><strong>-99 to -50</strong>: Security and authentication</li>
<li><strong>-49 to -1</strong>: Business logic prerequisites</li>
<li><strong>0</strong>: Default priority (recommended for most handlers)</li>
<li><strong>1 to 99</strong>: Business logic</li>
<li><strong>100+</strong>: Post-processing and cleanup</li>
</ul>
<a class="header" href="print.html#priority-examples" id="priority-examples"><h3>Priority Examples</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
app
    // Critical infrastructure (runs first)
    .on_priority(&quot;startup&quot;, -100, builtin::directory_setup(&amp;[&quot;logs&quot;]))
    
    // Security setup
    .on_priority(&quot;startup&quot;, -50, security_initialization)
    
    // Default priority (most handlers)
    .on(&quot;startup&quot;, application_setup)
    
    // Cleanup tasks (runs last)
    .on_priority(&quot;startup&quot;, 100, final_cleanup)
#}</code></pre></pre>
<a class="header" href="print.html#execution-flow" id="execution-flow"><h3>Execution Flow</h3></a>
<pre><code>Priority -100: Infrastructure setup
Priority -50:  Security initialization  
Priority 0:    Application setup (default)
Priority 100:  Final cleanup
</code></pre>
<a class="header" href="print.html#auto-discovery-1" id="auto-discovery-1"><h2>Auto-Discovery</h2></a>
<p>RustF can automatically discover and register event handlers from your codebase:</p>
<a class="header" href="print.html#file-structure" id="file-structure"><h3>File Structure</h3></a>
<pre><code>src/
  events/           â† Event handler modules
    database.rs     â† Database-related events
    filesystem.rs   â† File system events
    security.rs     â† Security events
    custom.rs       â† Custom application events
</code></pre>
<a class="header" href="print.html#event-handler-module" id="event-handler-module"><h3>Event Handler Module</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/events/database.rs
use rustf::events::{EventEmitter, EventContext};

pub fn install(emitter: &amp;mut EventEmitter) {
    emitter.on(&quot;database.ready&quot;, seed_development_data);
    emitter.on(&quot;ready&quot;, database_health_check);
}

async fn seed_development_data(ctx: EventContext) -&gt; rustf::Result&lt;()&gt; {
    if ctx.is_development() {
        println!(&quot;Seeding development data...&quot;);
        // Database seeding logic
    }
    Ok(())
}

async fn database_health_check(ctx: EventContext) -&gt; rustf::Result&lt;()&gt; {
    println!(&quot;Running database health check...&quot;);
    // Health check logic
    Ok(())
}
#}</code></pre></pre>
<a class="header" href="print.html#auto-discovery-registration" id="auto-discovery-registration"><h3>Auto-Discovery Registration</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// main.rs
use rustf::prelude::*;

let app = RustF::new()
    .events_from(auto_events!())  // Auto-discovers src/events/*.rs
    .controllers(auto_controllers!());
#}</code></pre></pre>
<p><strong>Note</strong>: Auto-discovery requires the <code>auto-discovery</code> feature to be enabled.</p>
<a class="header" href="print.html#common-patterns" id="common-patterns"><h2>Common Patterns</h2></a>
<a class="header" href="print.html#database-initialization-pattern" id="database-initialization-pattern"><h3>Database Initialization Pattern</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
app.on(&quot;database.ready&quot;, |ctx| Box::pin(async move {
    if ctx.is_development() {
        // Seed development data
        println!(&quot;Seeding development database...&quot;);
        seed_database().await?;
    } else if ctx.is_production() {
        // Validate production database
        println!(&quot;Validating production database...&quot;);
        validate_database_schema().await?;
    }
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#multi-environment-setup" id="multi-environment-setup"><h3>Multi-Environment Setup</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
app.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    match ctx.env() {
        &quot;development&quot; =&gt; {
            setup_debug_tools().await?;
            enable_hot_reload().await?;
        }
        &quot;staging&quot; =&gt; {
            setup_staging_environment().await?;
            enable_performance_monitoring().await?;
        }
        &quot;production&quot; =&gt; {
            validate_security_settings(&amp;ctx.config)?;
            enable_production_monitoring().await?;
        }
        env =&gt; {
            log::warn!(&quot;Unknown environment: {}&quot;, env);
        }
    }
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#dependency-chain-pattern" id="dependency-chain-pattern"><h3>Dependency Chain Pattern</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
app
    // Step 1: Initialize core services
    .on_priority(&quot;startup&quot;, -100, |ctx| Box::pin(async move {
        initialize_core_services().await?;
        ctx.emit(&quot;services.ready&quot;, None).await?;
        Ok(())
    }))
    
    // Step 2: Setup dependent services
    .on(&quot;services.ready&quot;, |ctx| Box::pin(async move {
        setup_dependent_services().await?;
        ctx.emit(&quot;dependencies.ready&quot;, None).await?;
        Ok(())
    }))
    
    // Step 3: Final application setup
    .on(&quot;dependencies.ready&quot;, |ctx| Box::pin(async move {
        finalize_application_setup().await?;
        Ok(())
    }))
#}</code></pre></pre>
<a class="header" href="print.html#error-recovery-pattern" id="error-recovery-pattern"><h3>Error Recovery Pattern</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
app.on(&quot;database.ready&quot;, |ctx| Box::pin(async move {
    match connect_to_database().await {
        Ok(()) =&gt; {
            println!(&quot;âœ… Database connected&quot;);
            ctx.emit(&quot;database.connected&quot;, None).await?;
        }
        Err(e) =&gt; {
            log::error!(&quot;âŒ Database connection failed: {}&quot;, e);
            
            if ctx.is_production() {
                // Fail fast in production
                return Err(e);
            } else {
                // Try fallback in development
                setup_fallback_database().await?;
                ctx.emit(&quot;database.fallback&quot;, None).await?;
            }
        }
    }
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#best-practices-18" id="best-practices-18"><h2>Best Practices</h2></a>
<a class="header" href="print.html#1-use-descriptive-event-names" id="1-use-descriptive-event-names"><h3>1. Use Descriptive Event Names</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Good: Clear and descriptive
.on(&quot;database.schema.validated&quot;, handler)
.on(&quot;security.certificates.loaded&quot;, handler)
.on(&quot;cache.warmed&quot;, handler)

// Avoid: Generic or unclear
.on(&quot;done&quot;, handler)
.on(&quot;init&quot;, handler)
.on(&quot;setup&quot;, handler)
#}</code></pre></pre>
<a class="header" href="print.html#2-leverage-priority-system" id="2-leverage-priority-system"><h3>2. Leverage Priority System</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Good: Logical priority ordering
.on_priority(&quot;startup&quot;, -100, create_directories)    // Infrastructure
.on_priority(&quot;startup&quot;, -50, load_certificates)      // Security
.on_priority(&quot;startup&quot;, 0, initialize_services)      // Business logic
.on_priority(&quot;startup&quot;, 100, warm_caches)           // Optimization
#}</code></pre></pre>
<a class="header" href="print.html#3-handle-errors-gracefully-1" id="3-handle-errors-gracefully-1"><h3>3. Handle Errors Gracefully</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    match risky_operation().await {
        Ok(()) =&gt; {
            log::info!(&quot;âœ… Operation completed successfully&quot;);
        }
        Err(e) =&gt; {
            log::error!(&quot;âŒ Operation failed: {}&quot;, e);
            
            // Don't fail the entire application for non-critical errors
            if is_critical_error(&amp;e) {
                return Err(e);
            }
            
            // Try fallback or continue
            attempt_fallback().await.ok();
        }
    }
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#4-use-environment-specific-logic" id="4-use-environment-specific-logic"><h3>4. Use Environment-Specific Logic</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    if ctx.is_development() {
        setup_development_tools().await?;
        seed_test_data().await?;
    }
    
    if ctx.is_production() {
        validate_production_config(&amp;ctx.config)?;
        setup_monitoring().await?;
    }
    
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#5-emit-custom-events-for-extension-points" id="5-emit-custom-events-for-extension-points"><h3>5. Emit Custom Events for Extension Points</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    initialize_core_application().await?;
    
    // Emit custom event for plugins/extensions
    ctx.emit(&quot;application.plugins.load&quot;, None).await?;
    
    finalize_initialization().await?;
    Ok(())
}))

// Extensions can hook into the custom event
.on(&quot;application.plugins.load&quot;, |ctx| Box::pin(async move {
    load_custom_plugins().await?;
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#6-document-event-contracts" id="6-document-event-contracts"><h3>6. Document Event Contracts</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Emitted when the user authentication system is fully initialized
/// 
/// Context Data: None
/// Prerequisites: database.ready, security.certificates.loaded
/// Guarantees: User authentication is available for requests
.on(&quot;auth.system.ready&quot;, auth_system_handler)
#}</code></pre></pre>
<a class="header" href="print.html#troubleshooting-6" id="troubleshooting-6"><h2>Troubleshooting</h2></a>
<a class="header" href="print.html#common-issues-2" id="common-issues-2"><h3>Common Issues</h3></a>
<a class="header" href="print.html#1-handlers-not-executing" id="1-handlers-not-executing"><h4>1. Handlers Not Executing</h4></a>
<p><strong>Problem</strong>: Event handlers don't seem to run.</p>
<p><strong>Solutions</strong>:</p>
<ul>
<li>Verify event names match exactly (case-sensitive)</li>
<li>Check that events are being emitted by the framework</li>
<li>Ensure handler registration happens before <code>app.start()</code></li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ Incorrect event name
.on(&quot;readdy&quot;, handler)  // Typo

// âœ… Correct event name  
.on(&quot;ready&quot;, handler)
#}</code></pre></pre>
<a class="header" href="print.html#2-handler-execution-order-issues" id="2-handler-execution-order-issues"><h4>2. Handler Execution Order Issues</h4></a>
<p><strong>Problem</strong>: Handlers run in unexpected order.</p>
<p><strong>Solutions</strong>:</p>
<ul>
<li>Use priority system to control execution order</li>
<li>Check priority values (lower = earlier execution)</li>
<li>Avoid depending on registration order</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ Relying on registration order
.on(&quot;startup&quot;, handler_a)  // Might run second
.on(&quot;startup&quot;, handler_b)  // Might run first

// âœ… Using explicit priorities
.on_priority(&quot;startup&quot;, 10, handler_a)  // Runs first
.on_priority(&quot;startup&quot;, 20, handler_b)  // Runs second
#}</code></pre></pre>
<a class="header" href="print.html#3-async-handler-issues" id="3-async-handler-issues"><h4>3. Async Handler Issues</h4></a>
<p><strong>Problem</strong>: Async operations not completing or compiler errors.</p>
<p><strong>Solutions</strong>:</p>
<ul>
<li>Always wrap handlers with <code>Box::pin(async move { ... })</code></li>
<li>Ensure all async operations are awaited</li>
<li>Return <code>rustf::Result&lt;()&gt;</code> from handlers</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ Missing Box::pin
.on(&quot;ready&quot;, |ctx| async move {  // Compiler error
    Ok(())
})

// âœ… Proper async handler
.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    some_async_operation().await?;
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#4-context-data-not-available" id="4-context-data-not-available"><h4>4. Context Data Not Available</h4></a>
<p><strong>Problem</strong>: <code>ctx.data</code> is always <code>None</code>.</p>
<p><strong>Solutions</strong>:</p>
<ul>
<li>Check that events are emitted with data</li>
<li>Verify JSON serialization of event data</li>
<li>Use built-in events with expected data structure</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Emitting event with data
ctx.emit(&quot;custom.event&quot;, Some(json!({
    &quot;message&quot;: &quot;Hello&quot;,
    &quot;timestamp&quot;: chrono::Utc::now()
}))).await?;

// Receiving event data
.on(&quot;custom.event&quot;, |ctx| Box::pin(async move {
    if let Some(data) = &amp;ctx.data {
        println!(&quot;Received: {}&quot;, data);
    }
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#5-environment-detection-issues" id="5-environment-detection-issues"><h4>5. Environment Detection Issues</h4></a>
<p><strong>Problem</strong>: Environment methods return unexpected values.</p>
<p><strong>Solutions</strong>:</p>
<ul>
<li>Set environment variables properly</li>
<li>Check supported environment variable names</li>
<li>Use explicit environment checks</li>
</ul>
<pre><code class="language-bash"># Set environment (choose one)
export NODE_ENV=production
export RUST_ENV=production  
export APP_ENV=production
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Debug environment detection
.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    println!(&quot;Environment: {}&quot;, ctx.env());
    println!(&quot;Is development: {}&quot;, ctx.is_development());
    println!(&quot;Is production: {}&quot;, ctx.is_production());
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#debugging-events" id="debugging-events"><h3>Debugging Events</h3></a>
<p>Enable debug logging to see event execution:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// In main.rs
env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(&quot;debug&quot;)).init();

// Events will log execution details:
// [DEBUG] Registered event handler for 'ready' with priority 0 (id: 1)
// [INFO]  Emitting event: 'ready'
// [DEBUG] Executing handler 1 for 'ready' (priority: 0)
// [INFO]  Event 'ready' executed 1 handler(s)
#}</code></pre></pre>
<a class="header" href="print.html#performance-considerations-2" id="performance-considerations-2"><h2>Performance Considerations</h2></a>
<a class="header" href="print.html#parallel-vs-sequential-execution" id="parallel-vs-sequential-execution"><h3>Parallel vs Sequential Execution</h3></a>
<p>RustF automatically optimizes event handler execution for maximum performance:</p>
<p><strong>Parallel Execution (Default)</strong>:</p>
<ul>
<li>Handlers within the same priority group execute concurrently</li>
<li>Significantly faster for I/O bound tasks (database calls, file operations)</li>
<li>Optimal for production environments</li>
<li>Example: 4 handlers Ã— 100ms each = <strong>100ms total</strong> (4x speedup)</li>
</ul>
<p><strong>Sequential Execution (Debug Mode)</strong>:</p>
<ul>
<li>Handlers execute one after another</li>
<li>Easier to debug and trace execution</li>
<li>Recommended for development and testing</li>
<li>Example: 4 handlers Ã— 100ms each = <strong>400ms total</strong></li>
</ul>
<a class="header" href="print.html#performance-optimization-tips" id="performance-optimization-tips"><h3>Performance Optimization Tips</h3></a>
<a class="header" href="print.html#1-enable-parallel-execution-in-production" id="1-enable-parallel-execution-in-production"><h4>1. <strong>Enable Parallel Execution in Production</strong></h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = RustF::new()
    .event_config(EventEmitterConfig::parallel()
        .with_debug_logging(false));  // Disable debug logging for performance
#}</code></pre></pre>
<a class="header" href="print.html#2-use-priority-groups-strategically" id="2-use-priority-groups-strategically"><h4>2. <strong>Use Priority Groups Strategically</strong></h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Group related handlers by priority
.on_priority(&quot;startup&quot;, -100, database_init)     // Infrastructure first
.on_priority(&quot;startup&quot;, -100, cache_init)        // (parallel with above)
.on_priority(&quot;startup&quot;, 0, service_init)         // Services second
.on_priority(&quot;startup&quot;, 0, api_init)             // (parallel with above)

// âŒ Avoid: Mixed priorities force sequential execution
.on_priority(&quot;startup&quot;, -100, database_init)
.on_priority(&quot;startup&quot;, 0, service_init)         // Must wait for database_init
.on_priority(&quot;startup&quot;, -99, cache_init)         // Must wait for service_init
#}</code></pre></pre>
<a class="header" href="print.html#3-configure-timeouts-appropriately" id="3-configure-timeouts-appropriately"><h4>3. <strong>Configure Timeouts Appropriately</strong></h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Production: Longer timeouts for complex operations
.event_config(EventEmitterConfig::parallel()
    .with_timeout(Duration::from_secs(60)))

// Development: Shorter timeouts to catch hung handlers
.event_config(EventEmitterConfig::sequential()
    .with_timeout(Duration::from_secs(10)))
#}</code></pre></pre>
<a class="header" href="print.html#4-optimize-handler-design" id="4-optimize-handler-design"><h4>4. <strong>Optimize Handler Design</strong></h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Fast, focused handlers
.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    log::info!(&quot;Application ready in {} mode&quot;, ctx.env());
    Ok(())
}))

// âœ… Good: Async I/O operations benefit from parallel execution
.on(&quot;startup&quot;, |_ctx| Box::pin(async move {
    database::migrate().await?;  // Can run in parallel with other I/O
    Ok(())
}))

// âŒ Avoid: CPU-intensive work that doesn't benefit from parallelism
.on(&quot;startup&quot;, |_ctx| Box::pin(async move {
    // Heavy CPU work - consider moving to background task
    expensive_computation();
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#performance-monitoring" id="performance-monitoring"><h3>Performance Monitoring</h3></a>
<a class="header" href="print.html#runtime-performance-metrics" id="runtime-performance-metrics"><h4>Runtime Performance Metrics</h4></a>
<p>Enable debug logging to monitor handler performance:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = RustF::new()
    .event_config(EventEmitterConfig::parallel()
        .with_debug_logging(true));  // Enable in development

// Console output:
// [INFO]  Emitting event: 'startup' (parallel: true)
// [DEBUG] Executing 3 handler(s) for 'startup' at priority -100 (parallel: true)
// [DEBUG] Handler 1 completed in 145ms
// [DEBUG] Handler 2 completed in 203ms 
// [DEBUG] Event 'startup' executed 3 handler(s) with 0 error(s)
#}</code></pre></pre>
<a class="header" href="print.html#production-monitoring" id="production-monitoring"><h4>Production Monitoring</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
.on(&quot;ready&quot;, |ctx| Box::pin(async move {
    let start = std::time::Instant::now();
    
    // Your handler logic here
    initialize_services().await?;
    
    let duration = start.elapsed();
    if duration &gt; Duration::from_millis(1000) {
        log::warn!(&quot;Slow handler execution: {}ms&quot;, duration.as_millis());
    }
    
    Ok(())
}))
#}</code></pre></pre>
<a class="header" href="print.html#performance-best-practices" id="performance-best-practices"><h3>Performance Best Practices</h3></a>
<ol>
<li><strong>Keep Handlers Fast</strong>: Event handlers block application startup</li>
<li><strong>Use Parallel Execution</strong>: Default configuration optimizes for production</li>
<li><strong>Group by Priority</strong>: Related handlers at same priority execute concurrently</li>
<li><strong>Set Appropriate Timeouts</strong>: Prevent runaway handlers from hanging startup</li>
<li><strong>Monitor in Production</strong>: Track handler execution times</li>
<li><strong>Defer Heavy Work</strong>: Move non-essential tasks to background jobs</li>
<li><strong>Disable Debug Logging</strong>: Reduces overhead in production</li>
</ol>
<a class="header" href="print.html#performance-anti-patterns" id="performance-anti-patterns"><h3>Performance Anti-Patterns</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âŒ Bad: Synchronous blocking operations
.on(&quot;startup&quot;, |_ctx| Box::pin(async move {
    std::thread::sleep(Duration::from_secs(5));  // Blocks executor!
    Ok(())
}))

// âœ… Good: Async operations
.on(&quot;startup&quot;, |_ctx| Box::pin(async move {
    tokio::time::sleep(Duration::from_secs(5)).await;  // Non-blocking
    Ok(())
}))

// âŒ Bad: Sequential chains that could be parallel
.on_priority(&quot;startup&quot;, 1, handler_a)
.on_priority(&quot;startup&quot;, 2, handler_b)  // Must wait for handler_a
.on_priority(&quot;startup&quot;, 3, handler_c)  // Must wait for handler_b

// âœ… Good: Parallel execution when possible
.on(&quot;startup&quot;, handler_a)  // All execute in parallel
.on(&quot;startup&quot;, handler_b)  
.on(&quot;startup&quot;, handler_c)
#}</code></pre></pre>
<hr />
<a class="header" href="print.html#summary-6" id="summary-6"><h2>Summary</h2></a>
<p>RustF's event system provides a powerful, Total.js-inspired approach to application lifecycle management with advanced parallel execution capabilities:</p>
<p>âœ… <strong>Familiar Syntax</strong> - Total.js-style <code>ON('ready', handler)</code> patterns<br />
âœ… <strong>Complete Lifecycle</strong> - Events for every stage of application startup<br />
âœ… <strong>Parallel Execution</strong> - Concurrent handler execution with 4x+ performance improvements<br />
âœ… <strong>Built-in Handlers</strong> - Ready-to-use handlers for common tasks<br />
âœ… <strong>Priority Control</strong> - Fine-grained execution order management with parallel optimization<br />
âœ… <strong>Performance Optimized</strong> - Fast-path execution, timeout protection, and error isolation<br />
âœ… <strong>Type Safety</strong> - Full compile-time checking with excellent error messages<br />
âœ… <strong>Auto-Discovery</strong> - Automatic handler registration from your codebase<br />
âœ… <strong>Rich Context</strong> - Comprehensive context with config, environment, and utilities<br />
âœ… <strong>Production Ready</strong> - Configurable performance settings and comprehensive monitoring</p>
<a class="header" href="print.html#related-topics-3" id="related-topics-3"><h2>Related Topics</h2></a>
<ul>
<li><a href="../api-reference/context.md">API Reference: Context</a> - Context API documentation</li>
<li><a href="../examples/README.md">Examples</a> - Practical examples and tutorials</li>
<li><a href="workers.md">Workers</a> - Background job processing</li>
<li><a href="modules.md">Modules</a> - Shared business logic modules</li>
</ul>
<a class="header" href="print.html#rustf-module-system-user-guide" id="rustf-module-system-user-guide"><h1>RustF Module System User Guide</h1></a>
<p><strong>Complete documentation based on actual framework implementation</strong></p>
<a class="header" href="print.html#overview-12" id="overview-12"><h2>Overview</h2></a>
<p>RustF provides a comprehensive module system for organizing business logic, services, and reusable components. The system combines standard Rust module patterns with an optional <code>SharedModule</code> trait and a Total.js-style global MODULE accessor for singleton services. Modules follow clean architecture principles, separating business logic from HTTP request handling.</p>
<a class="header" href="print.html#key-concepts" id="key-concepts"><h3>Key Concepts</h3></a>
<ul>
<li><strong>Standard Rust Modules</strong> - Uses regular Rust module system with <code>use</code> statements for direct instantiation</li>
<li><strong>Global MODULE System</strong> - Total.js-style singleton access via <code>MODULE::get_typed::&lt;T&gt;()</code> for shared services</li>
<li><strong>Auto-Discovery</strong> - Automatic module scanning with <code>auto_modules!()</code> macro at compile time</li>
<li><strong>SharedModule Trait</strong> - Optional trait for lifecycle management and type-safe registration</li>
<li><strong>Business Logic Separation</strong> - Controllers handle HTTP, modules handle business logic</li>
<li><strong>Flexible Access Patterns</strong> - Choose between direct instantiation or singleton access based on needs</li>
</ul>
<a class="header" href="print.html#module-organization" id="module-organization"><h2>Module Organization</h2></a>
<a class="header" href="print.html#directory-structure-1" id="directory-structure-1"><h3>Directory Structure</h3></a>
<pre><code>src/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ user_service.rs      # User business logic
â”‚   â”œâ”€â”€ email_service.rs     # Email operations
â”‚   â”œâ”€â”€ payment_service.rs   # Payment processing
â”‚   â””â”€â”€ validation_utils.rs  # Utility functions
â”œâ”€â”€ controllers/             # HTTP handlers
â”œâ”€â”€ models/                  # Data models
â””â”€â”€ _modules.rs             # Auto-generated (DO NOT EDIT)
</code></pre>
<a class="header" href="print.html#module-types" id="module-types"><h3>Module Types</h3></a>
<p>The framework recognizes four types of modules:</p>
<ol>
<li><strong>Services</strong> - Stateful business logic with side effects (database operations, external API calls)</li>
<li><strong>Utilities</strong> - Stateless pure functions for data transformation and validation</li>
<li><strong>Helpers</strong> - Template and view helper functions</li>
<li><strong>Traits</strong> - Custom trait definitions and interfaces</li>
</ol>
<a class="header" href="print.html#global-module-system-new" id="global-module-system-new"><h2>Global MODULE System (New)</h2></a>
<p>RustF provides a Total.js-style global MODULE system for singleton access to shared services:</p>
<a class="header" href="print.html#overview-13" id="overview-13"><h3>Overview</h3></a>
<p>The MODULE system enables global access to registered modules without passing them through Context or using dependency injection. This is ideal for stateful services that should have a single instance across the entire application.</p>
<a class="header" href="print.html#basic-usage-6" id="basic-usage-6"><h3>Basic Usage</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Access modules globally anywhere in your application
let email = MODULE::get_typed::&lt;EmailService&gt;()?;
let cache = MODULE::get_typed::&lt;CacheService&gt;()?;

// Check if a module is registered
if MODULE::exists::&lt;EmailService&gt;() {
    let email = MODULE::get_typed::&lt;EmailService&gt;()?;
    email.send_notification(&quot;user@example.com&quot;).await?;
}

// Name-based access for dynamic scenarios
if let Some(service) = MODULE::get(&quot;EmailService&quot;) {
    // Use the service dynamically
}

// List all registered modules (useful for debugging)
let modules = MODULE::list();
for (name, module_type) in modules {
    println!(&quot;Module: {} ({})&quot;, name, module_type);
}
#}</code></pre></pre>
<a class="header" href="print.html#when-to-use-module-registration" id="when-to-use-module-registration"><h3>When to Use MODULE Registration</h3></a>
<p><strong>Good candidates for MODULE (singleton pattern):</strong></p>
<ul>
<li><strong>Database Connection Pools</strong> - Expensive to create, should be shared</li>
<li><strong>Cache Services</strong> - In-memory caches, Redis connections</li>
<li><strong>Email/SMS Services</strong> - Configured once, used everywhere</li>
<li><strong>WebSocket Managers</strong> - Track all active connections</li>
<li><strong>Rate Limiters</strong> - Shared request counters</li>
<li><strong>Background Job Queues</strong> - Single task scheduler</li>
<li><strong>Metrics Collectors</strong> - Application-wide statistics</li>
</ul>
<p><strong>Use direct instantiation for:</strong></p>
<ul>
<li><strong>Stateless Utilities</strong> - Pure functions, no shared state</li>
<li><strong>Request-Specific Services</strong> - Need new instance per request</li>
<li><strong>Simple Validators</strong> - Lightweight, no configuration</li>
<li><strong>View Helpers</strong> - Template formatting functions</li>
</ul>
<a class="header" href="print.html#registering-modules-for-global-access" id="registering-modules-for-global-access"><h3>Registering Modules for Global Access</h3></a>
<p>To enable MODULE access, register your modules during app initialization:</p>
<pre><pre class="playpen"><code class="language-rust">// src/main.rs
use rustf::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::new()
        .controllers(auto_controllers!())
        
        // Option 1: Auto-discovery (requires install() function in each module)
        .modules_from(auto_modules!())
        
        // Option 2: Manual registration for specific modules
        .modules_from(|registry| {
            use crate::modules::{
                email_service::EmailService,
                cache_service::CacheService,
                database_pool::DatabasePool,
            };
            
            // These become singletons accessible via MODULE
            registry.register(EmailService::new());
            registry.register(CacheService::new());
            registry.register(DatabasePool::new());
        })
        
        .start().await
}
</code></pre></pre>
<a class="header" href="print.html#usage-patterns-comparison" id="usage-patterns-comparison"><h3>Usage Patterns Comparison</h3></a>
<a class="header" href="print.html#pattern-1-direct-instantiation-simple-stateless" id="pattern-1-direct-instantiation-simple-stateless"><h4>Pattern 1: Direct Instantiation (Simple, Stateless)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Best for stateless utilities and simple services
use crate::modules::validation_utils::ValidationUtils;

async fn handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Create new instance when needed
    let validator = ValidationUtils::new();
    
    if !validator.is_valid_email(&quot;user@example.com&quot;) {
        return ctx.throw400(Some(&quot;Invalid email&quot;));
    }
    
    ctx.json(json!({&quot;status&quot;: &quot;valid&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#pattern-2-global-module-access-singleton-stateful" id="pattern-2-global-module-access-singleton-stateful"><h4>Pattern 2: Global MODULE Access (Singleton, Stateful)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Best for shared resources and configured services
async fn handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Access singleton instance
    let email_service = MODULE::get_typed::&lt;EmailService&gt;()?;
    let cache = MODULE::get_typed::&lt;CacheService&gt;()?;
    
    // Check cache first
    if let Some(cached) = cache.get(&quot;user:123&quot;).await {
        return ctx.json(cached);
    }
    
    // Send email using shared service
    email_service.send_welcome(&quot;user@example.com&quot;).await?;
    
    ctx.json(json!({&quot;status&quot;: &quot;sent&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#pattern-3-hybrid-approach-best-of-both" id="pattern-3-hybrid-approach-best-of-both"><h4>Pattern 3: Hybrid Approach (Best of Both)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use crate::modules::{user_service, validation_utils};

async fn handler(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Stateless utility - direct instantiation
    let validator = validation_utils::ValidationUtils::new();
    
    // Stateful service - could use MODULE if registered
    let email = if MODULE::exists::&lt;EmailService&gt;() {
        // Use singleton if available
        MODULE::get_typed::&lt;EmailService&gt;()?
    } else {
        // Fall back to direct instantiation
        &amp;email_service::EmailService::new()
    };
    
    // Business logic...
    email.send_notification(&quot;user@example.com&quot;).await?;
    
    ctx.json(json!({&quot;status&quot;: &quot;processed&quot;}))
}
#}</code></pre></pre>
<a class="header" href="print.html#creating-modules" id="creating-modules"><h2>Creating Modules</h2></a>
<a class="header" href="print.html#basic-module-structure" id="basic-module-structure"><h3>Basic Module Structure</h3></a>
<p>Every module is a standard Rust module with an optional <code>install()</code> function for auto-discovery:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/user_service.rs
use rustf::prelude::*;

#[derive(Debug)]
pub struct UserService {
    name: String,
}

impl UserService {
    pub fn new() -&gt; Self {
        Self {
            name: &quot;UserService&quot;.to_string(),
        }
    }
    
    /// Register a new user with business logic validation
    pub async fn register_user(&amp;self, email: &amp;str, password: &amp;str, profile: Value) -&gt; Result&lt;Value&gt; {
        // Input validation
        if email.is_empty() || !email.contains('@') {
            return Err(Error::validation(&quot;Invalid email format&quot;));
        }
        
        if password.len() &lt; 8 {
            return Err(Error::validation(&quot;Password must be at least 8 characters&quot;));
        }
        
        // Business logic implementation
        let user = json!({
            &quot;user_id&quot;: 1,
            &quot;email&quot;: email,
            &quot;created_at&quot;: chrono::Utc::now(),
            &quot;is_verified&quot;: false
        });
        
        Ok(user)
    }
}

// Required for auto-discovery
pub fn install() -&gt; UserService {
    UserService::new()
}
#}</code></pre></pre>
<a class="header" href="print.html#sharedmodule-implementation-optional" id="sharedmodule-implementation-optional"><h3>SharedModule Implementation (Optional)</h3></a>
<p>For advanced lifecycle management, implement the <code>SharedModule</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;
use async_trait::async_trait;

#[derive(Debug)]
pub struct EmailService {
    templates: HashMap&lt;String, String&gt;,
}

impl EmailService {
    pub fn new() -&gt; Self {
        let mut templates = HashMap::new();
        templates.insert(&quot;welcome&quot;.to_string(), 
            &quot;Welcome {{name}}! Please verify: {{link}}&quot;.to_string());
        
        Self { templates }
    }
    
    pub async fn send_verification_email(&amp;self, email: &amp;str, name: &amp;str, token: &amp;str) -&gt; Result&lt;Value&gt; {
        let template = self.templates.get(&quot;welcome&quot;).unwrap();
        let rendered = template
            .replace(&quot;{{name}}&quot;, name)
            .replace(&quot;{{link}}&quot;, &amp;format!(&quot;https://app.com/verify?token={}&quot;, token));
            
        // In production: integrate with email provider
        log::info!(&quot;Sending verification email to {}: {}&quot;, email, rendered);
        
        Ok(json!({
            &quot;email&quot;: email,
            &quot;status&quot;: &quot;sent&quot;,
            &quot;message_id&quot;: uuid::Uuid::new_v4()
        }))
    }
}

#[async_trait]
impl SharedModule for EmailService {
    fn name(&amp;self) -&gt; &amp;'static str {
        &quot;EmailService&quot;
    }
    
    fn module_type(&amp;self) -&gt; SharedModuleType {
        SharedModuleType::Service
    }
    
    fn as_any(&amp;self) -&gt; &amp;dyn std::any::Any {
        self
    }
    
    async fn initialize(&amp;self) -&gt; Result&lt;()&gt; {
        log::info!(&quot;EmailService initialized with {} templates&quot;, self.templates.len());
        Ok(())
    }
}

pub fn install() -&gt; EmailService {
    EmailService::new()
}
#}</code></pre></pre>
<a class="header" href="print.html#utility-modules" id="utility-modules"><h3>Utility Modules</h3></a>
<p>For stateless utilities, use the convenience macro:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/validation_utils.rs
use rustf::prelude::*;

pub struct ValidationUtils;

impl ValidationUtils {
    /// Validate email format
    pub fn is_valid_email(email: &amp;str) -&gt; bool {
        email.contains('@') &amp;&amp; email.len() &gt; 5
    }
    
    /// Validate password strength
    pub fn is_strong_password(password: &amp;str) -&gt; bool {
        password.len() &gt;= 8 
            &amp;&amp; password.chars().any(|c| c.is_uppercase())
            &amp;&amp; password.chars().any(|c| c.is_lowercase())
            &amp;&amp; password.chars().any(|c| c.is_numeric())
    }
    
    /// Sanitize user input
    pub fn sanitize_input(input: &amp;str) -&gt; String {
        input.trim()
            .replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;)
            .replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)
            .replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;)
    }
}

// Use convenience macro for simple implementation
impl_shared_util!(ValidationUtils);

pub fn install() -&gt; ValidationUtils {
    ValidationUtils
}
#}</code></pre></pre>
<a class="header" href="print.html#module-discovery-and-registration" id="module-discovery-and-registration"><h2>Module Discovery and Registration</h2></a>
<a class="header" href="print.html#auto-discovery-with-auto_modules" id="auto-discovery-with-auto_modules"><h3>Auto-Discovery with <code>auto_modules!()</code></h3></a>
<p>The framework automatically discovers modules at compile time and optionally enables global MODULE access:</p>
<pre><pre class="playpen"><code class="language-rust">// src/main.rs
use rustf::prelude::*;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::new()
        .controllers(auto_controllers!())
        .models(auto_models!())
        .modules_from(auto_modules!())  // Enables global MODULE access
        .start().await
}
</code></pre></pre>
<p><strong>What happens during registration:</strong></p>
<ol>
<li><code>auto_modules!()</code> scans <code>src/modules/</code> directory at compile time</li>
<li>Each module's <code>install()</code> function is called to create an instance</li>
<li>Modules implementing <code>SharedModule</code> are registered in SharedRegistry</li>
<li><code>MODULE::init()</code> is called during app startup, enabling global access</li>
<li>Registered modules become singletons accessible via <code>MODULE::get_typed::&lt;T&gt;()</code></li>
</ol>
<a class="header" href="print.html#manual-module-access" id="manual-module-access"><h3>Manual Module Access</h3></a>
<p><strong>Recommended Pattern</strong>: Use standard Rust module system for accessing business logic:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/controllers/auth.rs
use rustf::prelude::*;
use crate::modules::{user_service, email_service};

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        POST &quot;/register&quot; =&gt; register_user,
        POST &quot;/login&quot; =&gt; login_user,
    ]
}

async fn register_user(ctx: Context) -&gt; Result&lt;Response&gt; {
    let form_data = ctx.body_form()?;
    let email = form_data.get(&quot;email&quot;).unwrap_or(&amp;String::new());
    let password = form_data.get(&quot;password&quot;).unwrap_or(&amp;String::new());
    
    // Access modules using standard Rust module system
    let user_svc = user_service::UserService::new();
    let email_svc = email_service::EmailService::new();
    
    // Business logic handled by modules
    match user_svc.register_user(email, password, json!({})).await {
        Ok(user) =&gt; {
            // Send verification email
            let _ = email_svc.send_verification_email(
                email, 
                &quot;New User&quot;, 
                &quot;verification_token_123&quot;
            ).await;
            
            ctx.flash_success(&quot;Registration successful! Check your email.&quot;);
            ctx.redirect(&quot;/login&quot;)
        }
        Err(e) =&gt; {
            ctx.flash_error(&amp;format!(&quot;Registration failed: {}&quot;, e));
            ctx.redirect(&quot;/register&quot;)
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#sharedregistry-pattern-automatic" id="sharedregistry-pattern-automatic"><h3>SharedRegistry Pattern (Automatic)</h3></a>
<p>The SharedRegistry is integrated with the RustF app and handles initialization automatically:</p>
<pre><pre class="playpen"><code class="language-rust">// src/main.rs
use rustf::prelude::*;

#[rustf::auto_discover]
#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let app = RustF::new()
        .controllers(auto_controllers!())
        .models(auto_models!())
        .modules_from(auto_modules!())  // Registers and initializes modules
        .start().await  // Calls initialize_all() automatically
}
</code></pre></pre>
<p><strong>What happens automatically:</strong></p>
<ol>
<li><code>auto_modules!()</code> scans <code>src/modules/</code> and calls each module's <code>install()</code> function</li>
<li>Modules implementing <code>SharedModule</code> trait are registered with the SharedRegistry</li>
<li><code>app.start()</code> calls <code>initialize_all()</code> on all registered modules</li>
<li>Modules are available throughout the application lifecycle</li>
</ol>
<a class="header" href="print.html#using-modules-in-controllers" id="using-modules-in-controllers"><h2>Using Modules in Controllers</h2></a>
<a class="header" href="print.html#pattern-1-direct-instantiation-simple" id="pattern-1-direct-instantiation-simple"><h3>Pattern 1: Direct Instantiation (Simple)</h3></a>
<p>Controllers create module instances directly for clear, simple code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/controllers/users.rs
use rustf::prelude::*;
use crate::modules::{user_service, validation_utils};

async fn create_user(ctx: Context) -&gt; Result&lt;Response&gt; {
    let form_data = ctx.body_form()?;
    let email = form_data.get(&quot;email&quot;).unwrap_or(&amp;String::new());
    let password = form_data.get(&quot;password&quot;).unwrap_or(&amp;String::new());
    
    // Use validation utilities
    if !validation_utils::ValidationUtils::is_valid_email(email) {
        ctx.flash_error(&quot;Invalid email format&quot;);
        return ctx.redirect(&quot;/users/new&quot;);
    }
    
    if !validation_utils::ValidationUtils::is_strong_password(password) {
        ctx.flash_error(&quot;Password must be at least 8 characters with mixed case and numbers&quot;);
        return ctx.redirect(&quot;/users/new&quot;);
    }
    
    // Use business service
    let user_svc = user_service::UserService::new();
    match user_svc.register_user(email, password, json!({})).await {
        Ok(user) =&gt; {
            ctx.flash_success(&quot;User created successfully!&quot;);
            ctx.redirect(&quot;/users&quot;)
        }
        Err(e) =&gt; {
            ctx.flash_error(&amp;format!(&quot;Failed to create user: {}&quot;, e));
            ctx.redirect(&quot;/users/new&quot;)
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#pattern-2-global-module-access-singleton" id="pattern-2-global-module-access-singleton"><h3>Pattern 2: Global MODULE Access (Singleton)</h3></a>
<p>Use MODULE for shared services that should have one instance:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/controllers/api.rs
use rustf::prelude::*;

async fn process_order(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Access singleton services via MODULE
    let cache = MODULE::get_typed::&lt;CacheService&gt;()?;
    let email = MODULE::get_typed::&lt;EmailService&gt;()?;
    let payment = MODULE::get_typed::&lt;PaymentService&gt;()?;
    
    let order_data: Value = ctx.body_json()?;
    let order_id = order_data[&quot;id&quot;].as_str().unwrap_or(&quot;&quot;);
    
    // Check cache for duplicate order
    if cache.exists(&amp;format!(&quot;order:{}&quot;, order_id)).await {
        return ctx.throw400(Some(&quot;Duplicate order&quot;));
    }
    
    // Process payment using singleton service
    let payment_result = payment.process(
        order_data[&quot;amount&quot;].as_u64().unwrap_or(0),
        order_data[&quot;token&quot;].as_str().unwrap_or(&quot;&quot;)
    ).await?;
    
    // Send confirmation email
    email.send_order_confirmation(
        order_data[&quot;email&quot;].as_str().unwrap_or(&quot;&quot;),
        order_id
    ).await?;
    
    // Cache the order
    cache.set(&amp;format!(&quot;order:{}&quot;, order_id), &amp;order_data, 3600).await?;
    
    ctx.json(json!({
        &quot;status&quot;: &quot;processed&quot;,
        &quot;payment_id&quot;: payment_result.id
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#pattern-3-dependency-injection-pattern" id="pattern-3-dependency-injection-pattern"><h3>Pattern 3: Dependency Injection Pattern</h3></a>
<p>For applications requiring shared state, pass dependencies explicitly:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/controllers/api.rs
use rustf::prelude::*;
use crate::modules::user_service::UserService;

// Service container approach
pub struct ApiServices {
    user_service: UserService,
    // other services...
}

impl ApiServices {
    pub fn new() -&gt; Self {
        Self {
            user_service: UserService::new(),
        }
    }
}

async fn api_create_user(ctx: Context) -&gt; Result&lt;Response&gt; {
    let services = ApiServices::new();
    let request_data: Value = ctx.body_json()?;
    
    let email = request_data[&quot;email&quot;].as_str().unwrap_or(&quot;&quot;);
    let password = request_data[&quot;password&quot;].as_str().unwrap_or(&quot;&quot;);
    
    match services.user_service.register_user(email, password, json!({})).await {
        Ok(user) =&gt; ctx.json(json!({
            &quot;success&quot;: true,
            &quot;user&quot;: user
        })),
        Err(e) =&gt; ctx.json(json!({
            &quot;success&quot;: false,
            &quot;error&quot;: e.to_string()
        }))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#module-patterns-and-best-practices" id="module-patterns-and-best-practices"><h2>Module Patterns and Best Practices</h2></a>
<a class="header" href="print.html#1-service-pattern-stateful-business-logic" id="1-service-pattern-stateful-business-logic"><h3>1. Service Pattern (Stateful Business Logic)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/order_service.rs
use rustf::prelude::*;

#[derive(Debug)]
pub struct OrderService {
    config: OrderConfig,
}

#[derive(Debug)]
pub struct OrderConfig {
    pub max_items: usize,
    pub tax_rate: f64,
}

impl OrderService {
    pub fn new() -&gt; Self {
        Self {
            config: OrderConfig {
                max_items: 100,
                tax_rate: 0.08,
            },
        }
    }
    
    pub async fn create_order(&amp;self, user_id: i64, items: Vec&lt;OrderItem&gt;) -&gt; Result&lt;Order&gt; {
        // Business validation
        if items.len() &gt; self.config.max_items {
            return Err(Error::validation(&quot;Too many items in order&quot;));
        }
        
        // Calculate totals
        let subtotal: f64 = items.iter().map(|item| item.price * item.quantity as f64).sum();
        let tax = subtotal * self.config.tax_rate;
        let total = subtotal + tax;
        
        // Create order (in real app: save to database)
        let order = Order {
            id: 1,
            user_id,
            items,
            subtotal,
            tax,
            total,
            status: OrderStatus::Pending,
            created_at: chrono::Utc::now(),
        };
        
        log::info!(&quot;Created order {} for user {} (total: ${:.2})&quot;, order.id, user_id, total);
        Ok(order)
    }
    
    pub async fn calculate_shipping(&amp;self, order: &amp;Order, address: &amp;Address) -&gt; Result&lt;f64&gt; {
        // Shipping calculation logic
        let base_rate = 5.99;
        let weight_factor = order.items.len() as f64 * 0.5;
        Ok(base_rate + weight_factor)
    }
}

#[derive(Debug, Serialize)]
pub struct Order {
    pub id: i64,
    pub user_id: i64,
    pub items: Vec&lt;OrderItem&gt;,
    pub subtotal: f64,
    pub tax: f64,
    pub total: f64,
    pub status: OrderStatus,
    pub created_at: chrono::DateTime&lt;chrono::Utc&gt;,
}

pub fn install() -&gt; OrderService {
    OrderService::new()
}
#}</code></pre></pre>
<a class="header" href="print.html#2-utility-pattern-stateless-functions" id="2-utility-pattern-stateless-functions"><h3>2. Utility Pattern (Stateless Functions)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/text_utils.rs
use rustf::prelude::*;

pub struct TextUtils;

impl TextUtils {
    /// Convert text to URL-friendly slug
    pub fn slugify(text: &amp;str) -&gt; String {
        text.to_lowercase()
            .chars()
            .map(|c| if c.is_alphanumeric() { c } else { '-' })
            .collect::&lt;String&gt;()
            .split('-')
            .filter(|s| !s.is_empty())
            .collect::&lt;Vec&lt;&amp;str&gt;&gt;()
            .join(&quot;-&quot;)
    }
    
    /// Truncate text with ellipsis
    pub fn truncate(text: &amp;str, max_length: usize) -&gt; String {
        if text.len() &lt;= max_length {
            text.to_string()
        } else {
            format!(&quot;{}...&quot;, &amp;text[..max_length - 3])
        }
    }
    
    /// Extract mentions from text (@username)
    pub fn extract_mentions(text: &amp;str) -&gt; Vec&lt;String&gt; {
        let re = regex::Regex::new(r&quot;@(\w+)&quot;).unwrap();
        re.captures_iter(text)
            .map(|cap| cap[1].to_string())
            .collect()
    }
    
    /// Generate random string
    pub fn random_string(length: usize) -&gt; String {
        use rand::Rng;
        const CHARSET: &amp;[u8] = b&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;
        let mut rng = rand::thread_rng();
        (0..length)
            .map(|_| {
                let idx = rng.gen_range(0..CHARSET.len());
                CHARSET[idx] as char
            })
            .collect()
    }
}

impl_shared_util!(TextUtils);

pub fn install() -&gt; TextUtils {
    TextUtils
}
#}</code></pre></pre>
<a class="header" href="print.html#3-helper-pattern-view-helpers" id="3-helper-pattern-view-helpers"><h3>3. Helper Pattern (View Helpers)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/view_helpers.rs
use rustf::prelude::*;

pub struct ViewHelpers;

impl ViewHelpers {
    /// Format currency for display
    pub fn format_currency(amount: f64, currency: &amp;str) -&gt; String {
        match currency {
            &quot;USD&quot; =&gt; format!(&quot;${:.2}&quot;, amount),
            &quot;EUR&quot; =&gt; format!(&quot;â‚¬{:.2}&quot;, amount),
            &quot;GBP&quot; =&gt; format!(&quot;Â£{:.2}&quot;, amount),
            _ =&gt; format!(&quot;{:.2} {}&quot;, amount, currency),
        }
    }
    
    /// Format relative time (e.g., &quot;2 hours ago&quot;)
    pub fn time_ago(datetime: &amp;chrono::DateTime&lt;chrono::Utc&gt;) -&gt; String {
        let now = chrono::Utc::now();
        let duration = now.signed_duration_since(*datetime);
        
        if duration.num_days() &gt; 7 {
            datetime.format(&quot;%Y-%m-%d&quot;).to_string()
        } else if duration.num_days() &gt; 0 {
            format!(&quot;{} days ago&quot;, duration.num_days())
        } else if duration.num_hours() &gt; 0 {
            format!(&quot;{} hours ago&quot;, duration.num_hours())
        } else if duration.num_minutes() &gt; 0 {
            format!(&quot;{} minutes ago&quot;, duration.num_minutes())
        } else {
            &quot;Just now&quot;.to_string()
        }
    }
    
    /// Generate avatar URL from email
    pub fn gravatar_url(email: &amp;str, size: u32) -&gt; String {
        let hash = md5::compute(email.trim().to_lowercase().as_bytes());
        format!(&quot;https://www.gravatar.com/avatar/{:x}?s={}&amp;d=identicon&quot;, hash, size)
    }
    
    /// Pluralize words based on count
    pub fn pluralize(word: &amp;str, count: usize) -&gt; String {
        if count == 1 {
            word.to_string()
        } else if word.ends_with('y') {
            format!(&quot;{}ies&quot;, &amp;word[..word.len()-1])
        } else if word.ends_with(&amp;['s', 'x', 'z']) || word.ends_with(&quot;ch&quot;) || word.ends_with(&quot;sh&quot;) {
            format!(&quot;{}es&quot;, word)
        } else {
            format!(&quot;{}s&quot;, word)
        }
    }
}

impl_shared_helper!(ViewHelpers);

pub fn install() -&gt; ViewHelpers {
    ViewHelpers
}
#}</code></pre></pre>
<a class="header" href="print.html#advanced-features-3" id="advanced-features-3"><h2>Advanced Features</h2></a>
<a class="header" href="print.html#module-lifecycle-management" id="module-lifecycle-management"><h3>Module Lifecycle Management</h3></a>
<p>For modules requiring initialization and cleanup:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/cache_service.rs
use rustf::prelude::*;

#[derive(Debug)]
pub struct CacheService {
    redis_client: Option&lt;redis::Client&gt;,
    memory_cache: HashMap&lt;String, CacheEntry&gt;,
}

#[derive(Debug, Clone)]
struct CacheEntry {
    value: String,
    expires_at: chrono::DateTime&lt;chrono::Utc&gt;,
}

impl CacheService {
    pub fn new() -&gt; Self {
        Self {
            redis_client: None,
            memory_cache: HashMap::new(),
        }
    }
    
    pub async fn get(&amp;self, key: &amp;str) -&gt; Option&lt;String&gt; {
        // Try memory cache first
        if let Some(entry) = self.memory_cache.get(key) {
            if entry.expires_at &gt; chrono::Utc::now() {
                return Some(entry.value.clone());
            }
        }
        
        // Fall back to Redis if available
        None // Simplified for example
    }
    
    pub async fn set(&amp;mut self, key: &amp;str, value: &amp;str, ttl_seconds: u64) -&gt; Result&lt;()&gt; {
        let expires_at = chrono::Utc::now() + chrono::Duration::seconds(ttl_seconds as i64);
        self.memory_cache.insert(key.to_string(), CacheEntry {
            value: value.to_string(),
            expires_at,
        });
        Ok(())
    }
}

#[async_trait]
impl SharedModule for CacheService {
    fn name(&amp;self) -&gt; &amp;'static str {
        &quot;CacheService&quot;
    }
    
    fn module_type(&amp;self) -&gt; SharedModuleType {
        SharedModuleType::Service
    }
    
    fn as_any(&amp;self) -&gt; &amp;dyn std::any::Any {
        self
    }
    
    async fn initialize(&amp;self) -&gt; Result&lt;()&gt; {
        log::info!(&quot;CacheService initializing...&quot;);
        
        // Initialize Redis connection
        if let Ok(redis_url) = std::env::var(&quot;REDIS_URL&quot;) {
            match redis::Client::open(redis_url) {
                Ok(_client) =&gt; log::info!(&quot;Redis cache client initialized&quot;),
                Err(e) =&gt; log::warn!(&quot;Failed to initialize Redis: {}&quot;, e),
            }
        }
        
        log::info!(&quot;CacheService initialized successfully&quot;);
        Ok(())
    }
    
    async fn shutdown(&amp;self) -&gt; Result&lt;()&gt; {
        log::info!(&quot;CacheService shutting down...&quot;);
        // Cleanup operations would go here
        Ok(())
    }
}

pub fn install() -&gt; CacheService {
    CacheService::new()
}
#}</code></pre></pre>
<a class="header" href="print.html#cross-module-dependencies" id="cross-module-dependencies"><h3>Cross-Module Dependencies</h3></a>
<p>Modules can depend on each other using standard Rust patterns:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/notification_service.rs
use rustf::prelude::*;
use super::email_service::EmailService;

#[derive(Debug)]
pub struct NotificationService {
    email_service: EmailService,
}

impl NotificationService {
    pub fn new() -&gt; Self {
        Self {
            email_service: EmailService::new(),
        }
    }
    
    pub async fn send_welcome_notification(&amp;self, user_email: &amp;str, user_name: &amp;str) -&gt; Result&lt;()&gt; {
        // Send email notification
        self.email_service.send_verification_email(user_email, user_name, &quot;welcome_token&quot;).await?;
        
        // Could also send push notification, SMS, etc.
        log::info!(&quot;Welcome notification sent to {}&quot;, user_email);
        Ok(())
    }
    
    pub async fn send_order_confirmation(&amp;self, user_email: &amp;str, order_id: i64) -&gt; Result&lt;()&gt; {
        // Complex notification logic using email service
        let subject = format!(&quot;Order #{} confirmed&quot;, order_id);
        // Implementation details...
        Ok(())
    }
}

pub fn install() -&gt; NotificationService {
    NotificationService::new()
}
#}</code></pre></pre>
<a class="header" href="print.html#testing-modules" id="testing-modules"><h2>Testing Modules</h2></a>
<a class="header" href="print.html#unit-testing-services" id="unit-testing-services"><h3>Unit Testing Services</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/user_service.rs
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_register_user_valid() {
        let service = UserService::new();
        let result = service.register_user(
            &quot;test@example.com&quot;, 
            &quot;password123&quot;, 
            json!({})
        ).await;
        
        assert!(result.is_ok());
        let user = result.unwrap();
        assert_eq!(user[&quot;email&quot;], &quot;test@example.com&quot;);
        assert_eq!(user[&quot;is_verified&quot;], false);
    }
    
    #[tokio::test]
    async fn test_register_user_invalid_email() {
        let service = UserService::new();
        let result = service.register_user(
            &quot;invalid-email&quot;, 
            &quot;password123&quot;, 
            json!({})
        ).await;
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains(&quot;Invalid email format&quot;));
    }
    
    #[tokio::test]
    async fn test_register_user_weak_password() {
        let service = UserService::new();
        let result = service.register_user(
            &quot;test@example.com&quot;, 
            &quot;123&quot;, 
            json!({})
        ).await;
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains(&quot;at least 8 characters&quot;));
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#integration-testing" id="integration-testing"><h3>Integration Testing</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// tests/integration/module_tests.rs
use rustf::prelude::*;
use your_app::modules::{user_service, email_service};

#[tokio::test]
async fn test_user_registration_flow() {
    // Setup
    let user_svc = user_service::UserService::new();
    let email_svc = email_service::EmailService::new();
    
    // Test user registration
    let user_result = user_svc.register_user(
        &quot;integration@test.com&quot;,
        &quot;TestPassword123&quot;,
        json!({&quot;first_name&quot;: &quot;Test&quot;, &quot;last_name&quot;: &quot;User&quot;})
    ).await;
    
    assert!(user_result.is_ok());
    let user = user_result.unwrap();
    
    // Test email notification
    let email_result = email_svc.send_verification_email(
        &quot;integration@test.com&quot;,
        &quot;Test&quot;,
        &quot;test_token_123&quot;
    ).await;
    
    assert!(email_result.is_ok());
    let email_response = email_result.unwrap();
    assert_eq!(email_response[&quot;email&quot;][&quot;status&quot;], &quot;sent&quot;);
}
#}</code></pre></pre>
<a class="header" href="print.html#configuration-3" id="configuration-3"><h2>Configuration</h2></a>
<a class="header" href="print.html#environment-based-module-configuration" id="environment-based-module-configuration"><h3>Environment-Based Module Configuration</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/payment_service.rs
use rustf::prelude::*;

#[derive(Debug)]
pub struct PaymentService {
    stripe_key: Option&lt;String&gt;,
    sandbox_mode: bool,
}

impl PaymentService {
    pub fn new() -&gt; Self {
        let stripe_key = std::env::var(&quot;STRIPE_SECRET_KEY&quot;).ok();
        let sandbox_mode = std::env::var(&quot;PAYMENT_SANDBOX&quot;)
            .unwrap_or_else(|_| &quot;false&quot;.to_string())
            .parse()
            .unwrap_or(false);
            
        Self {
            stripe_key,
            sandbox_mode,
        }
    }
    
    pub async fn process_payment(&amp;self, amount: u64, token: &amp;str) -&gt; Result&lt;PaymentResult&gt; {
        if self.sandbox_mode {
            log::info!(&quot;SANDBOX: Processing payment of ${} with token {}&quot;, amount, token);
            return Ok(PaymentResult {
                id: &quot;sandbox_payment_123&quot;.to_string(),
                status: PaymentStatus::Succeeded,
                amount,
            });
        }
        
        // Real payment processing logic
        match &amp;self.stripe_key {
            Some(key) =&gt; {
                // Use Stripe API
                log::info!(&quot;Processing real payment with Stripe&quot;);
                // Implementation...
                Ok(PaymentResult {
                    id: &quot;real_payment_456&quot;.to_string(),
                    status: PaymentStatus::Succeeded,
                    amount,
                })
            }
            None =&gt; {
                Err(Error::configuration(&quot;STRIPE_SECRET_KEY not configured&quot;))
            }
        }
    }
}

pub fn install() -&gt; PaymentService {
    PaymentService::new()
}
#}</code></pre></pre>
<a class="header" href="print.html#module-documentation-patterns" id="module-documentation-patterns"><h2>Module Documentation Patterns</h2></a>
<a class="header" href="print.html#self-documenting-modules" id="self-documenting-modules"><h3>Self-Documenting Modules</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/analytics_service.rs
//! Analytics Service Module
//! 
//! Provides comprehensive analytics tracking and reporting functionality.
//! 
//! ## Features
//! - Event tracking with custom properties
//! - User behavior analytics
//! - Performance metrics collection
//! - A/B testing support
//! 
//! ## Usage
//! ```rust
//! use crate::modules::analytics_service::AnalyticsService;
//! 
//! let analytics = AnalyticsService::new();
//! analytics.track_event(&quot;user_signup&quot;, json!({&quot;source&quot;: &quot;web&quot;})).await?;
//! ```

use rustf::prelude::*;

/// Analytics service for tracking user events and system metrics
/// 
/// The AnalyticsService provides methods for tracking various types of events:
/// - User actions (clicks, page views, form submissions)
/// - System events (errors, performance metrics)  
/// - Custom business events (purchases, subscriptions)
#[derive(Debug)]
pub struct AnalyticsService {
    /// Whether analytics is enabled (can be disabled for testing)
    enabled: bool,
    /// Buffer for batching events before sending
    event_buffer: Vec&lt;AnalyticsEvent&gt;,
}

#[derive(Debug, Serialize)]
pub struct AnalyticsEvent {
    pub event_name: String,
    pub properties: Value,
    pub user_id: Option&lt;String&gt;,
    pub session_id: Option&lt;String&gt;,
    pub timestamp: chrono::DateTime&lt;chrono::Utc&gt;,
}

impl AnalyticsService {
    /// Create new analytics service
    /// 
    /// # Example
    /// ```rust
    /// let analytics = AnalyticsService::new();
    /// ```
    pub fn new() -&gt; Self {
        let enabled = std::env::var(&quot;ANALYTICS_ENABLED&quot;)
            .unwrap_or_else(|_| &quot;true&quot;.to_string())
            .parse()
            .unwrap_or(true);
            
        Self {
            enabled,
            event_buffer: Vec::new(),
        }
    }
    
    /// Track a user event with optional properties
    /// 
    /// # Arguments
    /// * `event_name` - Name of the event (e.g., &quot;page_view&quot;, &quot;button_click&quot;)
    /// * `properties` - Additional event data as JSON
    /// 
    /// # Example
    /// ```rust
    /// analytics.track_event(&quot;user_signup&quot;, json!({
    ///     &quot;source&quot;: &quot;web&quot;,
    ///     &quot;plan&quot;: &quot;premium&quot;
    /// })).await?;
    /// ```
    pub async fn track_event(&amp;mut self, event_name: &amp;str, properties: Value) -&gt; Result&lt;()&gt; {
        if !self.enabled {
            return Ok(());
        }
        
        let event = AnalyticsEvent {
            event_name: event_name.to_string(),
            properties,
            user_id: None, // Would be set from context in real implementation
            session_id: None,
            timestamp: chrono::Utc::now(),
        };
        
        self.event_buffer.push(event);
        
        // Flush buffer if it gets too large
        if self.event_buffer.len() &gt;= 100 {
            self.flush_events().await?;
        }
        
        Ok(())
    }
    
    /// Flush buffered events to analytics provider
    async fn flush_events(&amp;mut self) -&gt; Result&lt;()&gt; {
        if self.event_buffer.is_empty() {
            return Ok(());
        }
        
        log::info!(&quot;Flushing {} analytics events&quot;, self.event_buffer.len());
        
        // In real implementation: send to analytics provider
        // Google Analytics, Mixpanel, Segment, etc.
        
        self.event_buffer.clear();
        Ok(())
    }
}

pub fn install() -&gt; AnalyticsService {
    AnalyticsService::new()
}
#}</code></pre></pre>
<a class="header" href="print.html#error-handling-in-modules" id="error-handling-in-modules"><h2>Error Handling in Modules</h2></a>
<a class="header" href="print.html#consistent-error-patterns" id="consistent-error-patterns"><h3>Consistent Error Patterns</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/file_service.rs
use rustf::prelude::*;
use std::path::PathBuf;

#[derive(Debug)]
pub struct FileService {
    upload_path: PathBuf,
    max_file_size: usize,
}

impl FileService {
    pub fn new() -&gt; Self {
        let upload_path = std::env::var(&quot;UPLOAD_PATH&quot;)
            .unwrap_or_else(|_| &quot;uploads&quot;.to_string())
            .into();
            
        let max_file_size = std::env::var(&quot;MAX_FILE_SIZE&quot;)
            .unwrap_or_else(|_| &quot;10485760&quot;.to_string()) // 10MB default
            .parse()
            .unwrap_or(10485760);
            
        Self {
            upload_path,
            max_file_size,
        }
    }
    
    pub async fn save_upload(&amp;self, file_data: &amp;[u8], filename: &amp;str) -&gt; Result&lt;FileUploadResult&gt; {
        // Validation
        if file_data.is_empty() {
            return Err(Error::validation(&quot;File cannot be empty&quot;));
        }
        
        if file_data.len() &gt; self.max_file_size {
            return Err(Error::validation(&amp;format!(
                &quot;File size {} exceeds maximum allowed size {}&quot;, 
                file_data.len(), 
                self.max_file_size
            )));
        }
        
        // Security: validate filename
        if filename.contains(&quot;..&quot;) || filename.contains(&quot;/&quot;) || filename.contains(&quot;\\&quot;) {
            return Err(Error::security(&quot;Invalid filename&quot;));
        }
        
        // Generate unique filename
        let unique_filename = format!(&quot;{}_{}&quot;, 
            uuid::Uuid::new_v4(), 
            filename
        );
        
        let file_path = self.upload_path.join(&amp;unique_filename);
        
        // Ensure upload directory exists
        if let Some(parent) = file_path.parent() {
            std::fs::create_dir_all(parent)
                .map_err(|e| Error::filesystem(&amp;format!(&quot;Failed to create upload directory: {}&quot;, e)))?;
        }
        
        // Save file
        std::fs::write(&amp;file_path, file_data)
            .map_err(|e| Error::filesystem(&amp;format!(&quot;Failed to save file: {}&quot;, e)))?;
        
        log::info!(&quot;File saved: {} ({} bytes)&quot;, unique_filename, file_data.len());
        
        Ok(FileUploadResult {
            filename: unique_filename,
            path: file_path.to_string_lossy().to_string(),
            size: file_data.len(),
            mime_type: self.detect_mime_type(filename),
        })
    }
    
    fn detect_mime_type(&amp;self, filename: &amp;str) -&gt; String {
        match filename.split('.').last() {
            Some(&quot;jpg&quot;) | Some(&quot;jpeg&quot;) =&gt; &quot;image/jpeg&quot;.to_string(),
            Some(&quot;png&quot;) =&gt; &quot;image/png&quot;.to_string(),
            Some(&quot;gif&quot;) =&gt; &quot;image/gif&quot;.to_string(),
            Some(&quot;pdf&quot;) =&gt; &quot;application/pdf&quot;.to_string(),
            Some(&quot;txt&quot;) =&gt; &quot;text/plain&quot;.to_string(),
            _ =&gt; &quot;application/octet-stream&quot;.to_string(),
        }
    }
}

#[derive(Debug, Serialize)]
pub struct FileUploadResult {
    pub filename: String,
    pub path: String,
    pub size: usize,
    pub mime_type: String,
}

pub fn install() -&gt; FileService {
    FileService::new()
}
#}</code></pre></pre>
<a class="header" href="print.html#best-practices-summary" id="best-practices-summary"><h2>Best Practices Summary</h2></a>
<a class="header" href="print.html#1-module-design-principles" id="1-module-design-principles"><h3>1. Module Design Principles</h3></a>
<ul>
<li><strong>Single Responsibility</strong> - Each module handles one domain of business logic</li>
<li><strong>Clear Interfaces</strong> - Public methods are well-documented and consistent</li>
<li><strong>Error Handling</strong> - Use Result<T> for operations that can fail</li>
<li><strong>Configuration</strong> - Use environment variables for runtime configuration</li>
<li><strong>Logging</strong> - Include appropriate logging for debugging and monitoring</li>
</ul>
<a class="header" href="print.html#2-code-organization" id="2-code-organization"><h3>2. Code Organization</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Clear module structure
// src/modules/
//   â”œâ”€â”€ user_service.rs        # User domain logic
//   â”œâ”€â”€ order_service.rs       # Order processing
//   â”œâ”€â”€ payment_service.rs     # Payment handling
//   â”œâ”€â”€ email_service.rs       # Email operations
//   â””â”€â”€ validation_utils.rs    # Shared utilities

// âŒ Bad: Mixed concerns
// src/modules/
//   â””â”€â”€ everything_service.rs  # Handles users, orders, payments, etc.
#}</code></pre></pre>
<a class="header" href="print.html#3-dependencies-and-coupling" id="3-dependencies-and-coupling"><h3>3. Dependencies and Coupling</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Explicit dependencies
use crate::modules::email_service::EmailService;

pub struct UserService {
    email_service: EmailService,
}

// âŒ Bad: Hidden global state
pub struct UserService;

impl UserService {
    pub async fn register_user(&amp;self, email: &amp;str) -&gt; Result&lt;User&gt; {
        // Hidden dependency on global email service
        GLOBAL_EMAIL_SERVICE.send_welcome(email).await?;
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#4-testing-strategy" id="4-testing-strategy"><h3>4. Testing Strategy</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Testable design
impl PaymentService {
    pub fn new_for_testing() -&gt; Self {
        Self {
            stripe_key: None,
            sandbox_mode: true, // Always sandbox for tests
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_payment_processing() {
        let service = PaymentService::new_for_testing();
        // Test implementation
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#migration-and-compatibility" id="migration-and-compatibility"><h2>Migration and Compatibility</h2></a>
<a class="header" href="print.html#from-older-module-systems" id="from-older-module-systems"><h3>From Older Module Systems</h3></a>
<p>If migrating from other Rust web frameworks:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Actix Web style -&gt; RustF style
// Old:
// web::Data&lt;EmailService&gt;

// New:
use crate::modules::email_service::EmailService;
let email_service = EmailService::new();
#}</code></pre></pre>
<a class="header" href="print.html#framework-agnostic-modules" id="framework-agnostic-modules"><h3>Framework Agnostic Modules</h3></a>
<p>Keep business logic independent of RustF specifics:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// âœ… Good: Framework-independent core logic
impl UserService {
    pub async fn validate_and_create_user(&amp;self, email: &amp;str, password: &amp;str) -&gt; Result&lt;User&gt; {
        // Core business logic - no RustF dependencies
        // Can be used in CLI tools, tests, other frameworks
    }
}

// âŒ Bad: Tightly coupled to RustF
impl UserService {
    pub async fn create_user(&amp;self, ctx: &amp;Context) -&gt; Result&lt;Response&gt; {
        // Mixing business logic with HTTP concerns
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#framework-integration-status" id="framework-integration-status"><h2>Framework Integration Status</h2></a>
<p>Based on the current RustF implementation:</p>
<p>âœ… <strong>SharedModule Trait</strong> - Complete implementation in <code>src/shared.rs</code><br />
âœ… <strong>SharedRegistry</strong> - Full registry with lifecycle management<br />
âœ… <strong>Module Types</strong> - Service, Util, Helper, Trait categorization<br />
âœ… <strong>Auto-discovery macro</strong> - <code>auto_modules!()</code> in rustf-macros<br />
âœ… <strong>Standard Rust modules</strong> - Normal <code>use</code> statement access<br />
âœ… <strong>Lifecycle management</strong> - Initialize/shutdown methods<br />
âœ… <strong>App Integration</strong> - SharedRegistry integrated with RustF app builder pattern<br />
âœ… <strong>CLI Support</strong> - <code>rustf-cli new</code> creates <code>src/modules/</code> directory with README<br />
âœ… <strong>Global MODULE System</strong> - Total.js-style singleton access via <code>MODULE::get_typed::&lt;T&gt;()</code><br />
âœ… <strong>Type-Safe Access</strong> - Compile-time type checking for module access<br />
âœ… <strong>MODULE Initialization</strong> - Automatic during app startup via <code>MODULE::init()</code><br />
âœ… <strong>Dynamic Module Discovery</strong> - <code>MODULE::list()</code> and <code>MODULE::exists()</code> methods</p>
<a class="header" href="print.html#usage-recommendations" id="usage-recommendations"><h2>Usage Recommendations</h2></a>
<p><strong>For most applications:</strong></p>
<ol>
<li>Use <code>.modules_from(auto_modules!())</code> in your app setup to enable MODULE system</li>
<li>Create services as structs with <code>new()</code> constructors and <code>install()</code> functions</li>
<li>For stateless utilities: Use direct instantiation with <code>use</code> statements</li>
<li>For stateful services: Register and access via <code>MODULE::get_typed::&lt;T&gt;()</code></li>
</ol>
<p><strong>Choosing between direct instantiation and MODULE:</strong></p>
<ol>
<li>
<p><strong>Use MODULE for:</strong></p>
<ul>
<li>Database connection pools</li>
<li>Cache services (Redis, in-memory)</li>
<li>Configured services (email, SMS, payment)</li>
<li>Services with expensive initialization</li>
<li>Resources that should be shared application-wide</li>
</ul>
</li>
<li>
<p><strong>Use direct instantiation for:</strong></p>
<ul>
<li>Stateless utility functions</li>
<li>Request-specific services</li>
<li>Simple validators and formatters</li>
<li>Services that don't need configuration</li>
</ul>
</li>
</ol>
<p><strong>For simple modules that don't need lifecycle management:</strong></p>
<ol>
<li>Create basic structs with static methods</li>
<li>Use <code>impl_shared_util!()</code> macro for utilities</li>
<li>Access directly via standard Rust module imports</li>
</ol>
<p><strong>For complex services requiring singleton behavior:</strong></p>
<ol>
<li>Implement <code>SharedModule</code> trait with <code>initialize()</code> and <code>shutdown()</code> methods</li>
<li>Register with <code>.modules_from()</code> to enable MODULE access</li>
<li>Access via <code>MODULE::get_typed::&lt;T&gt;()</code> throughout the application</li>
<li>Services are automatically initialized during app startup</li>
</ol>
<p>The module system now provides full integration with the framework while maintaining flexibility for both simple and complex use cases, with clean separation of concerns between HTTP handling (controllers) and business logic (modules).</p>
<a class="header" href="print.html#summary-7" id="summary-7"><h2>Summary</h2></a>
<p>RustF's module system provides:</p>
<p>âœ… <strong>Clean Architecture</strong> - Separation of business logic from HTTP concerns<br />
âœ… <strong>Standard Rust Patterns</strong> - Uses familiar module system and traits<br />
âœ… <strong>Auto-Discovery</strong> - Compile-time scanning of module directories<br />
âœ… <strong>Type Safety</strong> - Compile-time validation of module interfaces<br />
âœ… <strong>Lifecycle Management</strong> - Optional initialize/shutdown methods<br />
âœ… <strong>Global MODULE System</strong> - Total.js-style singleton access for shared services<br />
âœ… <strong>Flexible Access Patterns</strong> - Support for both direct instantiation and singleton access<br />
âœ… <strong>Testing Support</strong> - Easy to unit test individual modules<br />
âœ… <strong>Resource Efficiency</strong> - Singleton pattern for expensive resources</p>
<p>The system strikes a balance between simplicity and power, offering multiple patterns:</p>
<ul>
<li><strong>Direct instantiation</strong> for simple, stateless utilities</li>
<li><strong>Global MODULE access</strong> for shared, stateful services</li>
<li><strong>Hybrid approaches</strong> for maximum flexibility</li>
</ul>
<p>This allows developers to organize business logic effectively while maintaining clean architecture principles that make applications maintainable, testable, and resource-efficient.</p>
<a class="header" href="print.html#rustf-cli-complete-guide" id="rustf-cli-complete-guide"><h1>RustF CLI Complete Guide</h1></a>
<p><strong>Comprehensive documentation for rustf-cli - The AI-friendly command-line tool for RustF framework</strong></p>
<a class="header" href="print.html#overview-14" id="overview-14"><h2>Overview</h2></a>
<p>RustF CLI is a powerful command-line tool designed for analyzing, managing, and developing RustF web applications. It provides comprehensive project analysis, database introspection, schema management, code generation, and includes built-in MCP (Model Context Protocol) server support for AI coding assistants.</p>
<a class="header" href="print.html#key-features-6" id="key-features-6"><h3>Key Features</h3></a>
<ul>
<li>ğŸ” <strong>Project Analysis</strong> - Deep inspection and validation of RustF applications</li>
<li>ğŸ¤– <strong>AI Agent Integration</strong> - MCP server with read-only mode for safe remote access</li>
<li>ğŸ—„ï¸ <strong>Database Tools</strong> - Multi-database support (PostgreSQL, MySQL, SQLite)</li>
<li>ğŸ“‹ <strong>Schema Management</strong> - YAML-based schema validation and model generation</li>
<li>ğŸš€ <strong>Code Generation</strong> - Create projects, controllers, modules, and events</li>
<li>ğŸ’¾ <strong>Automatic Backups</strong> - Safety backups when using <code>--force</code> flags</li>
<li>ğŸ“Š <strong>Performance Analysis</strong> - Benchmarking and cache statistics</li>
<li>ğŸ”’ <strong>Security First</strong> - Read-only mode by default for remote access</li>
</ul>
<a class="header" href="print.html#installation-2" id="installation-2"><h2>Installation</h2></a>
<p>The RustF CLI is included with the RustF framework:</p>
<pre><code class="language-bash"># Build from source
cd rustf-cli
cargo build --release

# The binary will be at: target/release/rustf-cli
# Add to PATH for system-wide access
export PATH=&quot;$PATH:/path/to/rustf/rustf-cli/target/release&quot;
</code></pre>
<a class="header" href="print.html#global-options" id="global-options"><h2>Global Options</h2></a>
<p>All commands support these global options:</p>
<pre><code class="language-bash">-P, --project &lt;PATH&gt;     # Specify project directory (defaults to current)
-v, --verbose            # Enable verbose output for debugging
-h, --help              # Show help information
-V, --version           # Show version information
</code></pre>
<a class="header" href="print.html#command-reference" id="command-reference"><h2>Command Reference</h2></a>
<p>The CLI provides 9 main commands, each with specific functionality:</p>
<a class="header" href="print.html#1-analyze---project-component-analysis" id="1-analyze---project-component-analysis"><h3>1. <code>analyze</code> - Project Component Analysis</h3></a>
<p>Analyze various aspects of your RustF project.</p>
<pre><code class="language-bash">rustf-cli analyze &lt;SUBCOMMAND&gt;
</code></pre>
<p><strong>Subcommands:</strong></p>
<ul>
<li>
<p><strong><code>backups</code></strong> - List and analyze project backups</p>
<pre><code class="language-bash">rustf-cli analyze backups [--detailed]
# Shows backups created by --force operations
</code></pre>
</li>
<li>
<p><strong><code>controllers</code></strong> - List controllers and their handlers</p>
<pre><code class="language-bash">rustf-cli analyze controllers [-n &lt;NAME&gt;]
</code></pre>
</li>
<li>
<p><strong><code>discover</code></strong> - Quick project discovery and overview</p>
<pre><code class="language-bash">rustf-cli analyze discover [-f &lt;FILTER&gt;]
</code></pre>
</li>
<li>
<p><strong><code>middleware</code></strong> - Analyze middleware chain and execution order</p>
<pre><code class="language-bash">rustf-cli analyze middleware [--conflicts]
</code></pre>
</li>
<li>
<p><strong><code>models</code></strong> - Discover and analyze models</p>
<pre><code class="language-bash">rustf-cli analyze models [--relationships]
</code></pre>
</li>
<li>
<p><strong><code>project</code></strong> - Complete project analysis</p>
<pre><code class="language-bash">rustf-cli analyze project [--detailed] [-f &lt;FORMAT&gt;]
# FORMAT: table (default), json, yaml
</code></pre>
</li>
<li>
<p><strong><code>routes</code></strong> - Display route tree with parameters</p>
<pre><code class="language-bash">rustf-cli analyze routes [--conflicts-only] [--validate]
</code></pre>
</li>
<li>
<p><strong><code>views</code></strong> - Analyze views and templates</p>
<pre><code class="language-bash">rustf-cli analyze views [--layout] [-n &lt;NAME&gt;] [--security]
</code></pre>
</li>
</ul>
<a class="header" href="print.html#2-db---database-operations" id="2-db---database-operations"><h3>2. <code>db</code> - Database Operations</h3></a>
<p>Introspect and manage database schemas.</p>
<pre><code class="language-bash">rustf-cli db &lt;SUBCOMMAND&gt;
</code></pre>
<p><strong>Subcommands:</strong></p>
<ul>
<li>
<p><strong><code>describe</code></strong> - Describe table structure</p>
<pre><code class="language-bash">rustf-cli db describe &lt;TABLE_NAME&gt; [--connection &lt;NAME&gt;] [--format &lt;FORMAT&gt;]
</code></pre>
</li>
<li>
<p><strong><code>diff-schema</code></strong> - Compare database with schema files</p>
<pre><code class="language-bash">rustf-cli db diff-schema &lt;SCHEMA_FILE&gt; [--connection &lt;NAME&gt;]
</code></pre>
</li>
<li>
<p><strong><code>export-data</code></strong> - Export table data</p>
<pre><code class="language-bash">rustf-cli db export-data &lt;TABLE_NAME&gt; [--format json|csv] [--limit &lt;N&gt;] [-o &lt;FILE&gt;]
</code></pre>
</li>
<li>
<p><strong><code>generate-schema</code></strong> - Generate YAML schemas from database</p>
<pre><code class="language-bash">rustf-cli db generate-schema [-o &lt;DIR&gt;] [--force] [--tables &lt;TABLE1,TABLE2&gt;]
# âš ï¸ --force creates backups in .rustf/backups/schemas/
</code></pre>
</li>
<li>
<p><strong><code>list-tables</code></strong> - List all database tables</p>
<pre><code class="language-bash">rustf-cli db list-tables [--metadata] [--format table|json]
</code></pre>
</li>
<li>
<p><strong><code>test-connection</code></strong> - Test database connectivity</p>
<pre><code class="language-bash">rustf-cli db test-connection [--connection &lt;NAME&gt;]
</code></pre>
</li>
</ul>
<a class="header" href="print.html#3-export---export-project-analysis" id="3-export---export-project-analysis"><h3>3. <code>export</code> - Export Project Analysis</h3></a>
<p>Export project analysis in various formats.</p>
<pre><code class="language-bash">rustf-cli export [-f &lt;FORMAT&gt;] [--include-code] [-o &lt;FILE&gt;]
# FORMAT: json (default), yaml, markdown
</code></pre>
<a class="header" href="print.html#4-new---create-new-components" id="4-new---create-new-components"><h3>4. <code>new</code> - Create New Components</h3></a>
<p>Generate new RustF components with proper structure.</p>
<pre><code class="language-bash">rustf-cli new &lt;SUBCOMMAND&gt;
</code></pre>
<p><strong>Subcommands:</strong></p>
<ul>
<li>
<p><strong><code>controller</code></strong> - Generate controller(s)</p>
<pre><code class="language-bash">rustf-cli new controller -n &lt;NAMES&gt; [--crud] [--routes]
# Example: rustf-cli new controller -n &quot;UserController,PostController&quot; --crud
</code></pre>
</li>
<li>
<p><strong><code>event</code></strong> - Generate event handler</p>
<pre><code class="language-bash">rustf-cli new event -n &lt;NAME&gt; [--lifecycle] [--custom]
</code></pre>
</li>
<li>
<p><strong><code>middleware</code></strong> - Generate middleware component</p>
<pre><code class="language-bash">rustf-cli new middleware -n &lt;NAME&gt; [--auth] [--logging] [-p &lt;PRIORITY&gt;]

Options:
  -n, --name &lt;NAME&gt;        # Middleware name (required)
  --auth                   # Include authentication example with protected paths
  --logging                # Include request/response logging example
  -p, --priority &lt;PRIORITY&gt; # Execution priority (default: 0)
                          # Negative = runs early, Positive = runs late

Examples:
  # Basic middleware
  rustf-cli new middleware -n rate-limit
  
  # Auth middleware with early execution
  rustf-cli new middleware -n auth --auth --priority=-50
  
  # Logging middleware (runs very early)
  rustf-cli new middleware -n request-logger --logging --priority=-100
</code></pre>
</li>
<li>
<p><strong><code>module</code></strong> - Generate service/module</p>
<pre><code class="language-bash">rustf-cli new module -n &lt;NAME&gt; [--shared] [--with-methods]
</code></pre>
</li>
<li>
<p><strong><code>project</code></strong> - Create new RustF project</p>
<pre><code class="language-bash">rustf-cli new project &lt;PROJECT_NAME&gt; [--path &lt;DIR&gt;] [--force]
# âš ï¸ --force creates backup of existing project in .rustf/backups/project/
</code></pre>
</li>
</ul>
<a class="header" href="print.html#5-perf---performance-analysis" id="5-perf---performance-analysis"><h3>5. <code>perf</code> - Performance Analysis</h3></a>
<p>Analyze application performance characteristics.</p>
<pre><code class="language-bash">rustf-cli perf &lt;SUBCOMMAND&gt;
</code></pre>
<p><strong>Subcommands:</strong></p>
<ul>
<li>
<p><strong><code>benchmark</code></strong> - Run performance benchmarks</p>
<pre><code class="language-bash">rustf-cli perf benchmark [--iterations &lt;N&gt;]
</code></pre>
</li>
<li>
<p><strong><code>cache-stats</code></strong> - Display cache statistics</p>
<pre><code class="language-bash">rustf-cli perf cache-stats
</code></pre>
</li>
<li>
<p><strong><code>stream</code></strong> - Streaming performance analysis</p>
<pre><code class="language-bash">rustf-cli perf stream [--memory-limit &lt;MB&gt;] [--chunk-size &lt;KB&gt;]
</code></pre>
</li>
</ul>
<a class="header" href="print.html#6-query---query-specific-items" id="6-query---query-specific-items"><h3>6. <code>query</code> - Query Specific Items</h3></a>
<p>Query specific components or metadata.</p>
<pre><code class="language-bash">rustf-cli query &lt;ITEM_TYPE&gt; &lt;ITEM_NAME&gt; [-f &lt;FORMAT&gt;]
# ITEM_TYPE: controller, handler, middleware, model, model-metadata, route, view
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-bash">rustf-cli query model-metadata User --format json
# Returns field hints, validation rules, and type information
</code></pre>
<a class="header" href="print.html#7-schema---schema-management" id="7-schema---schema-management"><h3>7. <code>schema</code> - Schema Management</h3></a>
<p>Manage YAML schemas and generate code.</p>
<pre><code class="language-bash">rustf-cli schema &lt;SUBCOMMAND&gt;
</code></pre>
<p><strong>Subcommands:</strong></p>
<ul>
<li>
<p><strong><code>analyze</code></strong> - Analyze schema structure</p>
<pre><code class="language-bash">rustf-cli schema analyze [-s &lt;SCHEMA_PATH&gt;]
</code></pre>
</li>
<li>
<p><strong><code>check-consistency</code></strong> - Verify schema/code consistency</p>
<pre><code class="language-bash">rustf-cli schema check-consistency
</code></pre>
</li>
<li>
<p><strong><code>generate</code></strong> - Generate code from schemas</p>
<pre><code class="language-bash">rustf-cli schema generate &lt;TARGET&gt; [--schema-path &lt;DIR&gt;] [-o &lt;DIR&gt;] [--force]
# TARGET: models, migrations, postgres, mysql, sqlite
# âš ï¸ --force creates backups in .rustf/backups/models/
</code></pre>
</li>
<li>
<p><strong><code>validate</code></strong> - Validate schema files</p>
<pre><code class="language-bash">rustf-cli schema validate [-p &lt;SCHEMA_PATH&gt;]
</code></pre>
</li>
<li>
<p><strong><code>watch</code></strong> - Auto-regenerate on schema changes</p>
<pre><code class="language-bash">rustf-cli schema watch [-s &lt;SCHEMA_PATH&gt;] [-o &lt;OUTPUT&gt;]
</code></pre>
</li>
</ul>
<a class="header" href="print.html#8-serve---mcp-server-management" id="8-serve---mcp-server-management"><h3>8. <code>serve</code> - MCP Server Management</h3></a>
<p>Start MCP server for AI agent integration.</p>
<pre><code class="language-bash">rustf-cli serve &lt;SUBCOMMAND&gt;
</code></pre>
<p><strong>Subcommands:</strong></p>
<ul>
<li>
<p><strong><code>start</code></strong> - Start MCP server</p>
<pre><code class="language-bash">rustf-cli serve start [OPTIONS]

Options:
  --allow-writes       # Enable write operations (default: false - READ-ONLY)
  --auto-port         # Find available port automatically
  --bind &lt;ADDRESS&gt;    # Bind address (default: 127.0.0.1)
  -n, --name &lt;NAME&gt;   # Instance name for multiple servers
  --port &lt;PORT&gt;       # Server port (default: 3000)
  -w, --watch         # Enable file watching
  --websocket         # Enable WebSocket support
</code></pre>
</li>
<li>
<p><strong><code>list</code></strong> - List running MCP servers</p>
<pre><code class="language-bash">rustf-cli serve list
</code></pre>
</li>
<li>
<p><strong><code>stop</code></strong> - Stop MCP server</p>
<pre><code class="language-bash">rustf-cli serve stop &lt;PORT&gt;
</code></pre>
</li>
</ul>
<a class="header" href="print.html#9-validate---project-validation" id="9-validate---project-validation"><h3>9. <code>validate</code> - Project Validation</h3></a>
<p>Validate project structure and conventions.</p>
<pre><code class="language-bash">rustf-cli validate [--fix] [-w, --watch]
# --fix: Auto-fix issues where possible
# --watch: Continuous validation mode
</code></pre>
<a class="header" href="print.html#ai-agent-integration-mcp-server" id="ai-agent-integration-mcp-server"><h2>AI Agent Integration (MCP Server)</h2></a>
<p>The MCP server enables AI agents to interact with your RustF project safely.</p>
<a class="header" href="print.html#starting-the-server" id="starting-the-server"><h3>Starting the Server</h3></a>
<p><strong>Safe Remote Access (Read-Only - Default):</strong></p>
<pre><code class="language-bash"># Start read-only server for remote access
rustf-cli serve start --bind 0.0.0.0 --port 8080

ğŸ”’ Starting MCP Server in READ-ONLY mode (safe for remote)
   Available: analyze, query, validate, db list/describe
   Blocked: generate, new, fix, migrate
</code></pre>
<p><strong>Local Development (With Write Access):</strong></p>
<pre><code class="language-bash"># Enable writes for local development only
rustf-cli serve start --allow-writes

ğŸ”“ Starting MCP Server with WRITE operations enabled
   Available: All CLI commands including generate, new, fix
</code></pre>
<a class="header" href="print.html#mcp-protocol-usage" id="mcp-protocol-usage"><h3>MCP Protocol Usage</h3></a>
<p>The server exposes a single <code>rustf_cli_execute</code> endpoint that wraps all CLI commands:</p>
<pre><code class="language-json">// Request format
{
  &quot;method&quot;: &quot;rustf_cli_execute&quot;,
  &quot;params&quot;: {
    &quot;command&quot;: &quot;analyze&quot;,
    &quot;subcommand&quot;: &quot;project&quot;,
    &quot;args&quot;: [&quot;--format&quot;, &quot;json&quot;]
  }
}

// Response format
{
  &quot;status&quot;: &quot;success&quot;,
  &quot;data&quot;: { /* command output */ },
  &quot;metadata&quot;: {
    &quot;command_executed&quot;: &quot;rustf-cli analyze project --format json&quot;,
    &quot;execution_time_ms&quot;: 145,
    &quot;read_only_mode&quot;: true,
    &quot;command_type&quot;: &quot;read_only&quot;
  }
}
</code></pre>
<a class="header" href="print.html#safety-features" id="safety-features"><h3>Safety Features</h3></a>
<ol>
<li><strong>Read-Only by Default</strong>: Server starts in read-only mode unless explicitly enabled</li>
<li><strong>Public Interface Warning</strong>: 5-second delay when enabling writes on public interfaces</li>
<li><strong>Command Classification</strong>: Automatic blocking of write operations in read-only mode</li>
<li><strong>Audit Logging</strong>: All blocked write attempts are logged</li>
</ol>
<a class="header" href="print.html#backup-system" id="backup-system"><h2>Backup System</h2></a>
<p>The CLI automatically creates backups when using <code>--force</code> flags to prevent data loss.</p>
<a class="header" href="print.html#how-it-works-1" id="how-it-works-1"><h3>How It Works</h3></a>
<p>When you use <code>--force</code> with commands that overwrite files:</p>
<ol>
<li><strong>Automatic Backup</strong>: Creates timestamped backup in <code>.rustf/backups/</code></li>
<li><strong>Organized Storage</strong>: Backups organized by type (models, schemas, project)</li>
<li><strong>Manual Restore</strong>: Intentionally manual to ensure conscious restoration</li>
</ol>
<a class="header" href="print.html#backup-locations" id="backup-locations"><h3>Backup Locations</h3></a>
<pre><code>.rustf/
â””â”€â”€ backups/
    â”œâ”€â”€ models/
    â”‚   â””â”€â”€ 2024-01-15T10-30-00Z/
    â”œâ”€â”€ schemas/
    â”‚   â””â”€â”€ 2024-01-15T11-00-00Z/
    â””â”€â”€ project/
        â””â”€â”€ 2024-01-15T12-00-00Z/
</code></pre>
<a class="header" href="print.html#managing-backups" id="managing-backups"><h3>Managing Backups</h3></a>
<pre><code class="language-bash"># List all backups
rustf-cli analyze backups

# Manual restoration (intentionally not automated)
cp -r .rustf/backups/models/2024-01-15T10-30-00Z/* src/models/
</code></pre>
<a class="header" href="print.html#common-workflows" id="common-workflows"><h2>Common Workflows</h2></a>
<a class="header" href="print.html#setting-up-a-new-project" id="setting-up-a-new-project"><h3>Setting Up a New Project</h3></a>
<pre><code class="language-bash"># 1. Create new project
rustf-cli new project my-app

# 2. Configure database in config.toml or .env
export DATABASE_URL=&quot;postgresql://user:pass@localhost/myapp&quot;

# 3. Generate schemas from existing database
rustf-cli db generate-schema -o schemas

# 4. Generate models from schemas
rustf-cli schema generate models -o src/models

# 5. Create essential middleware
rustf-cli new middleware -n auth --auth --priority=-50
rustf-cli new middleware -n request-logger --logging --priority=-100

# 6. Start development server
cargo run
</code></pre>
<a class="header" href="print.html#analyzing-an-existing-project" id="analyzing-an-existing-project"><h3>Analyzing an Existing Project</h3></a>
<pre><code class="language-bash"># 1. Quick discovery
rustf-cli analyze discover

# 2. Detailed project analysis
rustf-cli analyze project --detailed --format json

# 3. Check for issues
rustf-cli validate

# 4. Analyze routes for conflicts
rustf-cli analyze routes --conflicts-only
</code></pre>
<a class="header" href="print.html#database-first-development" id="database-first-development"><h3>Database-First Development</h3></a>
<pre><code class="language-bash"># 1. Test connection
rustf-cli db test-connection

# 2. List tables
rustf-cli db list-tables --metadata

# 3. Generate schemas from database
rustf-cli db generate-schema --force

# 4. Generate models
rustf-cli schema generate models --force

# 5. Verify consistency
rustf-cli schema check-consistency
</code></pre>
<a class="header" href="print.html#creating-middleware-components" id="creating-middleware-components"><h3>Creating Middleware Components</h3></a>
<pre><code class="language-bash"># 1. Generate authentication middleware
rustf-cli new middleware -n auth --auth --priority=-50

# 2. Generate logging middleware
rustf-cli new middleware -n request-logger --logging --priority=-100

# 3. Generate rate limiting middleware
rustf-cli new middleware -n rate-limit --priority=-75

# 4. Generate custom security headers middleware
rustf-cli new middleware -n security-headers --priority=100

# Note: Priority determines execution order:
# - Negative values run early (e.g., logging, auth)
# - Positive values run late (e.g., response modification)
# - Zero is default (normal priority)
</code></pre>
<a class="header" href="print.html#ai-agent-development" id="ai-agent-development"><h3>AI Agent Development</h3></a>
<pre><code class="language-bash"># For remote project analysis (safe)
rustf-cli serve start --bind 0.0.0.0

# For local AI-assisted development
rustf-cli serve start --allow-writes --watch

# AI agent can then connect and execute commands:
# - Analyze project structure
# - Query specific components
# - Generate new code (if writes enabled)
# - Validate changes
</code></pre>
<a class="header" href="print.html#output-formats" id="output-formats"><h2>Output Formats</h2></a>
<p>Most commands support multiple output formats:</p>
<ul>
<li><strong>table</strong> (default) - Human-readable tables</li>
<li><strong>json</strong> - Machine-readable JSON</li>
<li><strong>yaml</strong> - YAML format</li>
<li><strong>markdown</strong> - Documentation-ready markdown</li>
</ul>
<p>Example:</p>
<pre><code class="language-bash">rustf-cli analyze project --format json &gt; analysis.json
rustf-cli db list-tables --format yaml
</code></pre>
<a class="header" href="print.html#environment-variables-2" id="environment-variables-2"><h2>Environment Variables</h2></a>
<p>The CLI respects these environment variables:</p>
<pre><code class="language-bash">DATABASE_URL           # Database connection string
RUST_LOG              # Logging level (error, warn, info, debug, trace)
RUSTF_AUTH_TOKEN      # Authentication token for MCP server
</code></pre>
<a class="header" href="print.html#troubleshooting-7" id="troubleshooting-7"><h2>Troubleshooting</h2></a>
<a class="header" href="print.html#common-issues-3" id="common-issues-3"><h3>Common Issues</h3></a>
<ol>
<li>
<p><strong>Database Connection Failed</strong></p>
<ul>
<li>Check DATABASE_URL is set correctly</li>
<li>Verify database is running</li>
<li>Check network connectivity</li>
</ul>
</li>
<li>
<p><strong>Schema Generation Errors</strong></p>
<ul>
<li>Ensure schemas directory exists</li>
<li>Check file permissions</li>
<li>Validate YAML syntax</li>
</ul>
</li>
<li>
<p><strong>MCP Server Port In Use</strong></p>
<ul>
<li>Use <code>--auto-port</code> to find available port</li>
<li>Check with <code>rustf-cli serve list</code></li>
<li>Stop existing server with <code>rustf-cli serve stop &lt;PORT&gt;</code></li>
</ul>
</li>
<li>
<p><strong>Backup Recovery</strong></p>
<ul>
<li>Backups are in <code>.rustf/backups/</code></li>
<li>Use standard file copy commands</li>
<li>Check <code>.rustf/README.md</code> for instructions</li>
</ul>
</li>
</ol>
<a class="header" href="print.html#debug-mode" id="debug-mode"><h3>Debug Mode</h3></a>
<p>Enable verbose output for debugging:</p>
<pre><code class="language-bash">RUST_LOG=debug rustf-cli -v analyze project
</code></pre>
<a class="header" href="print.html#best-practices-19" id="best-practices-19"><h2>Best Practices</h2></a>
<ol>
<li><strong>Always Use Backups</strong>: When using <code>--force</code>, check <code>.rustf/backups/</code> afterward</li>
<li><strong>Read-Only for Remote</strong>: Never use <code>--allow-writes</code> on public interfaces</li>
<li><strong>Validate Often</strong>: Run <code>rustf-cli validate</code> before commits</li>
<li><strong>Schema-First</strong>: Keep schemas in version control</li>
<li><strong>Use Watch Mode</strong>: <code>rustf-cli schema watch</code> for auto-regeneration</li>
</ol>
<a class="header" href="print.html#version-history" id="version-history"><h2>Version History</h2></a>
<ul>
<li><strong>v0.1.0</strong> - Initial release with core functionality</li>
<li><strong>v0.2.0</strong> - Added MCP server and backup system</li>
<li><strong>v0.3.0</strong> - Component generation and improved safety features</li>
<li><strong>v0.3.1</strong> - Added middleware generation to <code>new</code> command with auth/logging templates</li>
</ul>
<a class="header" href="print.html#license-1" id="license-1"><h2>License</h2></a>
<p>Part of the RustF framework. See LICENSE file for details.</p>
<hr />
<a class="header" href="print.html#related-topics-4" id="related-topics-4"><h2>Related Topics</h2></a>
<ul>
<li><a href="../getting-started/README.md">Getting Started</a> - Framework overview and quick start</li>
<li><a href="../guides/database.md">Database Integration</a> - Database tools and model generation</li>
<li><a href="events.md">Event System</a> - Event system documentation</li>
<li><a href="../guides/schemas.md">Schemas &amp; Definitions</a> - Schema-driven development</li>
</ul>
<a class="header" href="print.html#api-reference-3" id="api-reference-3"><h1>API Reference</h1></a>
<p>Complete API documentation for all RustF framework components.</p>
<a class="header" href="print.html#available-apis" id="available-apis"><h2>Available APIs</h2></a>
<a class="header" href="print.html#a-hrefcontextmdcontext-apia" id="a-hrefcontextmdcontext-apia"><h3><a href="context.md">Context API</a></h3></a>
<p>The <code>Context</code> struct provides access to request/response functionality:</p>
<ul>
<li>Request data access</li>
<li>Response generation</li>
<li>Session management</li>
<li>Flash messages</li>
<li>Repository data</li>
<li>Client information</li>
</ul>
<a class="header" href="print.html#a-hrefmodelsmdmodel-apia" id="a-hrefmodelsmdmodel-apia"><h3><a href="models.md">Model API</a></h3></a>
<p>Database model operations and query building:</p>
<ul>
<li>Model creation and configuration</li>
<li>Query builder methods</li>
<li>Relationships</li>
<li>Transactions</li>
<li>Migrations</li>
</ul>
<a class="header" href="print.html#a-hrefroutingmdrouting-apia" id="a-hrefroutingmdrouting-apia"><h3><a href="routing.md">Routing API</a></h3></a>
<p>Route definition and registration:</p>
<ul>
<li>Route creation</li>
<li>Route handlers</li>
<li>Route parameters</li>
<li>Route groups</li>
<li>Auto-discovery</li>
</ul>
<a class="header" href="print.html#a-hrefutilitiesmdutilitiesa" id="a-hrefutilitiesmdutilitiesa"><h3><a href="utilities.md">Utilities</a></h3></a>
<p>Helper functions and utilities:</p>
<ul>
<li>String utilities</li>
<li>Date/time helpers</li>
<li>Validation functions</li>
<li>Type conversions</li>
<li>Common patterns</li>
</ul>
<a class="header" href="print.html#related-topics-5" id="related-topics-5"><h2>Related Topics</h2></a>
<ul>
<li><a href="../guides/controllers.md">Controllers Guide</a> - Using Context in controllers</li>
<li><a href="../guides/database.md">Database Guide</a> - Using models and queries</li>
<li><a href="../examples/README.md">Examples</a> - Practical API usage examples</li>
</ul>
<a class="header" href="print.html#context-api-reference" id="context-api-reference"><h1>Context API Reference</h1></a>
<p>The <code>Context</code> struct provides access to request data, response methods, sessions, and more. All route handlers receive a <code>&amp;mut Context</code> parameter.</p>
<a class="header" href="print.html#overview-15" id="overview-15"><h2>Overview</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Context {
    pub req: Request,           // HTTP request
    pub res: Option&lt;Response&gt;,   // HTTP response
    // ... internal fields
}
#}</code></pre></pre>
<a class="header" href="print.html#request-data-1" id="request-data-1"><h2>Request Data</h2></a>
<a class="header" href="print.html#url-parameters-1" id="url-parameters-1"><h3>URL Parameters</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get route parameter (e.g., /users/{id})
ctx.param(&quot;id&quot;) -&gt; Option&lt;&amp;str&gt;

// Typed parameter access
ctx.str_param(&quot;id&quot;) -&gt; Result&lt;String&gt;
ctx.int_param(&quot;id&quot;) -&gt; Result&lt;i32&gt;
ctx.str_param_or(&quot;id&quot;, &quot;default&quot;) -&gt; String
ctx.int_param_or(&quot;id&quot;, 0) -&gt; i32
#}</code></pre></pre>
<a class="header" href="print.html#query-parameters-1" id="query-parameters-1"><h3>Query Parameters</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get query parameter (e.g., ?page=2)
ctx.query(&quot;page&quot;) -&gt; Option&lt;&amp;str&gt;

// Typed query access
ctx.str_query(&quot;page&quot;) -&gt; Result&lt;String&gt;
ctx.int_query(&quot;page&quot;) -&gt; Result&lt;i32&gt;
ctx.bool_query(&quot;active&quot;) -&gt; Result&lt;bool&gt;
ctx.str_query_or(&quot;page&quot;, &quot;1&quot;) -&gt; String
ctx.int_query_or(&quot;limit&quot;, 10) -&gt; i32
ctx.bool_query_or(&quot;active&quot;, false) -&gt; bool
#}</code></pre></pre>
<a class="header" href="print.html#request-body" id="request-body"><h3>Request Body</h3></a>
<a class="header" href="print.html#json-body" id="json-body"><h4>JSON Body</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Parse JSON body into struct
let data: MyStruct = ctx.body_json()?;

// Get full body as JSON Value
let body: Value = ctx.full_body()?;
#}</code></pre></pre>
<a class="header" href="print.html#form-data" id="form-data"><h4>Form Data</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get form data as HashMap&lt;String, String&gt;
let form: HashMap&lt;String, String&gt; = ctx.body_form()?;

// Get form data with array support
let form: HashMap&lt;String, FormValue&gt; = ctx.body_form_data()?;

// Typed form parsing
#[derive(Deserialize)]
struct LoginForm {
    email: String,
    password: String,
}
let form: LoginForm = ctx.body_form_typed()?;

// Individual field access
let email = ctx.str_body(&quot;email&quot;)?;              // Required
let age = ctx.int_body(&quot;age&quot;)?;                  // Parse as integer
let active = ctx.bool_body(&quot;active&quot;)?;           // Parse as boolean
let name = ctx.str_body_or(&quot;name&quot;, &quot;Anonymous&quot;); // Optional with default
#}</code></pre></pre>
<a class="header" href="print.html#headers" id="headers"><h3>Headers</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get header value
ctx.header(&quot;Authorization&quot;) -&gt; Option&lt;&amp;str&gt;

// Add response header
ctx.add_header(&quot;X-Custom&quot;, &quot;value&quot;);
#}</code></pre></pre>
<a class="header" href="print.html#client-information-1" id="client-information-1"><h3>Client Information</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.ip() -&gt; String                    // Client IP address
ctx.user_agent() -&gt; Option&lt;&amp;str&gt;      // User agent string
ctx.is_mobile() -&gt; bool               // Mobile device detection
ctx.is_robot() -&gt; bool                // Bot/crawler detection
ctx.is_secure() -&gt; bool               // HTTPS request
ctx.is_xhr() -&gt; bool                  // AJAX request
ctx.language() -&gt; Option&lt;&amp;str&gt;        // Preferred language
ctx.referrer() -&gt; Option&lt;&amp;str&gt;        // Referrer URL
ctx.url() -&gt; &amp;str                     // Request URL path
ctx.path() -&gt; &amp;str                    // URL path
ctx.host() -&gt; Option&lt;&amp;str&gt;            // Host header
ctx.hostname(path: Option&lt;&amp;str&gt;) -&gt; String  // Full hostname URL
ctx.extension() -&gt; Option&lt;&amp;str&gt;       // File extension
#}</code></pre></pre>
<a class="header" href="print.html#response-methods-1" id="response-methods-1"><h2>Response Methods</h2></a>
<a class="header" href="print.html#json-response" id="json-response"><h3>JSON Response</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.json(data: impl Serialize) -&gt; Result&lt;()&gt;
#}</code></pre></pre>
<a class="header" href="print.html#html-response" id="html-response"><h3>HTML Response</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.html(content: impl Into&lt;String&gt;) -&gt; Result&lt;()&gt;
#}</code></pre></pre>
<a class="header" href="print.html#text-response" id="text-response"><h3>Text Response</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.text(content: impl Into&lt;String&gt;) -&gt; Result&lt;()&gt;
ctx.plain(text: impl Into&lt;String&gt;) -&gt; Result&lt;()&gt;
#}</code></pre></pre>
<a class="header" href="print.html#viewtemplate-response" id="viewtemplate-response"><h3>View/Template Response</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.view(template: &amp;str, data: Value) -&gt; Result&lt;()&gt;
#}</code></pre></pre>
<a class="header" href="print.html#redirect" id="redirect"><h3>Redirect</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.redirect(path: &amp;str) -&gt; Result&lt;()&gt;
#}</code></pre></pre>
<a class="header" href="print.html#http-error-responses" id="http-error-responses"><h3>HTTP Error Responses</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.throw400(message: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;  // Bad Request
ctx.throw401(message: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;  // Unauthorized
ctx.throw403(message: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;  // Forbidden
ctx.throw404(message: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;  // Not Found
ctx.throw409(message: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;  // Conflict
ctx.throw500(message: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;  // Internal Server Error
ctx.throw501(message: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;  // Not Implemented
ctx.view404() -&gt; Result&lt;()&gt;                        // Custom 404 view
#}</code></pre></pre>
<a class="header" href="print.html#other-responses" id="other-responses"><h3>Other Responses</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.empty() -&gt; Result&lt;()&gt;                          // 204 No Content
ctx.success(data: Option&lt;T&gt;) -&gt; Result&lt;()&gt;         // Success JSON response
ctx.status(status: StatusCode)                      // Set status code
#}</code></pre></pre>
<a class="header" href="print.html#file-responses" id="file-responses"><h3>File Responses</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Download file
ctx.file_download(path: P, filename: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;

// Inline file
ctx.file_inline(path: P) -&gt; Result&lt;()&gt;

// Binary data
ctx.binary(data: Vec&lt;u8&gt;, content_type: &amp;str) -&gt; Result&lt;()&gt;

// Stream response
ctx.stream(stream: impl Stream&lt;Item = Result&lt;Bytes&gt;&gt;, content_type: &amp;str) -&gt; Result&lt;()&gt;
#}</code></pre></pre>
<a class="header" href="print.html#session-management-1" id="session-management-1"><h2>Session Management</h2></a>
<a class="header" href="print.html#session-access" id="session-access"><h3>Session Access</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.session() -&gt; Option&lt;&amp;Session&gt;
ctx.has_session() -&gt; bool
ctx.require_session() -&gt; Result&lt;&amp;Session&gt;
ctx.require_auth() -&gt; Result&lt;&amp;Session&gt;
#}</code></pre></pre>
<a class="header" href="print.html#session-data" id="session-data"><h3>Session Data</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Set session value
ctx.session_set(key: &amp;str, value: T) -&gt; Result&lt;()&gt;

// Get session value
ctx.session_get(key: &amp;str) -&gt; Option&lt;T&gt;

// Remove session value
ctx.session_remove(key: &amp;str) -&gt; Option&lt;Value&gt;

// Clear all session data
ctx.session_clear()

// Flush session (save changes)
ctx.session_flush()

// Destroy session
ctx.session_destroy()
#}</code></pre></pre>
<a class="header" href="print.html#authentication" id="authentication"><h3>Authentication</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
ctx.login(user_id: i64) -&gt; Result&lt;()&gt;
ctx.logout() -&gt; Result&lt;()&gt;
#}</code></pre></pre>
<a class="header" href="print.html#flash-messages-2" id="flash-messages-2"><h2>Flash Messages</h2></a>
<p>Flash messages are one-time messages stored in the session.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Set flash message
ctx.flash(key: &amp;str, value: impl Serialize) -&gt; Result&lt;()&gt;

// Convenience methods
ctx.flash_success(message: impl Into&lt;String&gt;) -&gt; Result&lt;()&gt;
ctx.flash_error(message: impl Into&lt;String&gt;) -&gt; Result&lt;()&gt;
ctx.flash_info(message: impl Into&lt;String&gt;) -&gt; Result&lt;()&gt;
ctx.flash_warning(message: impl Into&lt;String&gt;) -&gt; Result&lt;()&gt;

// Get flash message
ctx.get_flash(key: &amp;str) -&gt; Option&lt;Value&gt;
ctx.get_all_flash() -&gt; HashMap&lt;String, Value&gt;

// Clear flash messages
ctx.flash_clear() -&gt; Result&lt;()&gt;
ctx.flash_clear_key(key: &amp;str) -&gt; Result&lt;()&gt;
#}</code></pre></pre>
<a class="header" href="print.html#repository-data" id="repository-data"><h2>Repository Data</h2></a>
<p>Repository data is handler-scoped data accessible in all views rendered within the handler.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Set repository data
ctx.repository_set(key: &amp;str, value: impl Into&lt;Value&gt;) -&gt; &amp;mut Self

// Get repository data
ctx.repository_get(key: &amp;str) -&gt; Option&lt;&amp;Value&gt;

// Clear all repository data
ctx.repository_clear() -&gt; &amp;mut Self
#}</code></pre></pre>
<a class="header" href="print.html#layout-management" id="layout-management"><h2>Layout Management</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Set layout for views
ctx.layout(name: &amp;str) -&gt; &amp;mut Self

// Use empty layout
ctx.layout(&quot;&quot;)
#}</code></pre></pre>
<a class="header" href="print.html#file-uploads" id="file-uploads"><h2>File Uploads</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get all uploaded files
ctx.files() -&gt; Result&lt;&amp;FileCollection&gt;

// Get specific uploaded file
ctx.file(field_name: &amp;str) -&gt; Result&lt;Option&lt;&amp;UploadedFile&gt;&gt;
#}</code></pre></pre>
<a class="header" href="print.html#middleware-data" id="middleware-data"><h2>Middleware Data</h2></a>
<p>Middleware can store data in the context for communication.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Store data
ctx.set(key: &amp;str, value: T) -&gt; Result&lt;()&gt;

// Retrieve data
ctx.get(key: &amp;str) -&gt; Option&lt;&amp;T&gt;

// Check if data exists
ctx.has_data(key: &amp;str) -&gt; bool
#}</code></pre></pre>
<a class="header" href="print.html#request-data-helper" id="request-data-helper"><h2>Request Data Helper</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get comprehensive request data
ctx.request_data() -&gt; Result&lt;RequestData&gt;
#}</code></pre></pre>
<a class="header" href="print.html#response-management" id="response-management"><h2>Response Management</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Set custom response
ctx.set_response(response: Response)

// Get response
ctx.get_response() -&gt; Option&lt;&amp;Response&gt;

// Take response
ctx.take_response() -&gt; Option&lt;Response&gt;
#}</code></pre></pre>
<a class="header" href="print.html#examples-3" id="examples-3"><h2>Examples</h2></a>
<a class="header" href="print.html#basic-handler" id="basic-handler"><h3>Basic Handler</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn get_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let user_id = ctx.int_param(&quot;id&quot;)?;
    // ... fetch user ...
    ctx.json(json!({&quot;user&quot;: user}))
}
#}</code></pre></pre>
<a class="header" href="print.html#form-handling" id="form-handling"><h3>Form Handling</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn create_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form: CreateUserForm = ctx.body_form_typed()?;
    // ... create user ...
    ctx.flash_success(&quot;User created!&quot;)?;
    ctx.redirect(&quot;/users&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#session-usage" id="session-usage"><h3>Session Usage</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn dashboard(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let user: User = ctx.session_get(&quot;user&quot;)
        .ok_or_else(|| ctx.throw401(Some(&quot;Login required&quot;)))?;
    
    ctx.repository_set(&quot;user&quot;, json!(user));
    ctx.view(&quot;/dashboard/index&quot;, json!({}))
}
#}</code></pre></pre>
<a class="header" href="print.html#model-api-reference" id="model-api-reference"><h1>Model API Reference</h1></a>
<p>RustF provides a database model system with query builders and type-safe database access.</p>
<a class="header" href="print.html#model-traits" id="model-traits"><h2>Model Traits</h2></a>
<a class="header" href="print.html#databasemodel" id="databasemodel"><h3>DatabaseModel</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait DatabaseModel: Send + Sync {
    fn table_name(&amp;self) -&gt; &amp;str;
    fn primary_key(&amp;self) -&gt; &amp;str;
}
#}</code></pre></pre>
<a class="header" href="print.html#modelquery" id="modelquery"><h3>ModelQuery</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait ModelQuery {
    fn find_by_id(&amp;self, id: i64) -&gt; Result&lt;Option&lt;Self&gt;&gt;;
    fn find_all(&amp;self) -&gt; Result&lt;Vec&lt;Self&gt;&gt;;
    fn create(&amp;mut self) -&gt; Result&lt;()&gt;;
    fn update(&amp;mut self) -&gt; Result&lt;()&gt;;
    fn delete(&amp;self) -&gt; Result&lt;()&gt;;
}
#}</code></pre></pre>
<a class="header" href="print.html#query-builder-1" id="query-builder-1"><h2>Query Builder</h2></a>
<a class="header" href="print.html#basic-queries-2" id="basic-queries-2"><h3>Basic Queries</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::models::ModelQuery;

// Find by ID
let user = Users::find_by_id(1)?;

// Find all
let users = Users::find_all()?;

// Find with conditions
let active_users = Users::query()
    .where_eq(&quot;is_active&quot;, true)
    .find()?;
#}</code></pre></pre>
<a class="header" href="print.html#where-clauses" id="where-clauses"><h3>Where Clauses</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Users::query()
    .where_eq(&quot;status&quot;, &quot;active&quot;)
    .where_ne(&quot;deleted&quot;, true)
    .where_gt(&quot;age&quot;, 18)
    .where_lt(&quot;created_at&quot;, &quot;2024-01-01&quot;)
    .where_like(&quot;name&quot;, &quot;%john%&quot;)
    .where_in(&quot;id&quot;, vec![1, 2, 3])
    .find()?;
#}</code></pre></pre>
<a class="header" href="print.html#ordering" id="ordering"><h3>Ordering</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Users::query()
    .order_by(&quot;created_at&quot;, OrderDirection::Desc)
    .find()?;
#}</code></pre></pre>
<a class="header" href="print.html#pagination-1" id="pagination-1"><h3>Pagination</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Users::query()
    .limit(10)
    .offset(20)
    .find()?;
#}</code></pre></pre>
<a class="header" href="print.html#aggregations-1" id="aggregations-1"><h3>Aggregations</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let count = Users::query().count()?;
let max_age = Users::query().max(&quot;age&quot;)?;
let avg_score = Users::query().avg(&quot;score&quot;)?;
#}</code></pre></pre>
<a class="header" href="print.html#model-operations" id="model-operations"><h2>Model Operations</h2></a>
<a class="header" href="print.html#create" id="create"><h3>Create</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut user = User {
    name: &quot;John&quot;.to_string(),
    email: &quot;john@example.com&quot;.to_string(),
    ..Default::default()
};
user.create()?;
#}</code></pre></pre>
<a class="header" href="print.html#update" id="update"><h3>Update</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut user = Users::find_by_id(1)?;
user.name = &quot;Jane&quot;.to_string();
user.update()?;
#}</code></pre></pre>
<a class="header" href="print.html#delete" id="delete"><h3>Delete</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let user = Users::find_by_id(1)?;
user.delete()?;
#}</code></pre></pre>
<a class="header" href="print.html#global-database-access-1" id="global-database-access-1"><h2>Global Database Access</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::db::DB;

// Execute raw SQL
DB::query(&quot;SELECT * FROM users WHERE id = ?&quot;, &amp;[&amp;1])?;

// Transaction
DB::transaction(|| {
    // ... operations ...
})?;
#}</code></pre></pre>
<a class="header" href="print.html#model-registration" id="model-registration"><h2>Model Registration</h2></a>
<p>Models are auto-discovered:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = RustF::new()
    .models(auto_models!());
#}</code></pre></pre>
<a class="header" href="print.html#examples-4" id="examples-4"><h2>Examples</h2></a>
<a class="header" href="print.html#complete-model-usage" id="complete-model-usage"><h3>Complete Model Usage</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Find user
let user = Users::find_by_id(1)?;

// Query with conditions
let active_users = Users::query()
    .where_eq(&quot;is_active&quot;, true)
    .order_by(&quot;created_at&quot;, OrderDirection::Desc)
    .limit(10)
    .find()?;

// Create new user
let mut new_user = User {
    name: &quot;Alice&quot;.to_string(),
    email: &quot;alice@example.com&quot;.to_string(),
    is_active: true,
    ..Default::default()
};
new_user.create()?;

// Update user
let mut user = Users::find_by_id(1)?;
user.name = &quot;Bob&quot;.to_string();
user.update()?;

// Delete user
let user = Users::find_by_id(1)?;
user.delete()?;
#}</code></pre></pre>
<a class="header" href="print.html#routing-api-reference" id="routing-api-reference"><h1>Routing API Reference</h1></a>
<p>RustF provides a clean routing system with the <code>routes!</code> macro and <code>Route</code> struct.</p>
<a class="header" href="print.html#route-definition" id="route-definition"><h2>Route Definition</h2></a>
<a class="header" href="print.html#the-routes-macro-1" id="the-routes-macro-1"><h3>The <code>routes!</code> Macro</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
routes![
    GET &quot;/path&quot; =&gt; handler_function,
    POST &quot;/path&quot; =&gt; handler_function,
    PUT &quot;/path/{id}&quot; =&gt; handler_function,
    DELETE &quot;/path/{id}&quot; =&gt; handler_function,
]
#}</code></pre></pre>
<a class="header" href="print.html#route-struct" id="route-struct"><h3>Route Struct</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Route {
    pub method: String,        // HTTP method
    pub path: String,          // URL pattern
    pub handler: RouteHandler,  // Handler function
}
#}</code></pre></pre>
<a class="header" href="print.html#routehandler-type" id="routehandler-type"><h3>RouteHandler Type</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub type RouteHandler = for&lt;'a&gt; fn(&amp;'a mut Context) 
    -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;()&gt;&gt; + Send + 'a&gt;&gt;;
#}</code></pre></pre>
<a class="header" href="print.html#manual-route-creation" id="manual-route-creation"><h2>Manual Route Creation</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::routing::Route;

// Create routes manually
Route::get(&quot;/users&quot;, handler)
Route::post(&quot;/users&quot;, handler)
Route::put(&quot;/users/{id}&quot;, handler)
Route::delete(&quot;/users/{id}&quot;, handler)
#}</code></pre></pre>
<a class="header" href="print.html#url-parameters-2" id="url-parameters-2"><h2>URL Parameters</h2></a>
<p>Routes support URL parameters using <code>{parameter}</code> syntax:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
routes![
    GET &quot;/users/{id}&quot; =&gt; get_user,
    GET &quot;/posts/{post_id}/comments/{comment_id}&quot; =&gt; get_comment,
]
#}</code></pre></pre>
<p>Access parameters in handlers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn get_user(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let user_id = ctx.param(&quot;id&quot;)?;
    // ...
}
#}</code></pre></pre>
<a class="header" href="print.html#route-registration" id="route-registration"><h2>Route Registration</h2></a>
<a class="header" href="print.html#auto-discovery-recommended-1" id="auto-discovery-recommended-1"><h3>Auto-Discovery (Recommended)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = RustF::new()
    .controllers(auto_controllers!());
#}</code></pre></pre>
<a class="header" href="print.html#manual-registration-2" id="manual-registration-2"><h3>Manual Registration</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = RustF::new()
    .controllers({
        let mut routes = Vec::new();
        routes.extend(controllers::home::install());
        routes.extend(controllers::users::install());
        routes
    });
#}</code></pre></pre>
<a class="header" href="print.html#controller-pattern-1" id="controller-pattern-1"><h2>Controller Pattern</h2></a>
<p>Every controller must have an <code>install()</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/&quot; =&gt; index,
        POST &quot;/submit&quot; =&gt; submit,
    ]
}
#}</code></pre></pre>
<a class="header" href="print.html#http-methods" id="http-methods"><h2>HTTP Methods</h2></a>
<p>Supported methods:</p>
<ul>
<li><code>GET</code> - Retrieve resource</li>
<li><code>POST</code> - Create resource</li>
<li><code>PUT</code> - Update resource</li>
<li><code>DELETE</code> - Delete resource</li>
</ul>
<a class="header" href="print.html#route-matching" id="route-matching"><h2>Route Matching</h2></a>
<p>Routes are matched in order of registration. First match wins.</p>
<a class="header" href="print.html#examples-5" id="examples-5"><h2>Examples</h2></a>
<a class="header" href="print.html#basic-routes" id="basic-routes"><h3>Basic Routes</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/&quot; =&gt; index,
        GET &quot;/about&quot; =&gt; about,
    ]
}
#}</code></pre></pre>
<a class="header" href="print.html#restful-routes" id="restful-routes"><h3>RESTful Routes</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET    &quot;/api/users&quot; =&gt; list_users,
        GET    &quot;/api/users/{id}&quot; =&gt; get_user,
        POST   &quot;/api/users&quot; =&gt; create_user,
        PUT    &quot;/api/users/{id}&quot; =&gt; update_user,
        DELETE &quot;/api/users/{id}&quot; =&gt; delete_user,
    ]
}
#}</code></pre></pre>
<a class="header" href="print.html#nested-routes" id="nested-routes"><h3>Nested Routes</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/controllers/api/users.rs
pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/api/users&quot; =&gt; list,
        GET &quot;/api/users/{id}&quot; =&gt; show,
    ]
}
#}</code></pre></pre>
<a class="header" href="print.html#rustf-utilities-u-user-guide" id="rustf-utilities-u-user-guide"><h1>RustF Utilities (U) User Guide</h1></a>
<a class="header" href="print.html#overview-16" id="overview-16"><h2>Overview</h2></a>
<p>RustF provides a global utilities system through the <code>U</code> module, offering commonly used functions for web development. Inspired by Total.js, it provides a convenient API for random generation, string processing, HTTP utilities, encoding, parsing, cryptographic hash functions, and more.</p>
<p>The utilities system supports two access patterns:</p>
<ul>
<li><strong>Direct access</strong>: <code>U::function_name()</code> for commonly used functions</li>
<li><strong>Namespaced access</strong>: <code>U::ModuleName::function_name()</code> for extended functionality</li>
</ul>
<a class="header" href="print.html#getting-started" id="getting-started"><h2>Getting Started</h2></a>
<p>Import and use the utilities:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;  // Includes U
// or
use rustf::U;

// Direct access - commonly used functions
let id = U::guid();
let encoded = U::encode(&quot;hello world&quot;);
let status = U::http_status(404); // &quot;Not Found&quot;
let hash = U::sha256(&quot;data&quot;);      // Secure hash function

// Namespaced access - extended functionality  
let slug = U::String::to_slug(&quot;Hello World!&quot;);
let html = U::Encoding::html_encode(&quot;&lt;script&gt;&quot;);
let duration = U::Parsing::parse_duration(&quot;1h&quot;, 0);
let md5_hash = U::Crypto::md5(&quot;data&quot;);  // Warning: Not secure
#}</code></pre></pre>
<a class="header" href="print.html#available-utilities" id="available-utilities"><h2>Available Utilities</h2></a>
<p>The RustF utilities system provides two access patterns:</p>
<a class="header" href="print.html#direct-access-functions-ufunction" id="direct-access-functions-ufunction"><h3>Direct Access Functions (U::function())</h3></a>
<p>These are the most commonly used functions available directly through <code>U::</code>:</p>
<table><thead><tr><th> Category </th><th> Function </th><th> Description </th><th> Example </th></tr></thead><tbody>
<tr><td> <strong>Random</strong> </td><td> <code>U::guid()</code> </td><td> Generate UUID without hyphens </td><td> <code>U::guid()</code> â†’ <code>&quot;a1b2c3d4e5f67890...&quot;</code> </td></tr>
<tr><td> </td><td> <code>U::random_string(len)</code> </td><td> Generate random alphanumeric string </td><td> <code>U::random_string(8)</code> â†’ <code>&quot;Kj8mN2pQ&quot;</code> </td></tr>
<tr><td> </td><td> <code>U::random_number(min, max)</code> </td><td> Generate random number in range </td><td> <code>U::random_number(1, 100)</code> â†’ <code>42</code> </td></tr>
<tr><td> <strong>HTTP</strong> </td><td> <code>U::http_status(code)</code> </td><td> Get HTTP status text </td><td> <code>U::http_status(404)</code> â†’ <code>&quot;Not Found&quot;</code> </td></tr>
<tr><td> </td><td> <code>U::etag(content)</code> </td><td> Generate ETag for content </td><td> <code>U::etag(&quot;hello&quot;)</code> â†’ <code>&quot;5d41402a...&quot;</code> </td></tr>
<tr><td> </td><td> <code>U::get_content_type(ext)</code> </td><td> Get MIME type by extension </td><td> <code>U::get_content_type(&quot;json&quot;)</code> â†’ <code>&quot;application/json&quot;</code> </td></tr>
<tr><td> <strong>Encoding</strong> </td><td> <code>U::encode(str)</code> </td><td> URL encode string </td><td> <code>U::encode(&quot;hello world&quot;)</code> â†’ <code>&quot;hello%20world&quot;</code> </td></tr>
<tr><td> </td><td> <code>U::decode(str)</code> </td><td> URL decode string </td><td> <code>U::decode(&quot;hello%20world&quot;)</code> â†’ <code>&quot;hello world&quot;</code> </td></tr>
<tr><td> </td><td> <code>U::btoa(str)</code> </td><td> Base64 encode </td><td> <code>U::btoa(&quot;hello&quot;)</code> â†’ <code>&quot;aGVsbG8=&quot;</code> </td></tr>
<tr><td> </td><td> <code>U::atob(str)</code> </td><td> Base64 decode </td><td> <code>U::atob(&quot;aGVsbG8=&quot;)</code> â†’ <code>&quot;hello&quot;</code> </td></tr>
<tr><td> <strong>String</strong> </td><td> <code>U::trim(str)</code> </td><td> Clean whitespace </td><td> <code>U::trim(&quot; hello &quot;)</code> â†’ <code>&quot;hello&quot;</code> </td></tr>
<tr><td> </td><td> <code>U::keywords(text, max, min_len)</code> </td><td> Extract keywords </td><td> <code>U::keywords(&quot;hello world&quot;, 10, 3)</code> â†’ <code>[&quot;hello&quot;, &quot;world&quot;]</code> </td></tr>
<tr><td> <strong>Parsing</strong> </td><td> <code>U::parse_bool(str, default)</code> </td><td> Parse boolean safely </td><td> <code>U::parse_bool(&quot;true&quot;, false)</code> â†’ <code>true</code> </td></tr>
<tr><td> </td><td> <code>U::parse_int(str, default)</code> </td><td> Parse integer safely </td><td> <code>U::parse_int(&quot;123&quot;, 0)</code> â†’ <code>123</code> </td></tr>
<tr><td> </td><td> <code>U::parse_float(str, default)</code> </td><td> Parse float safely </td><td> <code>U::parse_float(&quot;12.34&quot;, 0.0)</code> â†’ <code>12.34</code> </td></tr>
<tr><td> <strong>JSON</strong> </td><td> <code>U::get(obj, path)</code> </td><td> Get nested property </td><td> <code>U::get(&amp;data, &quot;user.name&quot;)</code> â†’ <code>Some(&amp;Value)</code> </td></tr>
<tr><td> </td><td> <code>U::set(obj, path, value)</code> </td><td> Set nested property </td><td> <code>U::set(&amp;mut data, &quot;user.name&quot;, json!(&quot;John&quot;))</code> </td></tr>
<tr><td> <strong>Geographic</strong> </td><td> <code>U::distance(lat1, lon1, lat2, lon2)</code> </td><td> Distance in kilometers </td><td> <code>U::distance(40.7, -74.0, 34.0, -118.2)</code> â†’ <code>3944.42</code> </td></tr>
<tr><td> <strong>Crypto</strong> </td><td> <code>U::md5(str)</code> </td><td> MD5 hash âš ï¸ Not secure </td><td> <code>U::md5(&quot;hello world&quot;)</code> â†’ <code>&quot;5eb63bbbe01...&quot;</code> </td></tr>
<tr><td> </td><td> <code>U::sha256(str)</code> </td><td> SHA256 hash (secure) </td><td> <code>U::sha256(&quot;hello world&quot;)</code> â†’ <code>&quot;b94d27b993...&quot;</code> </td></tr>
</tbody></table>
<p><strong>Total: 20 direct access functions</strong></p>
<a class="header" href="print.html#namespaced-access-functions-umodulefunction" id="namespaced-access-functions-umodulefunction"><h3>Namespaced Access Functions (U::Module::function())</h3></a>
<p>Extended functionality is available through nested modules:</p>
<a class="header" href="print.html#random-generation" id="random-generation"><h3>Random Generation</h3></a>
<a class="header" href="print.html#generate-uuids" id="generate-uuids"><h4>Generate UUIDs</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Generate a simple UUID (without hyphens) - Direct access
let id = U::guid();
println!(&quot;ID: {}&quot;, id); // e.g., &quot;a1b2c3d4e5f67890abcdef1234567890&quot;

// Generate UUID with hyphens - Extended access
let uuid = U::Random::generate_guid_with_hyphens();
println!(&quot;UUID: {}&quot;, uuid); // e.g., &quot;a1b2c3d4-e5f6-7890-abcd-ef1234567890&quot;
#}</code></pre></pre>
<a class="header" href="print.html#generate-random-strings" id="generate-random-strings"><h4>Generate Random Strings</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Generate random alphanumeric string - Direct access
let token = U::random_string(32);
println!(&quot;Token: {}&quot;, token); // e.g., &quot;Kj8mN2pQ5rT9wX3yZ7aB4cD6fG1hI0kL&quot;

// Use for session tokens, API keys, etc.
let api_key = U::random_string(64);
let session_id = U::random_string(16);

// Generate with custom character set - Extended access
let numeric_code = U::Random::generate_random_string_with_charset(6, &quot;0123456789&quot;);
let secure_token = U::Random::generate_secure_token(32); // Cryptographically secure
#}</code></pre></pre>
<a class="header" href="print.html#generate-random-numbers" id="generate-random-numbers"><h4>Generate Random Numbers</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Generate random number in range (inclusive)
let dice = U::random_number(1, 6);
let port = U::random_number(8000, 9000);
let user_id = U::random_number(1000, 99999);
#}</code></pre></pre>
<a class="header" href="print.html#http-utilities" id="http-utilities"><h3>HTTP Utilities</h3></a>
<a class="header" href="print.html#status-code-helpers" id="status-code-helpers"><h4>Status Code Helpers</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get human-readable status text
let status = U::http_status(200);  // &quot;OK&quot;
let error = U::http_status(404);   // &quot;Not Found&quot;
let server_error = U::http_status(500); // &quot;Internal Server Error&quot;

// Use in responses
async fn not_found(ctx: Context) -&gt; Result&lt;Response&gt; {
    let message = U::http_status(404);
    Ok(Response::not_found().with_text(message))
}
#}</code></pre></pre>
<a class="header" href="print.html#etag-generation" id="etag-generation"><h4>ETag Generation</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Generate ETags for content caching
let content = &quot;Hello, World!&quot;;
let etag = U::etag(content);

// Use in HTTP responses
async fn cached_content(ctx: Context) -&gt; Result&lt;Response&gt; {
    let content = get_content();
    let etag = U::etag(&amp;content);
    
    Ok(Response::ok()
        .with_header(&quot;ETag&quot;, &amp;etag)
        .with_text(content))
}
#}</code></pre></pre>
<a class="header" href="print.html#mime-type-detection" id="mime-type-detection"><h4>MIME Type Detection</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Get content type by file extension
let html_type = U::get_content_type(&quot;html&quot;);   // &quot;text/html&quot;
let json_type = U::get_content_type(&quot;json&quot;);   // &quot;application/json&quot;
let css_type = U::get_content_type(&quot;css&quot;);     // &quot;text/css&quot;
let js_type = U::get_content_type(&quot;js&quot;);       // &quot;application/javascript&quot;

// Use in file serving
async fn serve_file(ctx: Context) -&gt; Result&lt;Response&gt; {
    let filename = ctx.param(&quot;filename&quot;)?;
    let extension = filename.split('.').last().unwrap_or(&quot;txt&quot;);
    let content_type = U::get_content_type(extension);
    
    let content = std::fs::read_to_string(&amp;filename)?;
    Ok(Response::ok()
        .with_header(&quot;Content-Type&quot;, content_type)
        .with_text(content))
}
#}</code></pre></pre>
<a class="header" href="print.html#encoding--decoding" id="encoding--decoding"><h3>Encoding &amp; Decoding</h3></a>
<a class="header" href="print.html#url-encoding" id="url-encoding"><h4>URL Encoding</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// URL encode strings - Direct access
let encoded = U::encode(&quot;hello world&quot;);
assert_eq!(encoded, &quot;hello%20world&quot;);

let encoded = U::encode(&quot;user@example.com&quot;);
assert_eq!(encoded, &quot;user%40example.com&quot;);

// URL decode strings - Direct access
let decoded = U::decode(&quot;hello%20world&quot;)?;
assert_eq!(decoded, &quot;hello world&quot;);

// Extended encoding functions - Namespaced access
let html = U::Encoding::html_encode(&quot;&lt;script&gt;alert('xss')&lt;/script&gt;&quot;);
let hex = U::Encoding::hex_encode(&amp;[255, 0, 128]);  // &quot;ff0080&quot;
let base64_url = U::Encoding::base64_url_encode(&quot;data&quot;);

// Use in URL building
fn build_search_url(query: &amp;str) -&gt; String {
    format!(&quot;/search?q={}&quot;, U::encode(query))
}
#}</code></pre></pre>
<a class="header" href="print.html#base64-encoding" id="base64-encoding"><h4>Base64 Encoding</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Base64 encode (btoa = binary to ASCII)
let encoded = U::btoa(&quot;hello&quot;);
println!(&quot;Base64: {}&quot;, encoded); // &quot;aGVsbG8=&quot;

// Base64 decode (atob = ASCII to binary)
let decoded = U::atob(&quot;aGVsbG8=&quot;)?;
assert_eq!(decoded, &quot;hello&quot;);

// Use for API tokens, data encoding
let token = U::btoa(&amp;format!(&quot;{}:{}&quot;, username, password));
#}</code></pre></pre>
<a class="header" href="print.html#string-processing" id="string-processing"><h3>String Processing</h3></a>
<a class="header" href="print.html#text-cleaning" id="text-cleaning"><h4>Text Cleaning</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Clean and normalize text - Direct access
let messy = &quot;  hello    world  \n\t&quot;;
let clean = U::trim(messy);
assert_eq!(clean, &quot;hello world&quot;);

// Extended string functions - Namespaced access
let slug = U::String::to_slug(&quot;Hello World!&quot;);        // &quot;hello-world&quot;
let camel = U::String::to_camel_case(&quot;hello world&quot;);   // &quot;helloWorld&quot;
let pascal = U::String::to_pascal_case(&quot;hello world&quot;); // &quot;HelloWorld&quot;
let snake = U::String::to_snake_case(&quot;Hello World&quot;);   // &quot;hello_world&quot;
let title = U::String::title_case(&quot;hello world&quot;);      // &quot;Hello World&quot;
let truncated = U::String::truncate(&quot;Long text here&quot;, 10); // &quot;Long te...&quot;

// Use for user input processing
async fn process_comment(ctx: Context) -&gt; Result&lt;Response&gt; {
    let raw_comment = ctx.form_value(&quot;comment&quot;)?;
    let clean_comment = U::trim(&amp;raw_comment);
    
    // Save clean comment to database
    save_comment(&amp;clean_comment).await?;
    ctx.redirect(&quot;/comments&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#keyword-extraction" id="keyword-extraction"><h4>Keyword Extraction</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Extract keywords for search indexing
let text = &quot;This is a sample blog post about web development&quot;;
let keywords = U::keywords(text, 10, 3);
// Returns: [&quot;sample&quot;, &quot;blog&quot;, &quot;post&quot;, &quot;web&quot;, &quot;development&quot;]
// (excludes common words like &quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;about&quot;)

// Use for content indexing
async fn create_post(ctx: Context) -&gt; Result&lt;Response&gt; {
    let title = ctx.form_value(&quot;title&quot;)?;
    let content = ctx.form_value(&quot;content&quot;)?;
    
    // Extract keywords for search
    let search_keywords = U::keywords(&amp;format!(&quot;{} {}&quot;, title, content), 20, 4);
    
    let post = Post {
        title,
        content,
        keywords: search_keywords.join(&quot;, &quot;),
        ..Default::default()
    };
    
    post.save().await?;
    ctx.redirect(&quot;/posts&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#safe-parsing" id="safe-parsing"><h3>Safe Parsing</h3></a>
<p>Parse strings with fallback values using direct access for common types, or namespaced access for extended parsing:</p>
<a class="header" href="print.html#boolean-parsing" id="boolean-parsing"><h4>Boolean Parsing</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Parse booleans safely
let enabled = U::parse_bool(&quot;true&quot;, false);   // true
let disabled = U::parse_bool(&quot;false&quot;, true);  // false
let default = U::parse_bool(&quot;invalid&quot;, false); // false (fallback)

// Use with form data
async fn update_settings(ctx: Context) -&gt; Result&lt;Response&gt; {
    let notifications = U::parse_bool(&amp;ctx.form_value(&quot;notifications&quot;)?, false);
    let public_profile = U::parse_bool(&amp;ctx.form_value(&quot;public&quot;)?, true);
    
    update_user_settings(notifications, public_profile).await?;
    ctx.redirect(&quot;/settings&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#number-parsing" id="number-parsing"><h4>Number Parsing</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Parse integers safely - Direct access
let page = U::parse_int(&quot;5&quot;, 1);        // 5
let invalid = U::parse_int(&quot;abc&quot;, 1);   // 1 (fallback)
let limit = U::parse_int(&quot;100&quot;, 10);    // 100

// Parse floats safely - Direct access
let price = U::parse_float(&quot;19.99&quot;, 0.0);    // 19.99
let invalid = U::parse_float(&quot;abc&quot;, 0.0);    // 0.0 (fallback)

// Extended parsing functions - Namespaced access
let duration = U::Parsing::parse_duration(&quot;1h&quot;, 0);     // 3600 seconds
let size = U::Parsing::parse_size(&quot;1MB&quot;, 0);            // 1048576 bytes
let percent = U::Parsing::parse_percentage(&quot;75%&quot;, 0.0); // 0.75
let unsigned = U::Parsing::parse_unsigned_integer(&quot;123&quot;, 0); // 123
let comma_separated = U::Parsing::parse_comma_separated(&quot;a,b,c&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

// Use with query parameters
async fn list_products(ctx: Context) -&gt; Result&lt;Response&gt; {
    let page = U::parse_int(&amp;ctx.query_value(&quot;page&quot;)?, 1);
    let limit = U::parse_int(&amp;ctx.query_value(&quot;limit&quot;)?, 10);
    let min_price = U::parse_float(&amp;ctx.query_value(&quot;min_price&quot;)?, 0.0);
    
    let products = Product::paginate(page, limit)
        .where_gte(&quot;price&quot;, min_price)
        .get().await?;
    
    ctx.view(&quot;/products/list&quot;, json!({
        &quot;products&quot;: products,
        &quot;page&quot;: page,
        &quot;limit&quot;: limit
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#json-object-manipulation" id="json-object-manipulation"><h3>JSON Object Manipulation</h3></a>
<a class="header" href="print.html#getting-nested-values" id="getting-nested-values"><h4>Getting Nested Values</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use serde_json::json;

// Get nested properties safely
let data = json!({
    &quot;user&quot;: {
        &quot;profile&quot;: {
            &quot;name&quot;: &quot;John Doe&quot;,
            &quot;age&quot;: 30
        },
        &quot;settings&quot;: {
            &quot;theme&quot;: &quot;dark&quot;
        }
    }
});

let name = U::get(&amp;data, &quot;user.profile.name&quot;);
// Returns: Some(&amp;Value::String(&quot;John Doe&quot;))

let theme = U::get(&amp;data, &quot;user.settings.theme&quot;);
// Returns: Some(&amp;Value::String(&quot;dark&quot;))

let missing = U::get(&amp;data, &quot;user.profile.email&quot;);
// Returns: None

// Use in templates or API responses
async fn user_profile(ctx: Context) -&gt; Result&lt;Response&gt; {
    let user_data = get_user_data().await?;
    
    let display_name = U::get(&amp;user_data, &quot;profile.display_name&quot;)
        .and_then(|v| v.as_str())
        .unwrap_or(&quot;Anonymous&quot;);
    
    ctx.view(&quot;/profile&quot;, json!({
        &quot;name&quot;: display_name,
        &quot;data&quot;: user_data
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#setting-nested-values" id="setting-nested-values"><h4>Setting Nested Values</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Set nested properties
let mut data = json!({});

// Creates nested structure automatically
U::set(&amp;mut data, &quot;user.name&quot;, json!(&quot;Jane&quot;))?;
U::set(&amp;mut data, &quot;user.profile.age&quot;, json!(25))?;
U::set(&amp;mut data, &quot;settings.theme&quot;, json!(&quot;light&quot;))?;

// Result:
// {
//   &quot;user&quot;: {
//     &quot;name&quot;: &quot;Jane&quot;,
//     &quot;profile&quot;: {
//       &quot;age&quot;: 25
//     }
//   },
//   &quot;settings&quot;: {
//     &quot;theme&quot;: &quot;light&quot;
//   }
// }

// Use for dynamic data building
async fn build_user_response(user: &amp;User) -&gt; Result&lt;Value&gt; {
    let mut response = json!({});
    
    U::set(&amp;mut response, &quot;user.id&quot;, json!(user.id))?;
    U::set(&amp;mut response, &quot;user.name&quot;, json!(user.name))?;
    U::set(&amp;mut response, &quot;user.email&quot;, json!(user.email))?;
    U::set(&amp;mut response, &quot;meta.timestamp&quot;, json!(chrono::Utc::now()))?;
    
    Ok(response)
}
#}</code></pre></pre>
<a class="header" href="print.html#geographic-utilities" id="geographic-utilities"><h3>Geographic Utilities</h3></a>
<a class="header" href="print.html#distance-calculation" id="distance-calculation"><h4>Distance Calculation</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Calculate distance between two points in kilometers - Direct access
let ny_lat = 40.7128;
let ny_lon = -74.0060;
let la_lat = 34.0522;
let la_lon = -118.2437;

let distance = U::distance(ny_lat, ny_lon, la_lat, la_lon);
println!(&quot;Distance: {:.2} km&quot;, distance); // Distance: 3944.42 km

// Extended geographic functions - Namespaced access
let distance_miles = U::Geo::distance_miles(ny_lat, ny_lon, la_lat, la_lon);
let is_in_bounds = U::Geo::in_bounds(40.7, -74.0, 40.0, 41.0, -75.0, -73.0);
let bearing = U::Geo::bearing(ny_lat, ny_lon, la_lat, la_lon);

// Use for location-based features
async fn find_nearby_stores(ctx: Context) -&gt; Result&lt;Response&gt; {
    let user_lat = U::parse_float(&amp;ctx.query_value(&quot;lat&quot;)?, 0.0);
    let user_lon = U::parse_float(&amp;ctx.query_value(&quot;lon&quot;)?, 0.0);
    
    let stores = get_all_stores().await?;
    let mut nearby_stores = Vec::new();
    
    for store in stores {
        let distance = U::distance(user_lat, user_lon, store.lat, store.lon);
        if distance &lt;= 50.0 { // Within 50km
            nearby_stores.push((store, distance));
        }
    }
    
    // Sort by distance
    nearby_stores.sort_by(|a, b| a.1.partial_cmp(&amp;b.1).unwrap());
    
    ctx.json(&amp;json!({
        &quot;stores&quot;: nearby_stores.into_iter()
            .map(|(store, dist)| json!({
                &quot;store&quot;: store,
                &quot;distance&quot;: dist
            }))
            .collect::&lt;Vec&lt;_&gt;&gt;()
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#cryptographic-hash-functions" id="cryptographic-hash-functions"><h3>Cryptographic Hash Functions</h3></a>
<p>RustF provides secure hash functions accessible both directly and through the Crypto namespace:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Direct access to most common hash functions
let md5_hash = U::md5(&quot;hello world&quot;);        // âš ï¸ Warning: MD5 not secure
let sha256_hash = U::sha256(&quot;hello world&quot;);  // âœ… Secure hash function

// Extended access to all hash functions via U::Crypto::
let sha1_hash = U::Crypto::sha1(&quot;data&quot;);       // âš ï¸ Warning: SHA1 not secure  
let sha512_hash = U::Crypto::sha512(&quot;data&quot;);   // âœ… Very secure hash function

// Hash from byte arrays
let hash_from_bytes = U::Crypto::md5_bytes(&amp;[1, 2, 3, 4, 5]);
let secure_hash_bytes = U::Crypto::sha256_bytes(b&quot;binary data&quot;);

// Other crypto utilities
let hash_code = U::Crypto::hash_string(&quot;data&quot;);           // Fast non-crypto hash
let is_equal = U::Crypto::constant_time_compare(&quot;a&quot;, &quot;b&quot;); // Timing-safe comparison
let checksum = U::Crypto::simple_checksum(&quot;integrity check&quot;);

// Simple obfuscation (not encryption!)
let obfuscated = U::Crypto::obfuscate_string(&quot;secret&quot;, 5);
let deobfuscated = U::Crypto::deobfuscate_string(&amp;obfuscated, 5);

// Basic XOR encryption/decryption (not secure - for obfuscation only)
let encrypted = U::Crypto::xor_encrypt(&quot;message&quot;, &quot;key&quot;);
let decrypted = U::Crypto::xor_decrypt(&amp;encrypted, &quot;key&quot;);
#}</code></pre></pre>
<p><strong>Security Notice</strong>: MD5 and SHA1 are cryptographically broken and should not be used for security purposes. Use SHA256 or higher for security-sensitive applications.</p>
<a class="header" href="print.html#common-usage-patterns" id="common-usage-patterns"><h2>Common Usage Patterns</h2></a>
<a class="header" href="print.html#form-processing-1" id="form-processing-1"><h3>Form Processing</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn process_form(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Safe parsing with defaults - Direct access
    let name = U::trim(&amp;ctx.form_value(&quot;name&quot;)?);
    let age = U::parse_int(&amp;ctx.form_value(&quot;age&quot;)?, 0);
    let email = U::trim(&amp;ctx.form_value(&quot;email&quot;)?);
    let newsletter = U::parse_bool(&amp;ctx.form_value(&quot;newsletter&quot;)?, false);
    
    // Extended validation using namespaced functions
    let clean_email = U::String::strip_html(&amp;email);
    let email_slug = U::String::to_slug(&amp;name); // For URL-friendly usernames
    
    if name.is_empty() || age &lt;= 0 {
        ctx.flash_set(&quot;error_msg&quot;, &quot;Please fill in all required fields&quot;);
        return ctx.redirect(&quot;/form&quot;);
    }
    
    // Create user with secure hash for verification tokens
    let user_id = U::guid();
    let verification_token = U::sha256(&amp;format!(&quot;{}:{}&quot;, user_id, email));
    
    let user = User {
        id: user_id,
        name,
        age,
        email: clean_email,
        newsletter_subscribed: newsletter,
        verification_token,
    };
    
    user.save().await?;
    ctx.flash_set(&quot;success_msg&quot;, &quot;User created successfully!&quot;);
    ctx.redirect(&quot;/users&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#api-response-building" id="api-response-building"><h3>API Response Building</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn api_user_list(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Parse pagination parameters safely - Direct access
    let page = U::parse_int(&amp;ctx.query_value(&quot;page&quot;)?, 1);
    let limit = U::parse_int(&amp;ctx.query_value(&quot;limit&quot;)?, 10);
    
    // Extended parsing for filtering - Namespaced access  
    let search = U::String::trim(&amp;ctx.query_value(&quot;search&quot;).unwrap_or_default());
    let sort_order = U::Parsing::parse_enum(&amp;ctx.query_value(&quot;sort&quot;)?, SortOrder::Asc);
    
    let users = User::paginate(page, limit).await?;
    let total = User::count().await?;
    
    // Build response with utilities - Direct access for JSON manipulation
    let mut response = json!({});
    U::set(&amp;mut response, &quot;data&quot;, json!(users))?;
    U::set(&amp;mut response, &quot;pagination.page&quot;, json!(page))?;
    U::set(&amp;mut response, &quot;pagination.limit&quot;, json!(limit))?;
    U::set(&amp;mut response, &quot;pagination.total&quot;, json!(total))?;
    U::set(&amp;mut response, &quot;meta.request_id&quot;, json!(U::guid()))?;
    U::set(&amp;mut response, &quot;meta.timestamp&quot;, json!(chrono::Utc::now()))?;
    
    // Extended object manipulation - Namespaced access
    let has_filters = U::Object::has_nested_property(&amp;response, &quot;filters&quot;);
    if !search.is_empty() {
        U::set(&amp;mut response, &quot;filters.search&quot;, json!(search))?;
    }
    
    // Generate ETag for caching - Direct access
    let content = response.to_string();
    let etag = U::etag(&amp;content);
    
    Ok(Response::ok()
        .with_header(&quot;ETag&quot;, &amp;etag)
        .with_json(&amp;response)?)
}
#}</code></pre></pre>
<a class="header" href="print.html#search-and-filtering" id="search-and-filtering"><h3>Search and Filtering</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn search_content(ctx: Context) -&gt; Result&lt;Response&gt; {
    // Basic input processing - Direct access
    let query = U::trim(&amp;ctx.query_value(&quot;q&quot;)?);
    let category = ctx.query_value(&quot;category&quot;)?;
    
    // Extended string processing - Namespaced access
    let clean_query = U::String::strip_html(&amp;query);
    let query_slug = U::String::to_slug(&amp;clean_query);
    
    if clean_query.is_empty() {
        return ctx.view(&quot;/search&quot;, json!({
            &quot;message&quot;: &quot;Please enter a search term&quot;
        }));
    }
    
    // Extract search keywords - Direct access
    let search_terms = U::keywords(&amp;clean_query, 10, 3);
    
    // Generate search hash for caching - Direct access
    let search_hash = U::sha256(&amp;format!(&quot;{}:{}&quot;, clean_query, category));
    
    // Build search results
    let results = search_posts(&amp;search_terms, &amp;category).await?;
    
    // Extended parsing for result formatting - Namespaced access
    let result_limit = U::Parsing::parse_int(&amp;ctx.query_value(&quot;limit&quot;)?, 10);
    let truncated_results: Vec&lt;_&gt; = results.into_iter()
        .take(result_limit as usize)
        .map(|mut post| {
            // Truncate content for search results
            post.content = U::String::truncate_words(&amp;post.content, 100);
            post
        })
        .collect();
    
    ctx.view(&quot;/search&quot;, json!({
        &quot;query&quot;: clean_query,
        &quot;results&quot;: truncated_results,
        &quot;keywords&quot;: search_terms,
        &quot;total&quot;: truncated_results.len(),
        &quot;search_hash&quot;: search_hash
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#file-upload-processing" id="file-upload-processing"><h3>File Upload Processing</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn handle_upload(ctx: Context) -&gt; Result&lt;Response&gt; {
    let file = ctx.file(&quot;upload&quot;)?;
    
    // Generate unique filename - Direct access
    let file_id = U::guid();
    let original_name = file.filename.unwrap_or(&quot;upload&quot;.to_string());
    let extension = original_name.split('.').last().unwrap_or(&quot;bin&quot;);
    
    // Extended string processing - Namespaced access
    let safe_original_name = U::String::strip_html(&amp;original_name);
    let filename_slug = U::String::to_slug(&amp;safe_original_name);
    let secure_token = U::Random::generate_secure_token(16);
    let new_filename = format!(&quot;{}_{}_{}.{}&quot;, file_id, filename_slug, secure_token, extension);
    
    // Get content type and validate - Direct and namespaced access
    let content_type = U::get_content_type(extension);
    let is_valid_type = U::Http::is_success_status(200); // Example validation
    
    // Generate file hash for integrity checking - Direct access
    let file_hash = U::sha256(&amp;format!(&quot;{:?}&quot;, file.data));
    
    // Extended parsing for file size - Namespaced access
    let max_size = U::Parsing::parse_size(&quot;10MB&quot;, 10485760); // 10MB default
    if file.data.len() &gt; max_size as usize {
        return ctx.json(&amp;json!({
            &quot;error&quot;: &quot;File too large&quot;,
            &quot;max_size&quot;: format!(&quot;{}MB&quot;, max_size / 1048576)
        }));
    }
    
    // Save file metadata with enhanced information
    let file_record = FileRecord {
        id: file_id.clone(),
        original_name: safe_original_name,
        filename: new_filename.clone(),
        content_type: content_type.to_string(),
        size: file.data.len(),
        hash: file_hash,
        upload_token: secure_token,
        ..Default::default()
    };
    
    // Save to storage and database
    save_file(&amp;new_filename, &amp;file.data).await?;
    file_record.save().await?;
    
    ctx.json(&amp;json!({
        &quot;success&quot;: true,
        &quot;file_id&quot;: file_id,
        &quot;filename&quot;: new_filename,
        &quot;size&quot;: file.data.len(),
        &quot;content_type&quot;: content_type
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#best-practices-20" id="best-practices-20"><h2>Best Practices</h2></a>
<a class="header" href="print.html#error-handling-7" id="error-handling-7"><h3>Error Handling</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Always handle potential errors from parsing
match U::decode(&amp;encoded_value) {
    Ok(decoded) =&gt; process_value(&amp;decoded),
    Err(_) =&gt; {
        log::warn!(&quot;Failed to decode value: {}&quot;, encoded_value);
        use_default_value()
    }
}

// Or use parsing utilities with safe defaults
let safe_value = U::parse_int(&amp;user_input, 0);
#}</code></pre></pre>
<a class="header" href="print.html#performance-considerations-3" id="performance-considerations-3"><h3>Performance Considerations</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Cache expensive operations
static KEYWORDS_CACHE: OnceCell&lt;HashMap&lt;String, Vec&lt;String&gt;&gt;&gt; = OnceCell::new();

fn get_cached_keywords(text: &amp;str) -&gt; Vec&lt;String&gt; {
    let cache = KEYWORDS_CACHE.get_or_init(HashMap::new);
    
    if let Some(cached) = cache.get(text) {
        return cached.clone();
    }
    
    let keywords = U::keywords(text, 20, 4);
    // In real implementation, you'd update the cache here
    keywords
}
#}</code></pre></pre>
<a class="header" href="print.html#security" id="security"><h3>Security</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Always validate and sanitize user input
async fn update_profile(ctx: Context) -&gt; Result&lt;Response&gt; {
    let name = U::trim(&amp;ctx.form_value(&quot;name&quot;)?);
    let bio = U::trim(&amp;ctx.form_value(&quot;bio&quot;)?);
    
    // Validate lengths
    if name.len() &gt; 100 {
        return ctx.json(&amp;json!({
            &quot;error&quot;: &quot;Name too long&quot;
        }));
    }
    
    if bio.len() &gt; 1000 {
        return ctx.json(&amp;json!({
            &quot;error&quot;: &quot;Bio too long&quot;  
        }));
    }
    
    // Update user...
}
#}</code></pre></pre>
<a class="header" href="print.html#summary-8" id="summary-8"><h2>Summary</h2></a>
<p>The RustF utilities system provides comprehensive utility functions organized in a dual-access pattern:</p>
<a class="header" href="print.html#core-features" id="core-features"><h3>Core Features</h3></a>
<ul>
<li><strong>Random generation</strong> - UUIDs, strings, numbers, secure tokens</li>
<li><strong>HTTP utilities</strong> - Status codes, ETags, MIME types, response validation</li>
<li><strong>String processing</strong> - Cleaning, keyword extraction, case conversion, HTML stripping</li>
<li><strong>Encoding/decoding</strong> - URL encoding, Base64, HTML entities, hexadecimal</li>
<li><strong>Safe parsing</strong> - Numbers, booleans, durations, sizes, percentages with defaults</li>
<li><strong>JSON manipulation</strong> - Get/set nested properties, deep merging, object flattening</li>
<li><strong>Geographic calculations</strong> - Distance between coordinates, boundary checking, bearing</li>
<li><strong>Cryptographic functions</strong> - MD5, SHA1, SHA256, SHA512 hashing, secure comparisons</li>
</ul>
<a class="header" href="print.html#access-patterns" id="access-patterns"><h3>Access Patterns</h3></a>
<p>The RustF utilities system provides both direct access (<code>U::function_name()</code>) for commonly used functions and namespaced access (<code>U::ModuleName::function_name()</code>) for extended functionality.</p>
<p><strong>Key Achievement</strong>: The exact <code>U::ModuleName::function()</code> syntax that was requested now works perfectly, providing powerful, organized access to all utility functions throughout your RustF application.</p>
<a class="header" href="print.html#security-features" id="security-features"><h3>Security Features</h3></a>
<ul>
<li>âœ… Secure hash functions (SHA256, SHA512)</li>
<li>âš ï¸ Legacy hash functions (MD5, SHA1) with clear warnings</li>
<li>ğŸ”’ Timing-safe comparisons for sensitive data</li>
<li>ğŸ›¡ï¸ Input sanitization and validation helpers</li>
<li>ğŸ” Cryptographically secure token generation</li>
</ul>
<p>Use the utilities system to build secure, maintainable web applications with consistent, predictable utility functions that follow Rust best practices and web development standards.</p>
<a class="header" href="print.html#urandom---random-generation-extended" id="urandom---random-generation-extended"><h4>U::Random:: - Random Generation (Extended)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
U::Random::generate_guid_with_hyphens()           // UUID with hyphens
U::Random::generate_random_string_with_charset(len, charset) // Custom character set
U::Random::generate_random_float(min, max)        // Random float
U::Random::generate_random_text(word_count)       // Lorem ipsum text
U::Random::generate_secure_token(byte_len)        // Cryptographically secure token
#}</code></pre></pre>
<a class="header" href="print.html#uencoding---encoding-extended" id="uencoding---encoding-extended"><h4>U::Encoding:: - Encoding (Extended)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
U::Encoding::encode_with_safe(str, safe_chars)    // URL encode with safe characters
U::Encoding::btoa_bytes(bytes)                    // Base64 encode bytes
U::Encoding::base64_decode_bytes(str)             // Base64 decode to bytes
U::Encoding::base64_url_encode(str)               // URL-safe base64 encode
U::Encoding::base64_url_decode(str)               // URL-safe base64 decode
U::Encoding::html_encode(str)                     // HTML entity encode
U::Encoding::html_decode(str)                     // HTML entity decode
U::Encoding::json_encode(str)                     // JSON string escape
U::Encoding::hex_encode(bytes)                    // Hexadecimal encode
U::Encoding::hex_decode(str)                      // Hexadecimal decode
U::Encoding::query_encode(params)                 // Query string encode
U::Encoding::query_decode(query)                  // Query string decode
#}</code></pre></pre>
<a class="header" href="print.html#ustring---string-processing-extended" id="ustring---string-processing-extended"><h4>U::String:: - String Processing (Extended)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
U::String::to_slug(str)           // Convert to URL slug
U::String::to_camel_case(str)     // Convert to camelCase
U::String::to_pascal_case(str)    // Convert to PascalCase
U::String::to_snake_case(str)     // Convert to snake_case
U::String::truncate(str, len)     // Truncate by character count
U::String::truncate_words(str, len) // Truncate by word count
U::String::word_count(str)        // Count words
U::String::title_case(str)        // Convert to Title Case
U::String::strip_html(str)        // Remove HTML tags
U::String::wrap_text(str, width)  // Wrap text to width
#}</code></pre></pre>
<a class="header" href="print.html#uparsing---parsing-extended" id="uparsing---parsing-extended"><h4>U::Parsing:: - Parsing (Extended)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
U::Parsing::parse_unsigned_integer(str, default) // Parse u64
U::Parsing::parse_i32(str, default)              // Parse i32
U::Parsing::parse_f32(str, default)              // Parse f32
U::Parsing::parse_enum(str, default)             // Parse enum from string
U::Parsing::parse_comma_separated(str)           // Parse comma-separated values
U::Parsing::parse_comma_separated_integers(str, default) // Parse comma-separated integers
U::Parsing::parse_key_value(str, separator)      // Parse key=value pairs
U::Parsing::parse_duration(str, default)         // Parse duration (1h, 30m, etc.)
U::Parsing::parse_size(str, default)             // Parse size (1KB, 2MB, etc.)
U::Parsing::parse_percentage(str, default)       // Parse percentage
#}</code></pre></pre>
<a class="header" href="print.html#ucrypto---cryptographic-functions" id="ucrypto---cryptographic-functions"><h4>U::Crypto:: - Cryptographic Functions</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Hash functions (includes all direct access functions plus extended ones)
U::Crypto::md5(str)                    // MD5 hash âš ï¸ Not secure
U::Crypto::md5_bytes(bytes)           // MD5 hash from bytes âš ï¸ Not secure
U::Crypto::sha1(str)                  // SHA1 hash âš ï¸ Not secure
U::Crypto::sha1_bytes(bytes)         // SHA1 hash from bytes âš ï¸ Not secure
U::Crypto::sha256(str)               // SHA256 hash (secure)
U::Crypto::sha256_bytes(bytes)       // SHA256 hash from bytes (secure)
U::Crypto::sha512(str)               // SHA512 hash (secure)
U::Crypto::sha512_bytes(bytes)       // SHA512 hash from bytes (secure)

// Other crypto utilities
U::Crypto::hash_string(str)                      // Hash string (non-crypto)
U::Crypto::hash_bytes(bytes)                     // Hash bytes (non-crypto)
U::Crypto::xor_encrypt(data, key)                // XOR encrypt (not secure)
U::Crypto::xor_decrypt(data, key)                // XOR decrypt (not secure)
U::Crypto::simple_checksum(data)                 // Simple checksum
U::Crypto::constant_time_compare(a, b)           // Timing-safe string compare
U::Crypto::constant_time_compare_bytes(a, b)     // Timing-safe byte compare
U::Crypto::obfuscate_string(str, offset)         // Simple obfuscation
U::Crypto::deobfuscate_string(str, offset)       // Simple deobfuscation
#}</code></pre></pre>
<a class="header" href="print.html#uhttp---http-extended" id="uhttp---http-extended"><h4>U::Http:: - HTTP (Extended)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
U::Http::generate_strong_etag(content, modified) // Strong ETag with timestamp
U::Http::get_extension_from_content_type(mime)   // Get extension from MIME type
U::Http::is_success_status(code)                 // Check if 2xx status
U::Http::is_client_error(code)                   // Check if 4xx status
U::Http::is_server_error(code)                   // Check if 5xx status
U::Http::is_redirect_status(code)                // Check if 3xx status
#}</code></pre></pre>
<a class="header" href="print.html#uobject---object-manipulation-extended" id="uobject---object-manipulation-extended"><h4>U::Object:: - Object Manipulation (Extended)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
U::Object::remove_nested_property(obj, path)     // Remove nested property
U::Object::deep_merge(target, source)            // Deep merge objects
U::Object::shallow_merge(target, source)         // Shallow merge objects
U::Object::deep_clone(value)                     // Deep clone JSON value
U::Object::flatten_object(obj, prefix)           // Flatten nested object
U::Object::has_nested_property(obj, path)        // Check if property exists
U::Object::get_all_keys(obj)                     // Get all object keys
#}</code></pre></pre>
<a class="header" href="print.html#ugeo---geographic-extended" id="ugeo---geographic-extended"><h4>U::Geo:: - Geographic (Extended)</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
U::Geo::distance_miles(lat1, lon1, lat2, lon2)   // Distance in miles
U::Geo::in_bounds(lat, lon, min_lat, max_lat, min_lon, max_lon) // Check if in bounds
U::Geo::bearing(lat1, lon1, lat2, lon2)          // Calculate bearing/direction
#}</code></pre></pre>
<a class="header" href="print.html#usage-patterns" id="usage-patterns"><h2>Usage Patterns</h2></a>
<p>The RustF utilities system supports three usage patterns:</p>
<a class="header" href="print.html#1-direct-access-recommended-for-common-operations" id="1-direct-access-recommended-for-common-operations"><h3>1. Direct Access (Recommended for Common Operations)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::U;

// Most commonly used functions - direct access
let id = U::guid();
let encoded = U::encode(&quot;hello world&quot;);
let hash = U::sha256(&quot;secure data&quot;);
let parsed = U::parse_int(&quot;123&quot;, 0);
#}</code></pre></pre>
<a class="header" href="print.html#2-namespaced-access-extended-functionality" id="2-namespaced-access-extended-functionality"><h3>2. Namespaced Access (Extended Functionality)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::U;

// Extended functions through nested modules - exact syntax requested!
let slug = U::String::to_slug(&quot;Hello World!&quot;);
let html = U::Encoding::html_encode(&quot;&lt;p&gt;Hello&lt;/p&gt;&quot;);
let size = U::Parsing::parse_size(&quot;1MB&quot;, 0);
let secure_token = U::Random::generate_secure_token(32);
let sha1_hash = U::Crypto::sha1(&quot;legacy data&quot;); // Warning: Not secure
#}</code></pre></pre>
<a class="header" href="print.html#3-module-level-access-alternative" id="3-module-level-access-alternative"><h3>3. Module-Level Access (Alternative)</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Alternative approach - direct module imports
use rustf::utils::{string, encoding, parsing};

let slug = string::to_slug(&quot;Hello World!&quot;);
let html = encoding::html_encode(&quot;&lt;p&gt;Hello&lt;/p&gt;&quot;);
let size = parsing::parse_size(&quot;1MB&quot;, 0);
#}</code></pre></pre>
<a class="header" href="print.html#examples--tutorials" id="examples--tutorials"><h1>Examples &amp; Tutorials</h1></a>
<p>This section contains step-by-step tutorials and real-world examples to help you build applications with RustF.</p>
<a class="header" href="print.html#available-examples" id="available-examples"><h2>Available Examples</h2></a>
<a class="header" href="print.html#a-hrefrest-apimdbuilding-a-rest-apia" id="a-hrefrest-apimdbuilding-a-rest-apia"><h3><a href="rest-api.md">Building a REST API</a></h3></a>
<p>Learn how to build a complete REST API with CRUD operations, validation, and error handling. This tutorial covers:</p>
<ul>
<li>Creating API controllers</li>
<li>Request/response handling</li>
<li>Input validation</li>
<li>Error responses</li>
<li>Testing your API</li>
</ul>
<a class="header" href="print.html#a-hrefauthenticationmdauthenticationa" id="a-hrefauthenticationmdauthenticationa"><h3><a href="authentication.md">Authentication</a></h3></a>
<p>Implement user authentication in your RustF application. This guide covers:</p>
<ul>
<li>User login and registration</li>
<li>Session management</li>
<li>Protected routes</li>
<li>Security best practices</li>
<li>Password hashing</li>
</ul>
<a class="header" href="print.html#a-hrefreal-world-appmdreal-world-applicationa" id="a-hrefreal-world-appmdreal-world-applicationa"><h3><a href="real-world-app.md">Real-World Application</a></h3></a>
<p>Build a complete blog application using all major RustF features:</p>
<ul>
<li>User authentication</li>
<li>Blog post management</li>
<li>Comments system</li>
<li>Admin panel</li>
<li>Search functionality</li>
</ul>
<a class="header" href="print.html#next-steps-3" id="next-steps-3"><h2>Next Steps</h2></a>
<p>After working through these examples:</p>
<ul>
<li>Explore the <a href="../guides/controllers.md">Core Guides</a> for detailed framework concepts</li>
<li>Check out the <a href="../api-reference/context.md">API Reference</a> for complete API documentation</li>
<li>Review <a href="../deployment/production.md">Deployment Guides</a> for production setup</li>
</ul>
<a class="header" href="print.html#building-a-rest-api" id="building-a-rest-api"><h1>Building a REST API</h1></a>
<p>This tutorial shows you how to build a complete REST API with RustF, including CRUD operations, validation, and error handling.</p>
<a class="header" href="print.html#overview-17" id="overview-17"><h2>Overview</h2></a>
<p>We'll build a REST API for managing blog posts with the following endpoints:</p>
<ul>
<li><code>GET /api/posts</code> - List all posts</li>
<li><code>GET /api/posts/{id}</code> - Get a specific post</li>
<li><code>POST /api/posts</code> - Create a new post</li>
<li><code>PUT /api/posts/{id}</code> - Update a post</li>
<li><code>DELETE /api/posts/{id}</code> - Delete a post</li>
</ul>
<a class="header" href="print.html#project-setup" id="project-setup"><h2>Project Setup</h2></a>
<a class="header" href="print.html#1-create-controller" id="1-create-controller"><h3>1. Create Controller</h3></a>
<p>Create <code>src/controllers/api/posts.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;
use serde::{Deserialize, Serialize};

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET    &quot;/api/posts&quot;       =&gt; list_posts,
        GET    &quot;/api/posts/{id}&quot;   =&gt; get_post,
        POST   &quot;/api/posts&quot;       =&gt; create_post,
        PUT    &quot;/api/posts/{id}&quot;   =&gt; update_post,
        DELETE &quot;/api/posts/{id}&quot;   =&gt; delete_post,
    ]
}
#}</code></pre></pre>
<a class="header" href="print.html#2-define-data-structures" id="2-define-data-structures"><h3>2. Define Data Structures</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Serialize, Deserialize, Clone)]
struct Post {
    id: Option&lt;i32&gt;,
    title: String,
    content: String,
    author: String,
    published: bool,
    created_at: Option&lt;String&gt;,
}

#[derive(Deserialize)]
struct CreatePostRequest {
    title: String,
    content: String,
    author: String,
    published: Option&lt;bool&gt;,
}

#[derive(Deserialize)]
struct UpdatePostRequest {
    title: Option&lt;String&gt;,
    content: Option&lt;String&gt;,
    author: Option&lt;String&gt;,
    published: Option&lt;bool&gt;,
}
#}</code></pre></pre>
<a class="header" href="print.html#implementation" id="implementation"><h2>Implementation</h2></a>
<a class="header" href="print.html#list-posts" id="list-posts"><h3>List Posts</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn list_posts(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Parse pagination parameters
    let page = ctx.int_query_or(&quot;page&quot;, 1);
    let limit = ctx.int_query_or(&quot;limit&quot;, 10);
    let offset = (page - 1) * limit;
    
    // In a real app, fetch from database
    let posts = vec![
        Post {
            id: Some(1),
            title: &quot;First Post&quot;.to_string(),
            content: &quot;Content here&quot;.to_string(),
            author: &quot;Alice&quot;.to_string(),
            published: true,
            created_at: Some(&quot;2024-01-01T00:00:00Z&quot;.to_string()),
        },
        // ... more posts
    ];
    
    ctx.json(json!({
        &quot;posts&quot;: posts,
        &quot;pagination&quot;: {
            &quot;page&quot;: page,
            &quot;limit&quot;: limit,
            &quot;total&quot;: posts.len(),
            &quot;total_pages&quot;: (posts.len() as f64 / limit as f64).ceil() as i32
        }
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#get-single-post" id="get-single-post"><h3>Get Single Post</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn get_post(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let post_id = ctx.int_param(&quot;id&quot;)?;
    
    // In a real app, fetch from database
    if post_id == 1 {
        let post = Post {
            id: Some(1),
            title: &quot;First Post&quot;.to_string(),
            content: &quot;Content here&quot;.to_string(),
            author: &quot;Alice&quot;.to_string(),
            published: true,
            created_at: Some(&quot;2024-01-01T00:00:00Z&quot;.to_string()),
        };
        
        ctx.json(json!({
            &quot;success&quot;: true,
            &quot;post&quot;: post
        }))
    } else {
        ctx.throw404(Some(&quot;Post not found&quot;))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#create-post" id="create-post"><h3>Create Post</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn create_post(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let request: CreatePostRequest = ctx.body_json()?;
    
    // Validation
    if request.title.trim().is_empty() {
        return ctx.throw400(Some(&quot;Title is required&quot;));
    }
    
    if request.content.trim().is_empty() {
        return ctx.throw400(Some(&quot;Content is required&quot;));
    }
    
    if request.author.trim().is_empty() {
        return ctx.throw400(Some(&quot;Author is required&quot;));
    }
    
    // In a real app, save to database
    let post = Post {
        id: Some(2), // Generated by database
        title: request.title,
        content: request.content,
        author: request.author,
        published: request.published.unwrap_or(false),
        created_at: Some(chrono::Utc::now().to_rfc3339()),
    };
    
    ctx.status(hyper::StatusCode::CREATED);
    ctx.json(json!({
        &quot;success&quot;: true,
        &quot;message&quot;: &quot;Post created successfully&quot;,
        &quot;post&quot;: post
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#update-post" id="update-post"><h3>Update Post</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn update_post(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let post_id = ctx.int_param(&quot;id&quot;)?;
    let request: UpdatePostRequest = ctx.body_json()?;
    
    // In a real app, fetch and update in database
    if post_id == 1 {
        let mut post = Post {
            id: Some(1),
            title: &quot;First Post&quot;.to_string(),
            content: &quot;Content here&quot;.to_string(),
            author: &quot;Alice&quot;.to_string(),
            published: true,
            created_at: Some(&quot;2024-01-01T00:00:00Z&quot;.to_string()),
        };
        
        // Apply updates
        if let Some(title) = request.title {
            post.title = title;
        }
        if let Some(content) = request.content {
            post.content = content;
        }
        if let Some(author) = request.author {
            post.author = author;
        }
        if let Some(published) = request.published {
            post.published = published;
        }
        
        ctx.json(json!({
            &quot;success&quot;: true,
            &quot;message&quot;: &quot;Post updated successfully&quot;,
            &quot;post&quot;: post
        }))
    } else {
        ctx.throw404(Some(&quot;Post not found&quot;))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#delete-post" id="delete-post"><h3>Delete Post</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn delete_post(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let post_id = ctx.int_param(&quot;id&quot;)?;
    
    // In a real app, delete from database
    if post_id == 1 {
        ctx.json(json!({
            &quot;success&quot;: true,
            &quot;message&quot;: &quot;Post deleted successfully&quot;,
            &quot;deleted_id&quot;: post_id
        }))
    } else {
        ctx.throw404(Some(&quot;Post not found&quot;))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#testing-the-api" id="testing-the-api"><h2>Testing the API</h2></a>
<a class="header" href="print.html#using-curl" id="using-curl"><h3>Using curl</h3></a>
<pre><code class="language-bash"># List posts
curl http://localhost:8000/api/posts

# Get single post
curl http://localhost:8000/api/posts/1

# Create post
curl -X POST http://localhost:8000/api/posts \
  -H &quot;Content-Type: application/json&quot; \
  -d '{
    &quot;title&quot;: &quot;New Post&quot;,
    &quot;content&quot;: &quot;Post content&quot;,
    &quot;author&quot;: &quot;Bob&quot;,
    &quot;published&quot;: true
  }'

# Update post
curl -X PUT http://localhost:8000/api/posts/1 \
  -H &quot;Content-Type: application/json&quot; \
  -d '{
    &quot;title&quot;: &quot;Updated Title&quot;
  }'

# Delete post
curl -X DELETE http://localhost:8000/api/posts/1
</code></pre>
<a class="header" href="print.html#error-handling-8" id="error-handling-8"><h2>Error Handling</h2></a>
<p>The API returns appropriate HTTP status codes:</p>
<ul>
<li><code>200 OK</code> - Success</li>
<li><code>201 Created</code> - Resource created</li>
<li><code>400 Bad Request</code> - Validation error</li>
<li><code>404 Not Found</code> - Resource not found</li>
<li><code>500 Internal Server Error</code> - Server error</li>
</ul>
<p>Error responses follow this format:</p>
<pre><code class="language-json">{
  &quot;error&quot;: &quot;Error message here&quot;
}
</code></pre>
<a class="header" href="print.html#next-steps-4" id="next-steps-4"><h2>Next Steps</h2></a>
<ul>
<li>Add database integration - See <a href="../guides/database.md">Database Guide</a></li>
<li>Add authentication - See <a href="authentication.md">Authentication Example</a></li>
<li>Add middleware - See <a href="../guides/middleware.md">Middleware Guide</a></li>
<li>Add input validation middleware</li>
<li>Add rate limiting</li>
<li>Add API versioning</li>
</ul>
<a class="header" href="print.html#authentication-implementation" id="authentication-implementation"><h1>Authentication Implementation</h1></a>
<p>This guide shows how to implement authentication in a RustF application using sessions.</p>
<a class="header" href="print.html#overview-18" id="overview-18"><h2>Overview</h2></a>
<p>We'll implement:</p>
<ul>
<li>User login</li>
<li>User registration</li>
<li>Session management</li>
<li>Protected routes</li>
<li>Logout</li>
</ul>
<a class="header" href="print.html#setup" id="setup"><h2>Setup</h2></a>
<a class="header" href="print.html#1-create-auth-controller" id="1-create-auth-controller"><h3>1. Create Auth Controller</h3></a>
<p>Create <code>src/controllers/auth.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;
use serde::Deserialize;

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET  &quot;/auth/login&quot;    =&gt; view_login,
        POST &quot;/auth/login&quot;    =&gt; do_login,
        GET  &quot;/auth/register&quot; =&gt; view_register,
        POST &quot;/auth/register&quot; =&gt; do_register,
        POST &quot;/auth/logout&quot;   =&gt; do_logout,
    ]
}
#}</code></pre></pre>
<a class="header" href="print.html#2-define-data-structures-1" id="2-define-data-structures-1"><h3>2. Define Data Structures</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Deserialize)]
struct LoginForm {
    email: String,
    password: String,
}

#[derive(Deserialize)]
struct RegisterForm {
    name: String,
    email: String,
    password: String,
    password_confirm: String,
}
#}</code></pre></pre>
<a class="header" href="print.html#implementation-1" id="implementation-1"><h2>Implementation</h2></a>
<a class="header" href="print.html#login-view" id="login-view"><h3>Login View</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn view_login(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Check if already logged in
    if ctx.has_session() {
        if let Some(session) = ctx.session() {
            if session.is_authenticated() {
                return ctx.redirect(&quot;/dashboard&quot;);
            }
        }
    }
    
    ctx.layout(&quot;&quot;)  // No layout for login page
       .view(&quot;/auth/login&quot;, json!({
           &quot;title&quot;: &quot;Login&quot;
       }))
}
#}</code></pre></pre>
<a class="header" href="print.html#login-handler" id="login-handler"><h3>Login Handler</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn do_login(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form: LoginForm = ctx.body_form_typed()?;
    
    // Validation
    if form.email.trim().is_empty() {
        ctx.flash_error(&quot;Email is required&quot;)?;
        return ctx.redirect(&quot;/auth/login&quot;);
    }
    
    if form.password.is_empty() {
        ctx.flash_error(&quot;Password is required&quot;)?;
        return ctx.redirect(&quot;/auth/login&quot;);
    }
    
    // In a real app, verify credentials against database
    // This is a simplified example
    if form.email == &quot;admin@example.com&quot; &amp;&amp; form.password == &quot;password123&quot; {
        // Get or create session
        let session = ctx.require_session()?;
        
        // Store user data in session
        ctx.session_set(&quot;user&quot;, json!({
            &quot;id&quot;: 1,
            &quot;email&quot;: form.email,
            &quot;name&quot;: &quot;Admin User&quot;,
            &quot;role&quot;: &quot;admin&quot;
        }))?;
        
        // Mark as authenticated
        ctx.login(1)?;
        
        ctx.flash_success(&quot;Login successful!&quot;)?;
        ctx.redirect(&quot;/dashboard&quot;)
    } else {
        ctx.flash_error(&quot;Invalid email or password&quot;)?;
        ctx.redirect(&quot;/auth/login&quot;)
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#registration-view" id="registration-view"><h3>Registration View</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn view_register(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    ctx.layout(&quot;&quot;)
       .view(&quot;/auth/register&quot;, json!({
           &quot;title&quot;: &quot;Create Account&quot;
       }))
}
#}</code></pre></pre>
<a class="header" href="print.html#registration-handler" id="registration-handler"><h3>Registration Handler</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn do_register(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let form: RegisterForm = ctx.body_form_typed()?;
    
    // Validation
    if form.name.trim().is_empty() {
        ctx.flash_error(&quot;Name is required&quot;)?;
        return ctx.redirect(&quot;/auth/register&quot;);
    }
    
    if form.email.trim().is_empty() || !form.email.contains('@') {
        ctx.flash_error(&quot;Valid email is required&quot;)?;
        return ctx.redirect(&quot;/auth/register&quot;);
    }
    
    if form.password.len() &lt; 8 {
        ctx.flash_error(&quot;Password must be at least 8 characters&quot;)?;
        return ctx.redirect(&quot;/auth/register&quot;);
    }
    
    if form.password != form.password_confirm {
        ctx.flash_error(&quot;Passwords do not match&quot;)?;
        return ctx.redirect(&quot;/auth/register&quot;);
    }
    
    // In a real app, create user in database
    // Hash password before storing
    
    ctx.flash_success(&quot;Account created successfully! Please login.&quot;)?;
    ctx.redirect(&quot;/auth/login&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#logout-handler" id="logout-handler"><h3>Logout Handler</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn do_logout(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    ctx.logout()?;
    ctx.flash_info(&quot;You have been logged out&quot;)?;
    ctx.redirect(&quot;/auth/login&quot;)
}
#}</code></pre></pre>
<a class="header" href="print.html#protected-routes" id="protected-routes"><h2>Protected Routes</h2></a>
<a class="header" href="print.html#create-auth-middleware" id="create-auth-middleware"><h3>Create Auth Middleware</h3></a>
<p>Create <code>src/middleware/auth.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use rustf::prelude::*;

pub struct AuthMiddleware;

impl InboundMiddleware for AuthMiddleware {
    fn handle(&amp;self, ctx: &amp;mut Context) -&gt; MiddlewareResult {
        // Check if route requires authentication
        let path = ctx.path();
        let protected_paths = [&quot;/dashboard&quot;, &quot;/profile&quot;, &quot;/settings&quot;];
        
        if protected_paths.iter().any(|p| path.starts_with(p)) {
            if let Some(session) = ctx.session() {
                if session.is_authenticated() {
                    return MiddlewareResult::Continue;
                }
            }
            
            // Not authenticated, redirect to login
            ctx.flash_error(&quot;Please login to access this page&quot;)?;
            if let Err(e) = ctx.redirect(&quot;/auth/login&quot;) {
                return MiddlewareResult::Error(e);
            }
            return MiddlewareResult::Stop;
        }
        
        MiddlewareResult::Continue
    }
}

pub fn install(registry: &amp;mut MiddlewareRegistry) {
    registry.register(&quot;auth&quot;, AuthMiddleware);
}
#}</code></pre></pre>
<a class="header" href="print.html#register-middleware" id="register-middleware"><h3>Register Middleware</h3></a>
<p>In <code>src/main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = RustF::new()
    .controllers(auto_controllers!())
    .middleware_from(auto_middleware!());
#}</code></pre></pre>
<a class="header" href="print.html#accessing-user-data" id="accessing-user-data"><h2>Accessing User Data</h2></a>
<a class="header" href="print.html#in-controllers-4" id="in-controllers-4"><h3>In Controllers</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn dashboard(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Get user from session
    let user: Option&lt;serde_json::Value&gt; = ctx.session_get(&quot;user&quot;);
    
    if let Some(user_data) = user {
        ctx.repository_set(&quot;user&quot;, user_data.clone());
        ctx.view(&quot;/dashboard/index&quot;, json!({
            &quot;title&quot;: &quot;Dashboard&quot;
        }))
    } else {
        ctx.throw401(Some(&quot;Not authenticated&quot;))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#in-templates" id="in-templates"><h3>In Templates</h3></a>
<pre><code class="language-html">&lt;!-- views/dashboard/index.html --&gt;
@{if repository.user}
    &lt;h1&gt;Welcome, @{repository.user.name}!&lt;/h1&gt;
    &lt;p&gt;Email: @{repository.user.email}&lt;/p&gt;
    &lt;p&gt;Role: @{repository.user.role}&lt;/p&gt;
@{fi}
</code></pre>
<a class="header" href="print.html#security-best-practices" id="security-best-practices"><h2>Security Best Practices</h2></a>
<ol>
<li>
<p><strong>Password Hashing</strong>: Always hash passwords before storing</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use bcrypt;
let hashed = bcrypt::hash(password, bcrypt::DEFAULT_COST)?;
#}</code></pre></pre>
</li>
<li>
<p><strong>Session Security</strong>: Use secure, HTTP-only cookies in production</p>
<pre><code class="language-toml">[session]
secure = true
http_only = true
</code></pre>
</li>
<li>
<p><strong>CSRF Protection</strong>: Enable CSRF protection - See <a href="../guides/security.md">Security Guide</a></p>
</li>
<li>
<p><strong>Rate Limiting</strong>: Add rate limiting to login endpoints</p>
</li>
<li>
<p><strong>Input Validation</strong>: Always validate and sanitize user input</p>
</li>
</ol>
<a class="header" href="print.html#next-steps-5" id="next-steps-5"><h2>Next Steps</h2></a>
<ul>
<li>Add password reset functionality</li>
<li>Add email verification</li>
<li>Add two-factor authentication</li>
<li>Add role-based access control (RBAC)</li>
<li>Integrate with OAuth providers</li>
</ul>
<a class="header" href="print.html#real-world-application-example" id="real-world-application-example"><h1>Real-World Application Example</h1></a>
<p>This guide demonstrates building a complete blog application with RustF, covering all major framework features.</p>
<a class="header" href="print.html#application-overview" id="application-overview"><h2>Application Overview</h2></a>
<p>We'll build a blog application with:</p>
<ul>
<li>User authentication</li>
<li>Blog post management</li>
<li>Comments system</li>
<li>Admin panel</li>
<li>Search functionality</li>
</ul>
<a class="header" href="print.html#project-structure-1" id="project-structure-1"><h2>Project Structure</h2></a>
<pre><code>blog-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ home.rs
â”‚   â”‚   â”œâ”€â”€ auth.rs
â”‚   â”‚   â”œâ”€â”€ posts.rs
â”‚   â”‚   â”œâ”€â”€ comments.rs
â”‚   â”‚   â””â”€â”€ admin/
â”‚   â”‚       â””â”€â”€ dashboard.rs
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ users.rs
â”‚   â”‚   â”œâ”€â”€ posts.rs
â”‚   â”‚   â””â”€â”€ comments.rs
â”‚   â”œâ”€â”€ modules/
â”‚   â”‚   â”œâ”€â”€ user_service.rs
â”‚   â”‚   â””â”€â”€ post_service.rs
â”‚   â””â”€â”€ middleware/
â”‚       â””â”€â”€ auth.rs
â”œâ”€â”€ views/
â”‚   â”œâ”€â”€ layouts/
â”‚   â”‚   â””â”€â”€ application.html
â”‚   â”œâ”€â”€ home/
â”‚   â”‚   â””â”€â”€ index.html
â”‚   â”œâ”€â”€ posts/
â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”œâ”€â”€ show.html
â”‚   â”‚   â””â”€â”€ create.html
â”‚   â””â”€â”€ auth/
â”‚       â”œâ”€â”€ login.html
â”‚       â””â”€â”€ register.html
â””â”€â”€ config.toml
</code></pre>
<a class="header" href="print.html#main-application" id="main-application"><h2>Main Application</h2></a>
<a class="header" href="print.html#srcmainrs-1" id="srcmainrs-1"><h3>src/main.rs</h3></a>
<pre><pre class="playpen"><code class="language-rust">use rustf::prelude::*;

#[tokio::main]
async fn main() -&gt; rustf::Result&lt;()&gt; {
    env_logger::init();
    
    let app = RustF::new()
        .controllers(auto_controllers!())
        .models(auto_models!())
        .middleware_from(auto_middleware!());
    
    println!(&quot;ğŸš€ Blog application running at http://127.0.0.1:8000&quot;);
    app.start().await
}
</code></pre></pre>
<a class="header" href="print.html#controllers" id="controllers"><h2>Controllers</h2></a>
<a class="header" href="print.html#home-controller" id="home-controller"><h3>Home Controller</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/controllers/home.rs
use rustf::prelude::*;

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET &quot;/&quot; =&gt; index,
        GET &quot;/search&quot; =&gt; search,
    ]
}

async fn index(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Get recent posts
    let recent_posts = get_recent_posts(5)?;
    
    ctx.repository_set(&quot;recent_posts&quot;, json!(recent_posts));
    ctx.view(&quot;/home/index&quot;, json!({
        &quot;title&quot;: &quot;Welcome to My Blog&quot;
    }))
}

async fn search(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let query = ctx.query(&quot;q&quot;).unwrap_or(&quot;&quot;);
    
    if query.is_empty() {
        return ctx.redirect(&quot;/&quot;);
    }
    
    let results = search_posts(query)?;
    
    ctx.view(&quot;/home/search&quot;, json!({
        &quot;title&quot;: format!(&quot;Search: {}&quot;, query),
        &quot;query&quot;: query,
        &quot;results&quot;: results
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#posts-controller" id="posts-controller"><h3>Posts Controller</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/controllers/posts.rs
use rustf::prelude::*;

pub fn install() -&gt; Vec&lt;Route&gt; {
    routes![
        GET  &quot;/posts&quot;          =&gt; index,
        GET  &quot;/posts/{id}&quot;     =&gt; show,
        GET  &quot;/posts/create&quot;   =&gt; create_form,
        POST &quot;/posts&quot;          =&gt; create,
        GET  &quot;/posts/{id}/edit&quot; =&gt; edit_form,
        PUT  &quot;/posts/{id}&quot;     =&gt; update,
        DELETE &quot;/posts/{id}&quot;   =&gt; delete,
    ]
}

async fn index(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let page = ctx.int_query_or(&quot;page&quot;, 1);
    let posts = get_posts_paginated(page, 10)?;
    
    ctx.view(&quot;/posts/index&quot;, json!({
        &quot;title&quot;: &quot;All Posts&quot;,
        &quot;posts&quot;: posts,
        &quot;page&quot;: page
    }))
}

async fn show(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    let post_id = ctx.int_param(&quot;id&quot;)?;
    let post = get_post_by_id(post_id)?;
    
    if post.is_none() {
        return ctx.throw404(Some(&quot;Post not found&quot;));
    }
    
    let comments = get_comments_for_post(post_id)?;
    
    ctx.view(&quot;/posts/show&quot;, json!({
        &quot;title&quot;: post.title.clone(),
        &quot;post&quot;: post,
        &quot;comments&quot;: comments
    }))
}

async fn create(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Require authentication
    ctx.require_auth()?;
    
    let form: CreatePostForm = ctx.body_form_typed()?;
    
    // Validation
    validate_post_form(&amp;form)?;
    
    // Create post
    let post = create_new_post(&amp;form, get_current_user_id(ctx)?)?;
    
    ctx.flash_success(&quot;Post created successfully!&quot;)?;
    ctx.redirect(&amp;format!(&quot;/posts/{}&quot;, post.id))
}
#}</code></pre></pre>
<a class="header" href="print.html#models" id="models"><h2>Models</h2></a>
<a class="header" href="print.html#post-model" id="post-model"><h3>Post Model</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/models/posts.rs
use rustf::prelude::*;

pub struct Posts {
    base: PostsBase,
}

impl Posts {
    pub fn new() -&gt; Self {
        Self {
            base: PostsBase::new(),
        }
    }
    
    pub fn find_recent(&amp;self, limit: i32) -&gt; Result&lt;Vec&lt;Post&gt;&gt; {
        self.base.query()
            .where_eq(&quot;published&quot;, true)
            .order_by(&quot;created_at&quot;, OrderDirection::Desc)
            .limit(limit)
            .find()
    }
    
    pub fn search(&amp;self, query: &amp;str) -&gt; Result&lt;Vec&lt;Post&gt;&gt; {
        self.base.query()
            .where_like(&quot;title&quot;, &amp;format!(&quot;%{}%&quot;, query))
            .or_where_like(&quot;content&quot;, &amp;format!(&quot;%{}%&quot;, query))
            .where_eq(&quot;published&quot;, true)
            .find()
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#modules" id="modules"><h2>Modules</h2></a>
<a class="header" href="print.html#post-service" id="post-service"><h3>Post Service</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/modules/post_service.rs
use rustf::prelude::*;

pub struct PostService;

impl PostService {
    pub fn create_post(&amp;self, data: &amp;CreatePostData, author_id: i32) -&gt; Result&lt;Post&gt; {
        // Business logic for creating posts
        // Validation, formatting, etc.
    }
    
    pub fn can_edit(&amp;self, post: &amp;Post, user_id: i32) -&gt; bool {
        post.author_id == user_id || is_admin(user_id)
    }
}

impl_shared_service!(PostService);
#}</code></pre></pre>
<a class="header" href="print.html#middleware" id="middleware"><h2>Middleware</h2></a>
<a class="header" href="print.html#auth-middleware" id="auth-middleware"><h3>Auth Middleware</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// src/middleware/auth.rs
use rustf::prelude::*;

pub struct AuthMiddleware;

impl InboundMiddleware for AuthMiddleware {
    fn handle(&amp;self, ctx: &amp;mut Context) -&gt; MiddlewareResult {
        let path = ctx.path();
        
        // Protected paths
        if path.starts_with(&quot;/posts/create&quot;) || 
           path.starts_with(&quot;/posts/&quot;) &amp;&amp; ctx.req.method() == &quot;POST&quot; {
            
            if !ctx.has_session() || 
               !ctx.session().map(|s| s.is_authenticated()).unwrap_or(false) {
                ctx.flash_error(&quot;Please login to continue&quot;)?;
                ctx.redirect(&quot;/auth/login&quot;);
                return MiddlewareResult::Stop;
            }
        }
        
        MiddlewareResult::Continue
    }
}

pub fn install(registry: &amp;mut MiddlewareRegistry) {
    registry.register(&quot;auth&quot;, AuthMiddleware);
}
#}</code></pre></pre>
<a class="header" href="print.html#configuration-4" id="configuration-4"><h2>Configuration</h2></a>
<a class="header" href="print.html#configtoml" id="configtoml"><h3>config.toml</h3></a>
<pre><code class="language-toml">[server]
host = &quot;127.0.0.1&quot;
port = 8000

[database]
url = &quot;sqlite:blog.db&quot;

[session]
timeout = 3600
secure = false
http_only = true

[views]
directory = &quot;views&quot;
cache_enabled = false
default_layout = &quot;layouts/application&quot;
</code></pre>
<a class="header" href="print.html#views" id="views"><h2>Views</h2></a>
<a class="header" href="print.html#layout" id="layout"><h3>Layout</h3></a>
<pre><code class="language-html">&lt;!-- views/layouts/application.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;@{model.title} - My Blog&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;nav&gt;
        &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;
        &lt;a href=&quot;/posts&quot;&gt;Posts&lt;/a&gt;
        @{if repository.user}
            &lt;a href=&quot;/posts/create&quot;&gt;New Post&lt;/a&gt;
            &lt;a href=&quot;/auth/logout&quot;&gt;Logout&lt;/a&gt;
        @{else}
            &lt;a href=&quot;/auth/login&quot;&gt;Login&lt;/a&gt;
        @{fi}
    &lt;/nav&gt;
    
    @{if flash.success_msg}
        &lt;div class=&quot;alert success&quot;&gt;@{flash.success_msg}&lt;/div&gt;
    @{fi}
    
    @{if flash.error_msg}
        &lt;div class=&quot;alert error&quot;&gt;@{flash.error_msg}&lt;/div&gt;
    @{fi}
    
    &lt;main&gt;
        {{@body}}
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<a class="header" href="print.html#testing-1" id="testing-1"><h2>Testing</h2></a>
<a class="header" href="print.html#manual-testing" id="manual-testing"><h3>Manual Testing</h3></a>
<pre><code class="language-bash"># Start server
cargo run

# Test endpoints
curl http://localhost:8000/
curl http://localhost:8000/posts
curl http://localhost:8000/posts/1
</code></pre>
<a class="header" href="print.html#integration-tests" id="integration-tests"><h3>Integration Tests</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_create_post() {
        // Test post creation
    }
    
    #[tokio::test]
    async fn test_search_posts() {
        // Test search functionality
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#deployment" id="deployment"><h2>Deployment</h2></a>
<p>See the <a href="../deployment/production.md">Deployment Guide</a> for production deployment instructions.</p>
<a class="header" href="print.html#next-steps-6" id="next-steps-6"><h2>Next Steps</h2></a>
<ul>
<li>Add email notifications</li>
<li>Add RSS feed</li>
<li>Add social sharing</li>
<li>Add analytics</li>
<li>Add caching layer</li>
<li>Add CDN for static assets</li>
</ul>
<a class="header" href="print.html#production-deployment" id="production-deployment"><h1>Production Deployment</h1></a>
<p>This guide covers deploying RustF applications to production environments.</p>
<a class="header" href="print.html#prerequisites-1" id="prerequisites-1"><h2>Prerequisites</h2></a>
<ul>
<li>Rust 1.70+ installed</li>
<li>Production-ready database</li>
<li>Reverse proxy (nginx, Caddy, etc.)</li>
<li>SSL certificate (Let's Encrypt recommended)</li>
</ul>
<a class="header" href="print.html#build-for-production" id="build-for-production"><h2>Build for Production</h2></a>
<a class="header" href="print.html#release-build" id="release-build"><h3>Release Build</h3></a>
<pre><code class="language-bash"># Build optimized release binary
cargo build --release

# Binary will be in target/release/your-app-name
</code></pre>
<a class="header" href="print.html#build-flags" id="build-flags"><h3>Build Flags</h3></a>
<p>For maximum optimization:</p>
<pre><code class="language-bash">RUSTFLAGS=&quot;-C target-cpu=native&quot; cargo build --release
</code></pre>
<a class="header" href="print.html#configuration-5" id="configuration-5"><h2>Configuration</h2></a>
<a class="header" href="print.html#production-config" id="production-config"><h3>Production Config</h3></a>
<p>Create <code>config.prod.toml</code>:</p>
<pre><code class="language-toml">environment = &quot;production&quot;

[server]
host = &quot;0.0.0.0&quot;
port = 8080
timeout = 30

[database]
url = &quot;postgresql://user:pass@localhost/dbname&quot;
pool_size = 20

[session]
timeout = 7200
secure = true
http_only = true
cookie_name = &quot;app_session&quot;

[views]
cache_enabled = true
directory = &quot;views&quot;

[logging]
level = &quot;warn&quot;
output = &quot;file&quot;
file_path = &quot;/var/log/app/error.log&quot;
</code></pre>
<a class="header" href="print.html#environment-variables-3" id="environment-variables-3"><h3>Environment Variables</h3></a>
<p>Set environment variables:</p>
<pre><code class="language-bash">export RUSTF_ENV=production
export DATABASE_URL=postgresql://user:pass@localhost/dbname
export SECRET_KEY=your-secret-key-here
</code></pre>
<a class="header" href="print.html#systemd-service" id="systemd-service"><h2>Systemd Service</h2></a>
<p>Create <code>/etc/systemd/system/rustf-app.service</code>:</p>
<pre><code class="language-ini">[Unit]
Description=RustF Application
After=network.target

[Service]
Type=simple
User=www-data
WorkingDirectory=/opt/rustf-app
ExecStart=/opt/rustf-app/target/release/rustf-app
Restart=always
RestartSec=10
Environment=&quot;RUSTF_ENV=production&quot;
Environment=&quot;RUST_LOG=warn&quot;

[Install]
WantedBy=multi-user.target
</code></pre>
<p>Enable and start:</p>
<pre><code class="language-bash">sudo systemctl enable rustf-app
sudo systemctl start rustf-app
sudo systemctl status rustf-app
</code></pre>
<a class="header" href="print.html#nginx-configuration" id="nginx-configuration"><h2>Nginx Configuration</h2></a>
<a class="header" href="print.html#reverse-proxy-setup" id="reverse-proxy-setup"><h3>Reverse Proxy Setup</h3></a>
<p>Create <code>/etc/nginx/sites-available/rustf-app</code>:</p>
<pre><code class="language-nginx">server {
    listen 80;
    server_name your-domain.com;
    
    # Redirect to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;
    
    # Security headers
    add_header X-Frame-Options &quot;SAMEORIGIN&quot; always;
    add_header X-Content-Type-Options &quot;nosniff&quot; always;
    add_header X-XSS-Protection &quot;1; mode=block&quot; always;
    
    # Proxy to RustF app
    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
    
    # Static files
    location /static/ {
        alias /opt/rustf-app/public/;
        expires 30d;
        add_header Cache-Control &quot;public, immutable&quot;;
    }
}
</code></pre>
<p>Enable site:</p>
<pre><code class="language-bash">sudo ln -s /etc/nginx/sites-available/rustf-app /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl reload nginx
</code></pre>
<a class="header" href="print.html#database-setup" id="database-setup"><h2>Database Setup</h2></a>
<a class="header" href="print.html#run-migrations" id="run-migrations"><h3>Run Migrations</h3></a>
<pre><code class="language-bash"># In production
rustf-cli migrate up
</code></pre>
<a class="header" href="print.html#backup-strategy" id="backup-strategy"><h3>Backup Strategy</h3></a>
<p>Set up regular database backups:</p>
<pre><code class="language-bash"># PostgreSQL
pg_dump -U user dbname &gt; backup_$(date +%Y%m%d).sql

# SQLite
cp db.sqlite backup_$(date +%Y%m%d).sqlite
</code></pre>
<a class="header" href="print.html#monitoring-1" id="monitoring-1"><h2>Monitoring</h2></a>
<a class="header" href="print.html#log-management" id="log-management"><h3>Log Management</h3></a>
<ul>
<li>Use structured logging</li>
<li>Set up log rotation</li>
<li>Monitor error logs</li>
<li>Use log aggregation (ELK, Loki, etc.)</li>
</ul>
<a class="header" href="print.html#health-checks-1" id="health-checks-1"><h3>Health Checks</h3></a>
<p>Add health check endpoint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
async fn health(ctx: &amp;mut Context) -&gt; Result&lt;()&gt; {
    // Check database connection
    let db_ok = check_database().is_ok();
    
    ctx.json(json!({
        &quot;status&quot;: if db_ok { &quot;healthy&quot; } else { &quot;unhealthy&quot; },
        &quot;database&quot;: if db_ok { &quot;connected&quot; } else { &quot;disconnected&quot; },
        &quot;timestamp&quot;: chrono::Utc::now().to_rfc3339()
    }))
}
#}</code></pre></pre>
<a class="header" href="print.html#metrics" id="metrics"><h3>Metrics</h3></a>
<p>Consider adding:</p>
<ul>
<li>Request rate</li>
<li>Response times</li>
<li>Error rates</li>
<li>Database connection pool status</li>
</ul>
<a class="header" href="print.html#security-checklist" id="security-checklist"><h2>Security Checklist</h2></a>
<ul>
<li>[ ] Use HTTPS (SSL/TLS)</li>
<li>[ ] Set secure session cookies</li>
<li>[ ] Enable CSRF protection</li>
<li>[ ] Set security headers</li>
<li>[ ] Use environment variables for secrets</li>
<li>[ ] Keep dependencies updated</li>
<li>[ ] Use strong database passwords</li>
<li>[ ] Enable rate limiting</li>
<li>[ ] Set up firewall rules</li>
<li>[ ] Regular security audits</li>
</ul>
<a class="header" href="print.html#performance-optimization-1" id="performance-optimization-1"><h2>Performance Optimization</h2></a>
<a class="header" href="print.html#enable-view-caching-1" id="enable-view-caching-1"><h3>Enable View Caching</h3></a>
<pre><code class="language-toml">[views]
cache_enabled = true
</code></pre>
<a class="header" href="print.html#database-connection-pooling" id="database-connection-pooling"><h3>Database Connection Pooling</h3></a>
<pre><code class="language-toml">[database]
pool_size = 20
max_connections = 50
</code></pre>
<a class="header" href="print.html#static-file-serving-1" id="static-file-serving-1"><h3>Static File Serving</h3></a>
<p>Serve static files via nginx/CDN, not the application.</p>
<a class="header" href="print.html#enable-compression" id="enable-compression"><h3>Enable Compression</h3></a>
<p>Configure nginx gzip:</p>
<pre><code class="language-nginx">gzip on;
gzip_types text/plain text/css application/json application/javascript;
</code></pre>
<a class="header" href="print.html#scaling" id="scaling"><h2>Scaling</h2></a>
<a class="header" href="print.html#horizontal-scaling" id="horizontal-scaling"><h3>Horizontal Scaling</h3></a>
<ul>
<li>Use load balancer (nginx, HAProxy)</li>
<li>Use shared session storage (Redis)</li>
<li>Use shared database</li>
<li>Use CDN for static assets</li>
</ul>
<a class="header" href="print.html#vertical-scaling" id="vertical-scaling"><h3>Vertical Scaling</h3></a>
<ul>
<li>Increase server resources</li>
<li>Optimize database queries</li>
<li>Use connection pooling</li>
<li>Enable caching</li>
</ul>
<a class="header" href="print.html#troubleshooting-8" id="troubleshooting-8"><h2>Troubleshooting</h2></a>
<a class="header" href="print.html#check-logs" id="check-logs"><h3>Check Logs</h3></a>
<pre><code class="language-bash"># Application logs
sudo journalctl -u rustf-app -f

# Nginx logs
sudo tail -f /var/log/nginx/error.log
</code></pre>
<a class="header" href="print.html#common-issues-4" id="common-issues-4"><h3>Common Issues</h3></a>
<p><strong>Issue: Application won't start</strong></p>
<ul>
<li>Check systemd service status</li>
<li>Verify configuration file</li>
<li>Check database connection</li>
</ul>
<p><strong>Issue: 502 Bad Gateway</strong></p>
<ul>
<li>Check if app is running</li>
<li>Verify port configuration</li>
<li>Check firewall rules</li>
</ul>
<p><strong>Issue: Database connection errors</strong></p>
<ul>
<li>Verify database URL</li>
<li>Check database is running</li>
<li>Verify credentials</li>
</ul>
<a class="header" href="print.html#next-steps-7" id="next-steps-7"><h2>Next Steps</h2></a>
<ul>
<li>Set up CI/CD pipeline</li>
<li>Configure monitoring alerts</li>
<li>Set up automated backups</li>
<li>Plan for disaster recovery</li>
</ul>
<a class="header" href="print.html#docker-deployment" id="docker-deployment"><h1>Docker Deployment</h1></a>
<p>This guide covers containerizing and deploying RustF applications with Docker.</p>
<a class="header" href="print.html#dockerfile" id="dockerfile"><h2>Dockerfile</h2></a>
<a class="header" href="print.html#multi-stage-build" id="multi-stage-build"><h3>Multi-Stage Build</h3></a>
<p>Create <code>Dockerfile</code>:</p>
<pre><code class="language-dockerfile"># Build stage
FROM rust:1.70 as builder

WORKDIR /app

# Copy dependency files
COPY Cargo.toml Cargo.lock ./
COPY rustf/Cargo.toml ./rustf/
COPY rustf-macros/Cargo.toml ./rustf-macros/

# Copy source code
COPY . .

# Build release binary
RUN cargo build --release

# Runtime stage
FROM debian:bookworm-slim

# Install runtime dependencies
RUN apt-get update &amp;&amp; apt-get install -y \
    ca-certificates \
    libssl3 \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy binary from builder
COPY --from=builder /app/target/release/rustf-app /app/rustf-app

# Copy configuration and static files
COPY config.toml ./
COPY views ./views
COPY public ./public

# Create non-root user
RUN useradd -m -u 1000 appuser &amp;&amp; \
    chown -R appuser:appuser /app

USER appuser

EXPOSE 8000

CMD [&quot;./rustf-app&quot;]
</code></pre>
<a class="header" href="print.html#docker-compose" id="docker-compose"><h2>Docker Compose</h2></a>
<p>Create <code>docker-compose.yml</code>:</p>
<pre><code class="language-yaml">version: '3.8'

services:
  app:
    build: .
    ports:
      - &quot;8000:8000&quot;
    environment:
      - RUSTF_ENV=production
      - DATABASE_URL=postgresql://user:pass@db:5432/dbname
    depends_on:
      - db
      - redis
    volumes:
      - ./config.toml:/app/config.toml
      - ./views:/app/views
      - ./public:/app/public
    restart: unless-stopped

  db:
    image: postgres:15
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=dbname
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
</code></pre>
<a class="header" href="print.html#build-and-run" id="build-and-run"><h2>Build and Run</h2></a>
<a class="header" href="print.html#build-image" id="build-image"><h3>Build Image</h3></a>
<pre><code class="language-bash">docker build -t rustf-app .
</code></pre>
<a class="header" href="print.html#run-container" id="run-container"><h3>Run Container</h3></a>
<pre><code class="language-bash">docker run -d \
  -p 8000:8000 \
  -e RUSTF_ENV=production \
  -v $(pwd)/config.toml:/app/config.toml \
  --name rustf-app \
  rustf-app
</code></pre>
<a class="header" href="print.html#docker-compose-1" id="docker-compose-1"><h3>Docker Compose</h3></a>
<pre><code class="language-bash"># Start all services
docker-compose up -d

# View logs
docker-compose logs -f

# Stop services
docker-compose down
</code></pre>
<a class="header" href="print.html#production-dockerfile" id="production-dockerfile"><h2>Production Dockerfile</h2></a>
<p>Optimized for production:</p>
<pre><code class="language-dockerfile">FROM rust:1.70 as builder

WORKDIR /app

# Install build dependencies
RUN apt-get update &amp;&amp; apt-get install -y \
    pkg-config \
    libssl-dev \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Copy and build
COPY . .
RUN cargo build --release

FROM debian:bookworm-slim

RUN apt-get update &amp;&amp; apt-get install -y \
    ca-certificates \
    libssl3 \
    &amp;&amp; rm -rf /var/lib/apt/lists/* \
    &amp;&amp; useradd -m -u 1000 appuser

WORKDIR /app

COPY --from=builder /app/target/release/rustf-app /app/
COPY --from=builder /app/config.toml ./
COPY --from=builder /app/views ./views
COPY --from=builder /app/public ./public

RUN chown -R appuser:appuser /app

USER appuser

EXPOSE 8000

HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:8000/health || exit 1

CMD [&quot;./rustf-app&quot;]
</code></pre>
<a class="header" href="print.html#dockerignore" id="dockerignore"><h2>.dockerignore</h2></a>
<p>Create <code>.dockerignore</code>:</p>
<pre><code>target/
.git/
.gitignore
*.md
.env
.env.local
*.log
</code></pre>
<a class="header" href="print.html#kubernetes" id="kubernetes"><h2>Kubernetes</h2></a>
<a class="header" href="print.html#deployment-1" id="deployment-1"><h3>Deployment</h3></a>
<p>Create <code>k8s/deployment.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: rustf-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rustf-app
  template:
    metadata:
      labels:
        app: rustf-app
    spec:
      containers:
      - name: rustf-app
        image: rustf-app:latest
        ports:
        - containerPort: 8000
        env:
        - name: RUSTF_ENV
          value: &quot;production&quot;
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        resources:
          requests:
            memory: &quot;256Mi&quot;
            cpu: &quot;250m&quot;
          limits:
            memory: &quot;512Mi&quot;
            cpu: &quot;500m&quot;
</code></pre>
<a class="header" href="print.html#service" id="service"><h3>Service</h3></a>
<p>Create <code>k8s/service.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: rustf-app
spec:
  selector:
    app: rustf-app
  ports:
  - port: 80
    targetPort: 8000
  type: LoadBalancer
</code></pre>
<a class="header" href="print.html#best-practices-21" id="best-practices-21"><h2>Best Practices</h2></a>
<ol>
<li><strong>Use multi-stage builds</strong> to reduce image size</li>
<li><strong>Run as non-root user</strong> for security</li>
<li><strong>Use .dockerignore</strong> to exclude unnecessary files</li>
<li><strong>Set resource limits</strong> in production</li>
<li><strong>Use health checks</strong> for monitoring</li>
<li><strong>Keep images updated</strong> with security patches</li>
<li><strong>Use secrets management</strong> for sensitive data</li>
<li><strong>Enable logging</strong> for debugging</li>
</ol>
<a class="header" href="print.html#troubleshooting-9" id="troubleshooting-9"><h2>Troubleshooting</h2></a>
<a class="header" href="print.html#container-wont-start" id="container-wont-start"><h3>Container won't start</h3></a>
<pre><code class="language-bash"># Check logs
docker logs rustf-app

# Run interactively
docker run -it rustf-app /bin/bash
</code></pre>
<a class="header" href="print.html#database-connection-issues" id="database-connection-issues"><h3>Database connection issues</h3></a>
<ul>
<li>Verify database URL</li>
<li>Check network connectivity</li>
<li>Verify credentials</li>
</ul>
<a class="header" href="print.html#performance-issues-1" id="performance-issues-1"><h3>Performance issues</h3></a>
<ul>
<li>Increase resource limits</li>
<li>Enable connection pooling</li>
<li>Use caching layer</li>
</ul>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
