//! {{table_name}} model - Generated from schema {{table.table}} v{{table.version}}
{{#if table.description}}
//! {{table.description}}
{{/if}}
//! 
//! DO NOT EDIT - This file is auto-generated from schema
//! To make changes, edit the schema YAML file and regenerate

use serde::{Deserialize, Serialize};
use sqlx::{FromRow, Row};
{{#if variables.needs_chrono}}
use chrono::{DateTime, Utc, NaiveDate, NaiveTime};
{{/if}}
{{#if variables.needs_decimal}}
use rust_decimal::Decimal;
{{/if}}
{{#if variables.needs_uuid}}
use uuid::Uuid;
{{/if}}

{{#if table.description}}
/// {{table.description}}
{{/if}}
{{#if table.ai_context}}
/// 
/// AI Context: {{table.ai_context}}
{{/if}}
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
#[rustf_schema(table = "{{table.table}}", version = {{table.version}})]
pub struct {{table_name}} {
{{#each variables.rust_fields}}
    {{#if ai_hint}}
    /// {{ai_hint}}
    {{/if}}
    {{#if primary_key}}
    #[serde(skip_serializing_if = "Option::is_none")]
    {{/if}}
    pub {{name}}: {{rust_type}},
{{/each}}
}

/// Type constants for AI agent reference
/// 
/// AI agents can use these type aliases to generate consistent,
/// schema-aware code without hardcoding types.
/// 
/// Example: {{table_name}}::Types::{{#each variables.rust_fields}}{{#if @first}}{{name}}{{/if}}{{/each}} resolves to {{#each variables.rust_fields}}{{#if @first}}{{rust_type}}{{/if}}{{/each}}
pub mod Types {
{{#if variables.needs_chrono}}
    use chrono::{DateTime, Utc, NaiveDate, NaiveTime};
{{/if}}
{{#if variables.needs_decimal}}
    use rust_decimal::Decimal;
{{/if}}
{{#if variables.needs_uuid}}
    use uuid::Uuid;
{{/if}}
{{#if variables.needs_json}}
    use serde_json;
{{/if}}
    
{{#each variables.type_constants}}
    pub type {{name}} = {{rust_type}};
{{/each}}
}

impl {{table_name}} {
    /// Create a new instance
    pub fn new() -> Self {
        Self {
{{#each variables.rust_fields}}
            {{#if auto_increment}}
            {{name}}: None, // Will be auto-generated
            {{else if default}}
            {{name}}: {{#if nullable}}Some({{/if}}{{default}}{{#if nullable}}){{/if}},
            {{else}}
            {{name}}: {{#if nullable}}None{{else}}Default::default(){{/if}},
            {{/if}}
{{/each}}
        }
    }

    /// Insert this record into the database
    pub async fn insert(&self, pool: &sqlx::PgPool) -> Result<{{table_name}}, sqlx::Error> {
        let row = sqlx::query!(
            r#"
            INSERT INTO {{table.table}} ({{#each variables.insert_fields}}{{this}}{{#unless @last}}, {{/unless}}{{/each}})
            VALUES ({{#each variables.insert_fields}}${{@index}}{{#unless @last}}, {{/unless}}{{/each}})
            RETURNING *
            "#,
{{#each variables.insert_fields}}
            self.{{this}}{{#unless @last}},{{/unless}}
{{/each}}
        )
        .fetch_one(pool)
        .await?;

        Ok({{table_name}}::from_row(&row)?)
    }

    /// Update this record in the database
    {{#if variables.primary_key}}
    pub async fn update(&self, pool: &sqlx::PgPool) -> Result<{{table_name}}, sqlx::Error> {
        let row = sqlx::query!(
            r#"
            UPDATE {{table.table}} 
            SET {{#each variables.update_fields}}{{this}} = ${{@index}}{{#unless @last}}, {{/unless}}{{/each}}
            WHERE {{variables.primary_key}} = ${{variables.update_fields.length}}
            RETURNING *
            "#,
{{#each variables.update_fields}}
            self.{{this}},
{{/each}}
            self.{{variables.primary_key}}
        )
        .fetch_one(pool)
        .await?;

        Ok({{table_name}}::from_row(&row)?)
    }
    {{/if}}

    /// Delete this record from the database
    {{#if variables.primary_key}}
    pub async fn delete(&self, pool: &sqlx::PgPool) -> Result<u64, sqlx::Error> {
        let result = sqlx::query!(
            "DELETE FROM {{table.table}} WHERE {{variables.primary_key}} = $1",
            self.{{variables.primary_key}}
        )
        .execute(pool)
        .await?;

        Ok(result.rows_affected())
    }
    {{/if}}
}

impl Default for {{table_name}} {
    fn default() -> Self {
        Self::new()
    }
}

// Static query methods
impl {{table_name}} {
    /// Find a record by primary key
    {{#if variables.primary_key}}
    pub async fn find(pool: &sqlx::PgPool, id: {{#each variables.rust_fields}}{{#if primary_key}}{{rust_type}}{{/if}}{{/each}}) -> Result<Option<{{table_name}}>, sqlx::Error> {
        let row = sqlx::query_as!(
            {{table_name}},
            "SELECT * FROM {{table.table}} WHERE {{variables.primary_key}} = $1",
            id
        )
        .fetch_optional(pool)
        .await?;

        Ok(row)
    }
    {{/if}}

    /// Find all records
    pub async fn find_all(pool: &sqlx::PgPool) -> Result<Vec<{{table_name}}>, sqlx::Error> {
        let rows = sqlx::query_as!(
            {{table_name}},
            "SELECT * FROM {{table.table}} ORDER BY {{#if variables.primary_key}}{{variables.primary_key}}{{else}}created_at{{/if}}"
        )
        .fetch_all(pool)
        .await?;

        Ok(rows)
    }

    /// Find records with custom where clause
    pub async fn find_where(pool: &sqlx::PgPool, where_clause: &str, params: &[&(dyn sqlx::Encode<sqlx::Postgres> + sqlx::Type<sqlx::Postgres> + Sync)]) -> Result<Vec<{{table_name}}>, sqlx::Error> {
        let query = format!("SELECT * FROM {{table.table}} WHERE {}", where_clause);
        
        let mut query_builder = sqlx::query_as::<_, {{table_name}}>(&query);
        for param in params {
            query_builder = query_builder.bind(param);
        }
        
        let rows = query_builder.fetch_all(pool).await?;
        Ok(rows)
    }

    /// Count all records
    pub async fn count(pool: &sqlx::PgPool) -> Result<i64, sqlx::Error> {
        let row = sqlx::query!(
            "SELECT COUNT(*) as count FROM {{table.table}}"
        )
        .fetch_one(pool)
        .await?;

        Ok(row.count.unwrap_or(0))
    }
}